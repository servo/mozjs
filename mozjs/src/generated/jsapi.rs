/* automatically generated by rust-bindgen 0.68.1 */

unsafe impl Sync for root::JSClass {}
unsafe impl Sync for root::JSFunctionSpec {}
unsafe impl Sync for root::JSNativeWrapper {}
unsafe impl Sync for root::JSPropertySpec {}
unsafe impl Sync for root::JSTypedMethodJitInfo {}

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub type FILE = ::libc::FILE;
    pub const JS_64BIT: u32 = 1;
    pub const JS_CODEGEN_X64: u32 = 1;
    pub const JS_DEFAULT_JITREPORT_GRANULARITY: u32 = 3;
    pub const JS_HAS_INTL_API: u32 = 1;
    pub const JS_PUNBOX64: u32 = 1;
    pub const JS_STANDALONE: u32 = 1;
    pub const JS_WITHOUT_NSPR: u32 = 1;
    pub const JS_BITS_PER_WORD: u32 = 64;
    pub const JS_STRUCTURED_CLONE_VERSION: u32 = 8;
    pub const JS_SCERR_RECURSION: u32 = 0;
    pub const JS_SCERR_TRANSFERABLE: u32 = 1;
    pub const JS_SCERR_DUP_TRANSFERABLE: u32 = 2;
    pub const JS_SCERR_UNSUPPORTED_TYPE: u32 = 3;
    pub const JS_SCERR_SHMEM_TRANSFERABLE: u32 = 4;
    pub const JS_SCERR_TYPED_ARRAY_DETACHED: u32 = 5;
    pub const JS_SCERR_WASM_NO_TRANSFER: u32 = 6;
    pub const JS_SCERR_NOT_CLONABLE: u32 = 7;
    pub const JS_SCERR_NOT_CLONABLE_WITH_COOP_COEP: u32 = 8;
    pub const JSITER_PRIVATE: u32 = 4;
    pub const JSITER_OWNONLY: u32 = 8;
    pub const JSITER_HIDDEN: u32 = 16;
    pub const JSITER_SYMBOLS: u32 = 32;
    pub const JSITER_SYMBOLSONLY: u32 = 64;
    pub const JSITER_FORAWAITOF: u32 = 128;
    pub type __off_t = ::std::os::raw::c_long;
    pub type __off64_t = ::std::os::raw::c_long;
    pub type uint_fast8_t = ::std::os::raw::c_uchar;
    pub type va_list = root::__builtin_va_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_marker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_codecvt {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_wide_data {
        _unused: [u8; 0],
    }
    pub type _IO_lock_t = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_FILE {
        pub _flags: ::std::os::raw::c_int,
        pub _IO_read_ptr: *mut ::std::os::raw::c_char,
        pub _IO_read_end: *mut ::std::os::raw::c_char,
        pub _IO_read_base: *mut ::std::os::raw::c_char,
        pub _IO_write_base: *mut ::std::os::raw::c_char,
        pub _IO_write_ptr: *mut ::std::os::raw::c_char,
        pub _IO_write_end: *mut ::std::os::raw::c_char,
        pub _IO_buf_base: *mut ::std::os::raw::c_char,
        pub _IO_buf_end: *mut ::std::os::raw::c_char,
        pub _IO_save_base: *mut ::std::os::raw::c_char,
        pub _IO_backup_base: *mut ::std::os::raw::c_char,
        pub _IO_save_end: *mut ::std::os::raw::c_char,
        pub _markers: *mut root::_IO_marker,
        pub _chain: *mut root::_IO_FILE,
        pub _fileno: ::std::os::raw::c_int,
        pub _flags2: ::std::os::raw::c_int,
        pub _old_offset: root::__off_t,
        pub _cur_column: ::std::os::raw::c_ushort,
        pub _vtable_offset: ::std::os::raw::c_schar,
        pub _shortbuf: [::std::os::raw::c_char; 1usize],
        pub _lock: *mut root::_IO_lock_t,
        pub _offset: root::__off64_t,
        pub _codecvt: *mut root::_IO_codecvt,
        pub _wide_data: *mut root::_IO_wide_data,
        pub _freeres_list: *mut root::_IO_FILE,
        pub _freeres_buf: *mut ::std::os::raw::c_void,
        pub __pad5: usize,
        pub _mode: ::std::os::raw::c_int,
        pub _unused2: [::std::os::raw::c_char; 20usize],
    }
    #[test]
    fn bindgen_test_layout__IO_FILE() {
        const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_IO_FILE>(),
            216usize,
            concat!("Size of: ", stringify!(_IO_FILE))
        );
        assert_eq!(
            ::std::mem::align_of::<_IO_FILE>(),
            8usize,
            concat!("Alignment of ", stringify!(_IO_FILE))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_const {
            pub _address: u8,
        }
        pub type remove_const_type<_Tp> = _Tp;
        pub type remove_const_t = root::std::remove_const;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type<_Tp> = _Tp;
        pub type remove_reference_t = root::std::remove_reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_signed {
            pub _address: u8,
        }
        pub type make_signed_type = u8;
        pub type make_signed_t = root::std::make_signed;
        pub type make_unsigned_t = root::std::make_unsigned;
        pub type __add_pointer_helper_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_pointer {
            pub _address: u8,
        }
        pub type add_pointer_t = root::std::add_pointer;
        pub type conditional_type<_Iftrue> = _Iftrue;
        pub type __underlying_type_impl_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct underlying_type {
            pub _address: u8,
        }
        pub type enable_if_t = u8;
        pub type conditional_t = u8;
        pub type underlying_type_t = root::std::underlying_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct random_access_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_random_access_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(random_access_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(random_access_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum float_round_style {
            round_indeterminate = -1,
            round_toward_zero = 0,
            round_to_nearest = 1,
            round_toward_infinity = 2,
            round_toward_neg_infinity = 3,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum float_denorm_style {
            denorm_indeterminate = -1,
            denorm_absent = 0,
            denorm_present = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __numeric_limits_base {
            pub _address: u8,
        }
        pub const __numeric_limits_base_is_specialized: bool = false;
        pub const __numeric_limits_base_digits: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_is_signed: bool = false;
        pub const __numeric_limits_base_is_integer: bool = false;
        pub const __numeric_limits_base_is_exact: bool = false;
        pub const __numeric_limits_base_radix: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_has_infinity: bool = false;
        pub const __numeric_limits_base_has_quiet_NaN: bool = false;
        pub const __numeric_limits_base_has_signaling_NaN: bool = false;
        extern "C" {
            #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
            pub static __numeric_limits_base_has_denorm: root::std::float_denorm_style;
        }
        pub const __numeric_limits_base_has_denorm_loss: bool = false;
        pub const __numeric_limits_base_is_iec559: bool = false;
        pub const __numeric_limits_base_is_bounded: bool = false;
        pub const __numeric_limits_base_is_modulo: bool = false;
        pub const __numeric_limits_base_traps: bool = false;
        pub const __numeric_limits_base_tinyness_before: bool = false;
        extern "C" {
            #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
            pub static __numeric_limits_base_round_style: root::std::float_round_style;
        }
        #[test]
        fn bindgen_test_layout___numeric_limits_base() {
            assert_eq!(
                ::std::mem::size_of::<__numeric_limits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__numeric_limits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__numeric_limits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__numeric_limits_base))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct numeric_limits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct atomic<_Tp> {
            pub _M_i: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        pub type atomic_value_type<_Tp> = _Tp;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssertionConditionType {
                pub _address: u8,
            }
            pub type AssertionConditionType_ValueT = root::std::remove_reference_t;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ToSignedness {
                ToIsSigned = 0,
                ToIsUnsigned = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum FromSignedness {
                FromIsSigned = 0,
                FromIsUnsigned = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum UUComparison {
                FromIsBigger = 0,
                FromIsNotBigger = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum USComparison {
                FromIsSmaller = 0,
                FromIsNotSmaller = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum StorageType {
                AsBase = 0,
                AsMember = 1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasPointerTypeHelper {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_HasPointerTypeHelper() {
                assert_eq!(
                    ::std::mem::size_of::<HasPointerTypeHelper>(),
                    1usize,
                    concat!("Size of: ", stringify!(HasPointerTypeHelper))
                );
                assert_eq!(
                    ::std::mem::align_of::<HasPointerTypeHelper>(),
                    1usize,
                    concat!("Alignment of ", stringify!(HasPointerTypeHelper))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasPointerType {
                pub _address: u8,
            }
            pub type PointerTypeImpl_Type = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PointerType {
                pub _address: u8,
            }
            pub type PointerType_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
            pub type UniqueSelector_SingleObject = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AlignasHelper<T> {
                pub mT: T,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AlignedChecker {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllowDeprecatedAbsFixed {
                pub _base: root::std::false_type,
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbsFixed_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbsFixed_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllowDeprecatedAbs {
                pub _base: root::mozilla::detail::AllowDeprecatedAbsFixed,
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbs_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbs_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AbsReturnType {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DoIsDestructibleImpl {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_DoIsDestructibleImpl() {
                assert_eq!(
                    ::std::mem::size_of::<DoIsDestructibleImpl>(),
                    1usize,
                    concat!("Size of: ", stringify!(DoIsDestructibleImpl))
                );
                assert_eq!(
                    ::std::mem::align_of::<DoIsDestructibleImpl>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DoIsDestructibleImpl))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsDestructibleImpl {
                pub _address: u8,
            }
            pub type IsDestructibleImpl_Type<T> = T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct VectorTesting {
                _unused: [u8; 0],
            }
            pub type supports_os<T> = T;
            #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LinkedListElementTraits {
                pub _address: u8,
            }
            pub type LinkedListElementTraits_RawType<T> = *mut T;
            pub type LinkedListElementTraits_ConstRawType<T> = *const T;
            pub type LinkedListElementTraits_ClientType<T> = *mut T;
            pub type LinkedListElementTraits_ConstClientType<T> = *const T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MaybePoisoner {
                pub _address: u8,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum PackingStrategy {
                Variant = 0,
                NullIsOk = 1,
                LowBitTagIsError = 2,
                PackedVariant = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EmptyWrapper<V> {
                pub _base: V,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
            }
            pub type AlignedStorageOrEmpty = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ResultImplementationNullIsOkBase {
                pub mValue: root::mozilla::CompactPair,
            }
            pub type ResultImplementationNullIsOkBase_ErrorStorageType =
                root::mozilla::detail::UnusedZero;
            pub type UnsignedIntType = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsPackableVariant {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsPackableVariant_VEbool<V, E> {
                pub v: V,
                pub e: E,
                pub ok: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsPackableVariant_EVbool<V, E> {
                pub e: E,
                pub v: V,
                pub ok: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            }
            pub type IsPackableVariant_Impl = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UnusedZero {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UnusedZeroEnum {
                pub _address: u8,
            }
            pub type UnusedZeroEnum_StorageType = root::std::underlying_type_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasFreeLSB {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_HasFreeLSB_open0_ptr_void_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SelectResultImpl {
                pub _address: u8,
            }
            pub type SelectResultImpl_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsResult {
                pub _base: root::std::false_type,
            }
            #[test]
            fn __bindgen_test_layout_UnusedZero_open0_Error_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::UnusedZero>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::UnusedZero)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::UnusedZero>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::UnusedZero)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_UnusedZero_open0_OOM_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::UnusedZero>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::UnusedZero)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::UnusedZero>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::UnusedZero)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_HasFreeLSB_open0_Error_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_HasFreeLSB_open0_OOM_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
            }
            pub type IntrinsicBase_ValueType<T> = root::std::atomic<T>;
            pub type IntrinsicBase_OrderedOp = u8;
            pub type IntrinsicMemoryOps_Base = u8;
            pub type IntrinsicAddSub_Base = u8;
            pub type IntrinsicIncDec_Base = u8;
            pub type AtomicIntrinsics_Base = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ToStorageTypeArgument {
                pub _address: u8,
            }
            pub type AtomicBase_Intrinsics = u8;
            pub type AtomicBase_ValueType = root::mozilla::detail::AtomicBase_Intrinsics;
            pub type AtomicBaseIncDec_Base = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrapToSignedHelper {
                pub _address: u8,
            }
            pub type WrapToSignedHelper_SignedType = root::std::make_signed_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrappingAddHelper {
                pub _address: u8,
            }
            pub type WrappingAddHelper_UnsignedT = root::std::make_unsigned_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrappingSubtractHelper {
                pub _address: u8,
            }
            pub type WrappingSubtractHelper_UnsignedT = root::std::make_unsigned_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrappingMultiplyHelper {
                pub _address: u8,
            }
            pub type WrappingMultiplyHelper_UnsignedT = root::std::make_unsigned_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTableEntry {
                pub _address: u8,
            }
            pub type HashTableEntry_NonConstT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EntrySlot {
                pub mEntry: *mut root::mozilla::detail::EntrySlot_Entry,
                pub mKeyHash: *mut root::mozilla::HashNumber,
            }
            pub type EntrySlot_NonConstT = root::std::remove_const_t;
            pub type EntrySlot_Entry = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable {
                pub _address: u8,
            }
            pub type HashTable_NonConstT = u8;
            pub type HashTable_Key = u8;
            pub type HashTable_Lookup = u8;
            pub type HashTable_Entry = u8;
            pub type HashTable_Slot = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Ptr {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_AddPtr {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Iterator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_ModIterator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Range {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Enum {
                pub _address: u8,
            }
            impl root::mozilla::detail::HashTable_FailureBehavior {
                pub const ReportFailure: root::mozilla::detail::HashTable_FailureBehavior =
                    HashTable_FailureBehavior::DontReportFailure;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum HashTable_FailureBehavior {
                DontReportFailure = 0,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_FakeSlot {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_DoubleHash {
                pub _address: u8,
            }
            impl root::mozilla::detail::HashTable_LookupReason {
                pub const ForAdd: root::mozilla::detail::HashTable_LookupReason =
                    HashTable_LookupReason::ForNonAdd;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum HashTable_LookupReason {
                ForNonAdd = 0,
            }
            impl root::mozilla::detail::HashTable_RebuildStatus {
                pub const Rehashed: root::mozilla::detail::HashTable_RebuildStatus =
                    HashTable_RebuildStatus::NotOverloaded;
            }
            impl root::mozilla::detail::HashTable_RebuildStatus {
                pub const RehashFailed: root::mozilla::detail::HashTable_RebuildStatus =
                    HashTable_RebuildStatus::NotOverloaded;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum HashTable_RebuildStatus {
                NotOverloaded = 0,
            }
            #[doc = " SelectVariantTypeHelper is used in the implementation of SelectVariantType."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SelectVariantTypeHelper {
                pub _address: u8,
            }
            #[doc = " SelectVariantType takes a type T and a list of variant types Variants and\n yields a type Type, selected from Variants, that can store a value of type T\n or a reference to type T. If no such type was found, Type is not defined.\n SelectVariantType also has a `count` member that contains the total number of\n selectable types (which will be used to check that a requested type is not\n ambiguously present twice.)"]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SelectVariantType {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct VariantTag {
                pub _address: u8,
            }
            pub type VariantTag_Type = root::std::conditional_t;
            #[doc = " AsVariantTemporary stores a value of type T to allow construction of a\n Variant value via type inference. Because T is copied and there's no\n guarantee that the copy can be elided, AsVariantTemporary is best used with\n primitive or very small types."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AsVariantTemporary {
                pub mValue: root::std::remove_const_t,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FloatingPointTrait {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_FloatingPointTrait_open0_float_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_FloatingPointTrait_open0_double_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FuzzyEqualsEpsilon {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_FuzzyEqualsEpsilon_open0_float_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_FuzzyEqualsEpsilon_open0_double_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Group {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CheckConvertibility {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IgnoreImpl {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_IgnoreImpl() {
                assert_eq!(
                    ::std::mem::size_of::<IgnoreImpl>(),
                    1usize,
                    concat!("Size of: ", stringify!(IgnoreImpl))
                );
                assert_eq!(
                    ::std::mem::align_of::<IgnoreImpl>(),
                    1usize,
                    concat!("Alignment of ", stringify!(IgnoreImpl))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MakeUnsignedChar {
                pub _address: u8,
            }
            pub type MakeUnsignedChar_Type = root::std::make_unsigned_t;
            #[test]
            fn __bindgen_test_layout_MakeUnsignedChar_open0_char16_t_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_MakeUnsignedChar_open0_char32_t_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
            }
        }
        #[doc = " CompactPair is the logical concatenation of an instance of A with an instance\n B. Space is conserved when possible.  Neither A nor B may be a final class.\n\n In general if space conservation is not critical is preferred to use\n std::pair.\n\n It's typically clearer to have individual A and B member fields.  Except if\n you want the space-conserving qualities of CompactPair, you're probably\n better off not using this!\n\n No guarantees are provided about the memory layout of A and B, the order of\n initialization or destruction of A and B, and so on.  (This is approximately\n required to optimize space usage.)  The first/second names are merely\n conceptual!"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CompactPair {
            pub _address: u8,
        }
        pub type CompactPair_Base = u8;
        #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UniquePtr {
            pub _address: u8,
        }
        pub type UniquePtr_ElementType = u8;
        pub type UniquePtr_DeleterType = u8;
        pub type UniquePtr_Pointer = u8;
        #[doc = " A default deletion policy using plain old operator delete.\n\n Note that this type can be specialized, but authors should beware of the risk\n that the specialization may at some point cease to match (either because it\n gets moved to a different compilation unit or the signature changes). If the\n non-specialized (|delete|-based) version compiles for that type but does the\n wrong thing, bad things could happen.\n\n This is a non-issue for types which are always incomplete (i.e. opaque handle\n types), since |delete|-ing such a type will always trigger a compilation\n error."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultDelete {
            pub _address: u8,
        }
        pub mod span_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_span_oracle {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_span {
                pub _base: root::mozilla::span_details::is_span_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_std_array_oracle {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_std_array {
                pub _base: root::mozilla::span_details::is_std_array_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_allowed_element_type_conversion {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SpanKnownBounds {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_SpanKnownBounds() {
                assert_eq!(
                    ::std::mem::size_of::<SpanKnownBounds>(),
                    1usize,
                    concat!("Size of: ", stringify!(SpanKnownBounds))
                );
                assert_eq!(
                    ::std::mem::align_of::<SpanKnownBounds>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SpanKnownBounds))
                );
            }
            pub type span_iterator_element_type_ = [u8; 0usize];
            pub type span_iterator_iterator_category = root::std::random_access_iterator_tag;
            pub type span_iterator_value_type = root::std::remove_const_t;
            pub type span_iterator_difference_type = [u8; 0usize];
            pub type span_iterator_reference = *mut root::std::conditional_t;
            pub type span_iterator_pointer = root::std::add_pointer_t;
            pub type extent_type_index_type = usize;
        }
        pub type Span_element_type<ElementType> = ElementType;
        pub type Span_index_type = usize;
        pub type Span_pointer<ElementType> = *mut root::mozilla::Span_element_type<ElementType>;
        pub type Span_reference<ElementType> = *mut root::mozilla::Span_element_type<ElementType>;
        pub type Span_iterator = u8;
        pub type Span_const_iterator = u8;
        pub type Span_reverse_iterator = root::std::reverse_iterator<root::mozilla::Span_iterator>;
        pub type Span_const_reverse_iterator =
            root::std::reverse_iterator<root::mozilla::Span_const_iterator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Span_storage_type<ElementType, ExtentType> {
            pub _base: ExtentType,
            pub data_: root::mozilla::Span_pointer<ElementType>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ElementType>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<ExtentType>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignmentFinder {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AlignmentFinder_Aligner<T> {
            pub mChar: ::std::os::raw::c_char,
            pub mT: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        pub struct AlignedStorage2 {
            pub u: root::mozilla::AlignedStorage2_U,
        }
        #[repr(C)]
        pub union AlignedStorage2_U {
            pub mBytes: *mut ::std::os::raw::c_char,
            pub mDummy: u64,
        }
        pub mod tl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static Min_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static Max_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static FloorLog2_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static CeilingLog2_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static RoundUpPow2_value: usize;
            }
            #[doc = " Compute the number of bits in the given unsigned type."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BitSize {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}checkPrecondition"]
                pub static NBitMask_checkPrecondition: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static NBitMask_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static MulOverflowMask_value: usize;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_MallocAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<MallocAllocPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(MallocAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<MallocAllocPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(MallocAllocPolicy))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NeverAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_NeverAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<NeverAllocPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(NeverAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<NeverAllocPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(NeverAllocPolicy))
            );
        }
        pub type MallocSizeOf =
            ::std::option::Option<unsafe extern "C" fn(p: *const ::std::os::raw::c_void) -> usize>;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NotNullTag {
            KnownNotNull = 0,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ReentrancyGuard {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_ReentrancyGuard() {
            assert_eq!(
                ::std::mem::size_of::<ReentrancyGuard>(),
                1usize,
                concat!("Size of: ", stringify!(ReentrancyGuard))
            );
            assert_eq!(
                ::std::mem::align_of::<ReentrancyGuard>(),
                1usize,
                concat!("Alignment of ", stringify!(ReentrancyGuard))
            );
        }
        #[doc = " Traits class for identifying POD types.  Until C++11 there's no automatic\n way to detect PODs, so for the moment this is done manually.  Users may\n define specializations of this class that inherit from std::true_type and\n std::false_type (or equivalently std::integral_constant<bool, true or\n false>, or conveniently from mozilla::IsPod for composite types) as needed to\n ensure correct IsPod behavior."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsPod {
            pub _base: root::std::false_type,
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_signed_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_short_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_short_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_long_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_long_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_bool__close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_float_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_double_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_wchar_t_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_char16_t_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[doc = " IsDestructible determines whether a type has a public destructor.\n\n struct S0 {};                    // Implicit default destructor.\n struct S1 { ~S1(); };\n class C2 { ~C2(); };             // private destructor.\n\n mozilla::IsDestructible<S0>::value is true;\n mozilla::IsDestructible<S1>::value is true;\n mozilla::IsDestructible<C2>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsDestructible {
            pub _address: u8,
        }
        pub type Vector_Impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_CapacityAndReserved {
            pub mCapacity: usize,
        }
        pub type Vector_ElementType<T> = T;
        pub const Vector_InlineLength: root::mozilla::Vector__bindgen_ty_1 =
            Vector__bindgen_ty_1::InlineLength;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Vector__bindgen_ty_1 {
            InlineLength = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_Range<T> {
            pub mCur: *mut T,
            pub mEnd: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_ConstRange<T> {
            pub mCur: *const T,
            pub mEnd: *const T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[doc = " DebugOnly contains a value of type T, but only in debug builds.  In release\n builds, it does not contain a value.  This helper is intended to be used with\n MOZ_ASSERT()-style macros, allowing one to write:\n\n   DebugOnly<bool> check = func();\n   MOZ_ASSERT(check);\n\n more concisely than declaring |check| conditional on #ifdef DEBUG.\n\n DebugOnly instances can only be coerced to T in debug builds.  In release\n builds they don't have a value, so type coercion is not well defined.\n\n NOTE: DebugOnly instances still take up one byte of space, plus padding, even\n in optimized, non-DEBUG builds (see bug 1253094 comment 37 for more info).\n For this reason the class is MOZ_STACK_CLASS to prevent consumers using\n DebugOnly for struct/class members and unwittingly inflating the size of\n their objects in release builds."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct DebugOnly {
            pub _address: u8,
        }
        pub type Array_ElementType<T> = T;
        pub type Array_iterator<T> = *mut T;
        pub type Array_const_iterator<T> = *const T;
        pub type Array_reverse_iterator<T> = root::std::reverse_iterator<T>;
        pub type Array_const_reverse_iterator<T> = root::std::reverse_iterator<T>;
        pub type EnumeratedArray_ArrayType = u8;
        pub type EnumeratedArray_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unused_t {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OwningNonNull {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticLocalRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RefPtrTraits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedListElement {
            pub mNext: *mut root::mozilla::LinkedListElement,
            pub mPrev: *mut root::mozilla::LinkedListElement,
            pub mIsSentinel: bool,
        }
        #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
        pub type LinkedListElement_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedListElement_RawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstRawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ClientType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstClientType = root::mozilla::LinkedListElement_Traits;
        impl root::mozilla::LinkedListElement_NodeKind {
            pub const Sentinel: root::mozilla::LinkedListElement_NodeKind =
                LinkedListElement_NodeKind::Normal;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LinkedListElement_NodeKind {
            Normal = 0,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedList {
            pub sentinel: root::mozilla::LinkedListElement,
        }
        #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
        pub type LinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedList_RawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstRawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ElementType = *mut root::mozilla::LinkedListElement;
        pub type LinkedList_ConstElementType = *const root::mozilla::LinkedListElement;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LinkedList_Iterator<Type> {
            pub mCurrent: Type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Type>>,
        }
        pub type LinkedList_Iterator_iterator_category = root::std::forward_iterator_tag;
        pub type LinkedList_Iterator_value_type<T> = T;
        pub type LinkedList_Iterator_difference_type = isize;
        pub type LinkedList_Iterator_pointer<T> = *mut T;
        pub type LinkedList_Iterator_reference<T> = *mut T;
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoCleanLinkedList {
            pub _base: root::mozilla::LinkedList,
        }
        #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
        pub type AutoCleanLinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type AutoCleanLinkedList_ClientType = root::mozilla::detail::LinkedListElementTraits;
        #[doc = " A version of CorruptionCanary that is suitable as a member of objects that\n are statically allocated."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CorruptionCanaryForStatics {
            pub mValue: usize,
        }
        pub const CorruptionCanaryForStatics_kCanarySet: usize = 252382987;
        #[test]
        fn bindgen_test_layout_CorruptionCanaryForStatics() {
            const UNINIT: ::std::mem::MaybeUninit<CorruptionCanaryForStatics> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CorruptionCanaryForStatics>(),
                8usize,
                concat!("Size of: ", stringify!(CorruptionCanaryForStatics))
            );
            assert_eq!(
                ::std::mem::align_of::<CorruptionCanaryForStatics>(),
                8usize,
                concat!("Alignment of ", stringify!(CorruptionCanaryForStatics))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mValue) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CorruptionCanaryForStatics),
                    "::",
                    stringify!(mValue)
                )
            );
        }
        #[doc = " This class is designed to cause crashes when various kinds of memory\n corruption are observed. For instance, let's say we have a class C where we\n suspect out-of-bounds writes to some members.  We can insert a member of type\n Poison near the members we suspect are being corrupted by out-of-bounds\n writes.  Or perhaps we have a class K we suspect is subject to use-after-free\n violations, in which case it doesn't particularly matter where in the class\n we add the member of type Poison.\n\n In either case, we then insert calls to Check() throughout the code.  Doing\n so enables us to narrow down the location where the corruption is occurring.\n A pleasant side-effect of these additional Check() calls is that crash\n signatures may become more regular, as crashes will ideally occur\n consolidated at the point of a Check(), rather than scattered about at\n various uses of the corrupted memory."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CorruptionCanary {
            pub _base: root::mozilla::CorruptionCanaryForStatics,
        }
        #[test]
        fn bindgen_test_layout_CorruptionCanary() {
            assert_eq!(
                ::std::mem::size_of::<CorruptionCanary>(),
                8usize,
                concat!("Size of: ", stringify!(CorruptionCanary))
            );
            assert_eq!(
                ::std::mem::align_of::<CorruptionCanary>(),
                8usize,
                concat!("Alignment of ", stringify!(CorruptionCanary))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Nothing {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Nothing() {
            assert_eq!(
                ::std::mem::size_of::<Nothing>(),
                1usize,
                concat!("Size of: ", stringify!(Nothing))
            );
            assert_eq!(
                ::std::mem::align_of::<Nothing>(),
                1usize,
                concat!("Alignment of ", stringify!(Nothing))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Maybe {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Maybe_SomeGuard {
            pub _address: u8,
        }
        pub type Maybe_ValueType = u8;
        #[doc = " Empty struct, indicating success for operations that have no return value.\n For example, if you declare another empty struct `struct OutOfMemory {};`,\n then `Result<Ok, OutOfMemory>` represents either success or OOM."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Ok {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Ok() {
            assert_eq!(
                ::std::mem::size_of::<Ok>(),
                1usize,
                concat!("Size of: ", stringify!(Ok))
            );
            assert_eq!(
                ::std::mem::align_of::<Ok>(),
                1usize,
                concat!("Alignment of ", stringify!(Ok))
            );
        }
        #[doc = " A tag used to differentiate between GenericErrorResult created by the Err\n function (completely new error) and GenericErrorResult created by the\n Result::propagateErr function (propagated error). This can be used to track\n error propagation and eventually produce error stacks for logging/debugging\n purposes."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ErrorPropagationTag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_ErrorPropagationTag() {
            assert_eq!(
                ::std::mem::size_of::<ErrorPropagationTag>(),
                1usize,
                concat!("Size of: ", stringify!(ErrorPropagationTag))
            );
            assert_eq!(
                ::std::mem::align_of::<ErrorPropagationTag>(),
                1usize,
                concat!("Alignment of ", stringify!(ErrorPropagationTag))
            );
        }
        #[doc = " Result<V, E> represents the outcome of an operation that can either succeed\n or fail. It contains either a success value of type V or an error value of\n type E.\n\n All Result methods are const, so results are basically immutable.\n This is just like Variant<V, E> but with a slightly different API, and the\n following cases are optimized so Result can be stored more efficiently:\n\n - If both the success and error types do not use their least significant bit,\n are trivially copyable and destructible, Result<V, E> is guaranteed to be as\n large as the larger type. This is determined via the HasFreeLSB trait. By\n default, empty classes (in particular Ok) and aligned pointer types are\n assumed to have a free LSB, but you can specialize this trait for other\n types. If the success type is empty, the representation is guaranteed to be\n all zero bits on success. Do not change this representation! There is JIT\n code that depends on it. (Implementation note: The lowest bit is used as a\n tag bit: 0 to indicate the Result's bits are a success value, 1 to indicate\n the Result's bits (with the 1 masked out) encode an error value)\n\n - Else, if the error type can't have a all-zero bits representation and is\n not larger than a pointer, a CompactPair is used to represent this rather\n than a Variant. This has shown to be better optimizable, and the template\n code is much simpler than that of Variant, so it should also compile faster.\n Whether an error type can't be all-zero bits, is determined via the\n UnusedZero trait. MFBT doesn't declare any public type UnusedZero, but\n nsresult is declared UnusedZero in XPCOM.\n\n The purpose of Result is to reduce the screwups caused by using `false` or\n `nullptr` to indicate errors.\n What screwups? See <https://bugzilla.mozilla.org/show_bug.cgi?id=912928> for\n a partial list.\n\n Result<const V, E> or Result<V, const E> are not meaningful. The success or\n error values in a Result instance are non-modifiable in-place anyway. This\n guarantee must also be maintained when evolving Result. They can be\n unwrap()ped, but this loses const qualification. However, Result<const V, E>\n or Result<V, const E> may be misleading and prevent movability. Just use\n Result<V, E>. (Result<const V*, E> may make sense though, just Result<const\n V* const, E> is not possible.)"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Result {
            pub mImpl: root::mozilla::Result_Impl,
        }
        pub type Result_Impl = root::mozilla::detail::SelectResultImpl;
        pub type Result_ok_type<V> = V;
        pub type Result_err_type<E> = E;
        #[doc = " A type that auto-converts to an error Result. This is like a Result without\n a success type. It's the best return type for functions that always return\n an error--functions designed to build and populate error objects. It's also\n useful in error-handling macros; see MOZ_TRY for an example."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GenericErrorResult<E> {
            pub mErrorValue: E,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
        }
        #[repr(u32)]
        #[doc = " An enum of memory ordering possibilities for atomics.\n\n Memory ordering is the observable state of distinct values in memory.\n (It's a separate concept from atomicity, which concerns whether an\n operation can ever be observed in an intermediate state.  Don't\n conflate the two!)  Given a sequence of operations in source code on\n memory, it is *not* always the case that, at all times and on all\n cores, those operations will appear to have occurred in that exact\n sequence.  First, the compiler might reorder that sequence, if it\n thinks another ordering will be more efficient.  Second, the CPU may\n not expose so consistent a view of memory.  CPUs will often perform\n their own instruction reordering, above and beyond that performed by\n the compiler.  And each core has its own memory caches, and accesses\n (reads and writes both) to \"memory\" may only resolve to out-of-date\n cache entries -- not to the \"most recently\" performed operation in\n some global sense.  Any access to a value that may be used by\n multiple threads, potentially across multiple cores, must therefore\n have a memory ordering imposed on it, for all code on all\n threads/cores to have a sufficiently coherent worldview.\n\n http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync and\n http://en.cppreference.com/w/cpp/atomic/memory_order go into more\n detail on all this, including examples of how each mode works.\n\n Note that for simplicity and practicality, not all of the modes in\n C++11 are supported.  The missing C++11 modes are either subsumed by\n the modes we provide below, or not relevant for the CPUs we support\n in Gecko.  These three modes are confusing enough as it is!"]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryOrdering {
            Relaxed = 0,
            ReleaseAcquire = 1,
            SequentiallyConsistent = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotNull {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BitSet_Reference {
            pub mBitSet: *mut u8,
            pub mPos: usize,
        }
        pub type HashNumber = u32;
        #[doc = " A pseudorandom function mapping 32-bit integers to 32-bit integers.\n\n This is for when you're feeding private data (like pointer values or credit\n card numbers) to a non-crypto hash function (like HashBytes) and then using\n the hash code for something that untrusted parties could observe (like a JS\n Map). Plug in a HashCodeScrambler before that last step to avoid leaking the\n private data.\n\n By itself, this does not prevent hash-flooding DoS attacks, because an\n attacker can still generate many values with exactly equal hash codes by\n attacking the non-crypto hash function alone. Equal hash codes will, of\n course, still be equal however much you scramble them.\n\n The algorithm is SipHash-1-3. See <https://131002.net/siphash/>."]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct HashCodeScrambler {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct HashCodeScrambler_SipHasher {
            pub _bindgen_opaque_blob: [u64; 4usize],
        }
        #[test]
        fn bindgen_test_layout_HashCodeScrambler_SipHasher() {
            assert_eq!(
                ::std::mem::size_of::<HashCodeScrambler_SipHasher>(),
                32usize,
                concat!("Size of: ", stringify!(HashCodeScrambler_SipHasher))
            );
            assert_eq!(
                ::std::mem::align_of::<HashCodeScrambler_SipHasher>(),
                8usize,
                concat!("Alignment of ", stringify!(HashCodeScrambler_SipHasher))
            );
        }
        #[test]
        fn bindgen_test_layout_HashCodeScrambler() {
            assert_eq!(
                ::std::mem::size_of::<HashCodeScrambler>(),
                16usize,
                concat!("Size of: ", stringify!(HashCodeScrambler))
            );
            assert_eq!(
                ::std::mem::align_of::<HashCodeScrambler>(),
                8usize,
                concat!("Alignment of ", stringify!(HashCodeScrambler))
            );
        }
        #[doc = " Opaque<T> is a replacement for integral T in cases where only comparisons\n must be supported, and it's desirable to prevent accidental dependency on\n exact values."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Opaque<T> {
            pub mValue: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[doc = " Opaque<T> is a replacement for integral T in cases where only comparisons\n must be supported, and it's desirable to prevent accidental dependency on\n exact values."]
        pub type Generation = root::mozilla::Opaque<u64>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashMap {
            pub _address: u8,
        }
        pub type HashMap_TableEntry = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashMap_MapHashPolicy {
            pub _address: u8,
        }
        pub type HashMap_MapHashPolicy_Base = u8;
        pub type HashMap_MapHashPolicy_KeyType = u8;
        pub type HashMap_Impl = u8;
        pub type HashMap_Lookup = u8;
        pub type HashMap_Entry = u8;
        pub type HashMap_Ptr = u8;
        pub type HashMap_AddPtr = u8;
        pub type HashMap_Iterator = u8;
        pub type HashMap_ModIterator = u8;
        pub type HashMap_Range = u8;
        pub type HashMap_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashSet {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashSet_SetHashPolicy {
            pub _address: u8,
        }
        pub type HashSet_SetHashPolicy_Base = u8;
        pub type HashSet_SetHashPolicy_KeyType = u8;
        pub type HashSet_Impl = u8;
        pub type HashSet_Lookup = u8;
        pub type HashSet_Entry = u8;
        pub type HashSet_Ptr = u8;
        pub type HashSet_AddPtr = u8;
        pub type HashSet_Iterator = u8;
        pub type HashSet_ModIterator = u8;
        pub type HashSet_Range = u8;
        pub type HashSet_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PointerHasher {
            pub _address: u8,
        }
        pub type PointerHasher_Lookup<Key> = Key;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultHasher {
            pub _address: u8,
        }
        pub type DefaultHasher_Lookup<Key> = Key;
        #[test]
        fn __bindgen_test_layout_DefaultHasher_open0_double_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_DefaultHasher_open0_float_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CStringHasher {
            pub _address: u8,
        }
        pub type CStringHasher_Key = *const ::std::os::raw::c_char;
        pub type CStringHasher_Lookup = *const ::std::os::raw::c_char;
        #[test]
        fn bindgen_test_layout_CStringHasher() {
            assert_eq!(
                ::std::mem::size_of::<CStringHasher>(),
                1usize,
                concat!("Size of: ", stringify!(CStringHasher))
            );
            assert_eq!(
                ::std::mem::align_of::<CStringHasher>(),
                1usize,
                concat!("Alignment of ", stringify!(CStringHasher))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FallibleHashMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashMapEntry {
            pub _address: u8,
        }
        pub type HashMapEntry_KeyType = u8;
        pub type HashMapEntry_ValueType = u8;
        pub mod ipc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IPDLParamTraits {
                pub _address: u8,
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct VariantType {
            pub _address: u8,
        }
        pub type VariantType_Type<T> = T;
        extern "C" {
            #[link_name = "\u{1}index"]
            pub static VariantIndex_index: usize;
        }
        #[doc = " # mozilla::Variant\n\n A variant / tagged union / heterogenous disjoint union / sum-type template\n class. Similar in concept to (but not derived from) `boost::variant`.\n\n Sometimes, you may wish to use a C union with non-POD types. However, this is\n forbidden in C++ because it is not clear which type in the union should have\n its constructor and destructor run on creation and deletion\n respectively. This is the problem that `mozilla::Variant` solves.\n\n ## Usage\n\n A `mozilla::Variant` instance is constructed (via move or copy) from one of\n its variant types (ignoring const and references). It does *not* support\n construction from subclasses of variant types or types that coerce to one of\n the variant types.\n\n     Variant<char, uint32_t> v1('a');\n     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());\n     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed\n     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int\n\n Because specifying the full type of a Variant value is often verbose,\n there are two easier ways to construct values:\n\n A. AsVariant() can be used to construct a Variant value using type inference\n in contexts such as expressions or when returning values from functions.\n Because AsVariant() must copy or move the value into a temporary and this\n cannot necessarily be elided by the compiler, it's mostly appropriate only\n for use with primitive or very small types.\n\n     Variant<char, uint32_t> Foo() { return AsVariant('x'); }\n     // ...\n     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x').\n\n B. Brace-construction with VariantType or VariantIndex; this also allows\n in-place construction with any number of arguments.\n\n     struct AB { AB(int, int){...} };\n     static Variant<AB, bool> foo()\n     {\n       return {VariantIndex<0>{}, 1, 2};\n     }\n     // ...\n     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2).\n\n All access to the contained value goes through type-safe accessors.\n Either the stored type, or the type index may be provided.\n\n     void\n     Foo(Variant<A, B, C> v)\n     {\n       if (v.is<A>()) {\n         A& ref = v.as<A>();\n         ...\n       } else (v.is<1>()) { // Instead of v.is<B>.\n         ...\n       } else {\n         ...\n       }\n     }\n\n In some situation, a Variant may be constructed from templated types, in\n which case it is possible that the same type could be given multiple times by\n an external developer. Or seemingly-different types could be aliases.\n In this case, repeated types can only be accessed through their index, to\n prevent ambiguous access by type.\n\n    // Bad!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(int(0)) {} // Error '0' by default\n      ResultOrError(const T& r) : m(r) {}\n      bool IsResult() const { return m.is<T>(); }\n      bool IsError() const { return m.is<int>(); }\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // Fail!\n    // In Variant<int, int>, which 'int' are we refering to, from inside\n    // ResultOrError functions?\n\n    // Good!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default\n      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}\n      bool IsResult() const { return m.is<0>(); } // 0 -> T\n      bool IsError() const { return m.is<1>(); } // 1 -> int\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // It now works!\n\n Attempting to use the contained value as type `T1` when the `Variant`\n instance contains a value of type `T2` causes an assertion failure.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<B>(); // <--- Assertion failure!\n\n Trying to use a `Variant<Ts...>` instance as some type `U` that is not a\n member of the set of `Ts...` is a compiler error.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<SomeRandomType>(); // <--- Compiler error!\n\n Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it\n out of the containing `Variant` instance with the `extract<T>` method:\n\n     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());\n     auto ptr = v.extract<UniquePtr<A>>();\n\n Finally, you can exhaustively match on the contained variant and branch into\n different code paths depending on which type is contained. This is preferred\n to manually checking every variant type T with is<T>() because it provides\n compile-time checking that you handled every type, rather than runtime\n assertion failures.\n\n     // Bad!\n     char* foo(Variant<A, B, C, D>& v) {\n       if (v.is<A>()) {\n         return ...;\n       } else if (v.is<B>()) {\n         return ...;\n       } else {\n         return doSomething(v.as<C>()); // Forgot about case D!\n       }\n     }\n\n     // Instead, a single function object (that can deal with all possible\n     // options) may be provided:\n     struct FooMatcher\n     {\n       // The return type of all matchers must be identical.\n       char* operator()(A& a) { ... }\n       char* operator()(B& b) { ... }\n       char* operator()(C& c) { ... }\n       char* operator()(D& d) { ... } // Compile-time error to forget D!\n     }\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match(FooMatcher());\n     }\n\n     // In some situations, a single generic lambda may also be appropriate:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto&) {...});\n     }\n\n     // Alternatively, multiple function objects may be provided, each one\n     // corresponding to an option, in the same order:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](A&) { ... },\n                      [](B&) { ... },\n                      [](C&) { ... },\n                      [](D&) { ... });\n     }\n\n     // In rare cases, the index of the currently-active alternative is\n     // needed, it may be obtained by adding a first parameter in the matcner\n     // callback, which will receive the index in its most compact type (just\n     // use `size_t` if the exact type is not important), e.g.:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto aIndex, auto& aAlternative) {...});\n       // --OR--\n       return v.match([](size_t aIndex, auto& aAlternative) {...});\n     }\n\n ## Examples\n\n A tree is either an empty leaf, or a node with a value and two children:\n\n     struct Leaf { };\n\n     template<typename T>\n     struct Node\n     {\n       T value;\n       Tree<T>* left;\n       Tree<T>* right;\n     };\n\n     template<typename T>\n     using Tree = Variant<Leaf, Node<T>>;\n\n A copy-on-write string is either a non-owning reference to some existing\n string, or an owning reference to our copy:\n\n     class CopyOnWriteString\n     {\n       Variant<const char*, UniquePtr<char[]>> string;\n\n       ...\n     };\n\n Because Variant must be aligned suitable to hold any value stored within it,\n and because |alignas| requirements don't affect platform ABI with respect to\n how parameters are laid out in memory, Variant can't be used as the type of a\n function parameter.  Pass Variant to functions by pointer or reference\n instead."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Variant {
            pub _address: u8,
        }
        pub type Variant_Tag = root::mozilla::detail::VariantTag;
        pub type Variant_Impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FloatingPoint {
            pub _address: u8,
        }
        pub type FloatingPoint_Base = root::mozilla::detail::FloatingPointTrait;
        #[doc = " An unsigned integral type suitable for accessing the bitwise representation\n of T."]
        pub type FloatingPoint_Bits = root::mozilla::FloatingPoint_Base;
        pub type InfinityBits_Traits = root::mozilla::FloatingPoint;
        pub type SpecificNaNBits_Traits = root::mozilla::FloatingPoint;
        #[doc = " EnumSet<T, U> is a set of values defined by an enumeration. It is implemented\n using a bit mask with the size of U for each value. It works both for enum\n and enum class types. EnumSet also works with U being a BitSet."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EnumSet<Serialized> {
            pub mBitField: Serialized,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Serialized>>,
        }
        pub type EnumSet_valueType<T> = T;
        pub type EnumSet_serializedType<Serialized> = Serialized;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EnumSet_ConstIterator<Serialized> {
            pub mSet: *const root::mozilla::EnumSet<Serialized>,
            pub mPos: u32,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Serialized>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RangedPtr<T> {
            pub mPtr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Range<T> {
            pub mStart: root::mozilla::RangedPtr<T>,
            pub mEnd: root::mozilla::RangedPtr<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[doc = " Tuple is a class that stores zero or more objects, whose types are specified\n as template parameters. It can be thought of as a generalization of\n std::pair, (which can be thought of as a 2-tuple).\n\n Tuple allows index-based access to its elements (with the index having to be\n known at compile time) via the non-member function 'Get<N>(tuple)'."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Tuple {
            pub _address: u8,
        }
        pub type Tuple_Impl = u8;
        #[test]
        fn __bindgen_test_layout_Tuple_open0_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::Tuple>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::Tuple)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::Tuple>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::Tuple)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferList {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferList_Segment {
            pub mData: *mut ::std::os::raw::c_char,
            pub mSize: usize,
            pub mCapacity: usize,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferList_IterImpl {
            pub mSegment: usize,
            pub mData: *mut ::std::os::raw::c_char,
            pub mDataEnd: *mut ::std::os::raw::c_char,
            pub mAbsoluteOffset: usize,
        }
        #[doc = " A code unit within a UTF-8 encoded string.  (A code unit is the smallest\n unit within the Unicode encoding of a string.  For UTF-8 this is an 8-bit\n number; for UTF-16 it would be a 16-bit number.)\n\n This is *not* the same as a single code point: in UTF-8, non-ASCII code\n points are constituted by multiple code units."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union Utf8Unit {
            pub mValue: ::std::os::raw::c_char,
        }
        #[test]
        fn bindgen_test_layout_Utf8Unit() {
            const UNINIT: ::std::mem::MaybeUninit<Utf8Unit> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Utf8Unit>(),
                1usize,
                concat!("Size of: ", stringify!(Utf8Unit))
            );
            assert_eq!(
                ::std::mem::align_of::<Utf8Unit>(),
                1usize,
                concat!("Alignment of ", stringify!(Utf8Unit))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mValue) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Utf8Unit),
                    "::",
                    stringify!(mValue)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_RefPtrTraits_open0_CompilationStencil_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::RefPtrTraits>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::RefPtrTraits)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::RefPtrTraits>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::RefPtrTraits)
                )
            );
        }
        pub type TimeStampValue = u64;
        #[doc = " Platform-specific implementation details of BaseTimeDuration."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDurationPlatformUtils {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_BaseTimeDurationPlatformUtils() {
            assert_eq!(
                ::std::mem::size_of::<BaseTimeDurationPlatformUtils>(),
                1usize,
                concat!("Size of: ", stringify!(BaseTimeDurationPlatformUtils))
            );
            assert_eq!(
                ::std::mem::align_of::<BaseTimeDurationPlatformUtils>(),
                1usize,
                concat!("Alignment of ", stringify!(BaseTimeDurationPlatformUtils))
            );
        }
        #[doc = " Instances of this class represent the length of an interval of time.\n Negative durations are allowed, meaning the end is before the start.\n\n Internally the duration is stored as a int64_t in units of\n PR_TicksPerSecond() when building with NSPR interval timers, or a\n system-dependent unit when building with system clocks.  The\n system-dependent unit must be constant, otherwise the semantics of\n this class would be broken.\n\n The ValueCalculator template parameter determines how arithmetic\n operations are performed on the integer count of ticks (mValue)."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration {
            pub mValue: i64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration__SomethingVeryRandomHere {
            _unused: [u8; 0],
        }
        #[doc = " Perform arithmetic operations on the value of a BaseTimeDuration without\n doing strict checks on the range of values."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeDurationValueCalculator {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_TimeDurationValueCalculator() {
            assert_eq!(
                ::std::mem::size_of::<TimeDurationValueCalculator>(),
                1usize,
                concat!("Size of: ", stringify!(TimeDurationValueCalculator))
            );
            assert_eq!(
                ::std::mem::align_of::<TimeDurationValueCalculator>(),
                1usize,
                concat!("Alignment of ", stringify!(TimeDurationValueCalculator))
            );
        }
        #[doc = " Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for\n arithmetic on the mValue member.\n\n Use this class for time durations that are *not* expected to hold values of\n Forever (or the negative equivalent) or when such time duration are *not*\n expected to be used in arithmetic operations."]
        pub type TimeDuration = root::mozilla::BaseTimeDuration;
        #[doc = " Instances of this class represent moments in time, or a special\n \"null\" moment. We do not use the non-monotonic system clock or\n local time, since they can be reset, causing apparent backward\n travel in time, which can confuse algorithms. Instead we measure\n elapsed time according to the system.  This time can never go\n backwards (i.e. it never wraps around, at least not in less than\n five million years of system elapsed time). It might not advance\n while the system is sleeping. If TimeStamp::SetNow() is not called\n at all for hours or days, we might not notice the passage of some\n of that time.\n\n We deliberately do not expose a way to convert TimeStamps to some\n particular unit. All you can do is compute a difference between two\n TimeStamps to get a TimeDuration. You can also add a TimeDuration\n to a TimeStamp to get a new TimeStamp. You can't do something\n meaningless like add two TimeStamps.\n\n Internally this is implemented as either a wrapper around\n   - high-resolution, monotonic, system clocks if they exist on this\n     platform\n   - PRIntervalTime otherwise.  We detect wraparounds of\n     PRIntervalTime and work around them.\n\n This class is similar to C++11's time_point, however it is\n explicitly nullable and provides an IsNull() method. time_point\n is initialized to the clock's epoch and provides a\n time_since_epoch() method that functions similiarly. i.e.\n t.IsNull() is equivalent to t.time_since_epoch() ==\n decltype(t)::duration::zero();\n\n Note that, since TimeStamp objects are small, prefer to pass them by value\n unless there is a specific reason not to do so."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeStamp {
            #[doc = " When built with PRIntervalTime, a value of 0 means this instance\n is \"null\". Otherwise, the low 32 bits represent a PRIntervalTime,\n and the high 32 bits represent a counter of the number of\n rollovers of PRIntervalTime that we've seen. This counter starts\n at 1 to avoid a real time colliding with the \"null\" value.\n\n PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum\n time to wrap around is about 2^64/100000 seconds, i.e. about\n 5,849,424 years.\n\n When using a system clock, a value is system dependent."]
            pub mValue: root::mozilla::TimeStampValue,
        }
        #[test]
        fn bindgen_test_layout_TimeStamp() {
            const UNINIT: ::std::mem::MaybeUninit<TimeStamp> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TimeStamp>(),
                8usize,
                concat!("Size of: ", stringify!(TimeStamp))
            );
            assert_eq!(
                ::std::mem::align_of::<TimeStamp>(),
                8usize,
                concat!("Alignment of ", stringify!(TimeStamp))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mValue) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimeStamp),
                    "::",
                    stringify!(mValue)
                )
            );
        }
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TypeIsGCThing {
                pub _base: root::std::false_type,
            }
            #[test]
            fn __bindgen_test_layout_TypeIsGCThing_open0_Value_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::js::detail::TypeIsGCThing>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::js::detail::TypeIsGCThing)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::js::detail::TypeIsGCThing>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::js::detail::TypeIsGCThing)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
            pub type UniqueSelector_SingleObject = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PtrBarrierMethodsBase {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProxyReservedSlots {
                pub slots: [root::JS::Value; 1usize],
            }
            #[test]
            fn bindgen_test_layout_ProxyReservedSlots() {
                const UNINIT: ::std::mem::MaybeUninit<ProxyReservedSlots> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ProxyReservedSlots>(),
                    8usize,
                    concat!("Size of: ", stringify!(ProxyReservedSlots))
                );
                assert_eq!(
                    ::std::mem::align_of::<ProxyReservedSlots>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ProxyReservedSlots))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ProxyReservedSlots),
                        "::",
                        stringify!(slots)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProxyValueArray {
                pub expandoSlot: root::JS::Value,
                pub privateSlot: root::JS::Value,
                pub reservedSlots: root::js::detail::ProxyReservedSlots,
            }
            #[test]
            fn bindgen_test_layout_ProxyValueArray() {
                const UNINIT: ::std::mem::MaybeUninit<ProxyValueArray> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ProxyValueArray>(),
                    24usize,
                    concat!("Size of: ", stringify!(ProxyValueArray))
                );
                assert_eq!(
                    ::std::mem::align_of::<ProxyValueArray>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ProxyValueArray))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).expandoSlot) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ProxyValueArray),
                        "::",
                        stringify!(expandoSlot)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).privateSlot) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ProxyValueArray),
                        "::",
                        stringify!(privateSlot)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).reservedSlots) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ProxyValueArray),
                        "::",
                        stringify!(reservedSlots)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProxyDataLayout {
                pub reservedSlots: *mut root::js::detail::ProxyReservedSlots,
                pub handler: *const root::js::BaseProxyHandler,
            }
            #[test]
            fn bindgen_test_layout_ProxyDataLayout() {
                const UNINIT: ::std::mem::MaybeUninit<ProxyDataLayout> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ProxyDataLayout>(),
                    16usize,
                    concat!("Size of: ", stringify!(ProxyDataLayout))
                );
                assert_eq!(
                    ::std::mem::align_of::<ProxyDataLayout>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ProxyDataLayout))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).reservedSlots) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ProxyDataLayout),
                        "::",
                        stringify!(reservedSlots)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ProxyDataLayout),
                        "::",
                        stringify!(handler)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail15SetValueInProxyEPN2JS5ValueERKS2_"]
                pub fn SetValueInProxy(slot: *mut root::JS::Value, value: *const root::JS::Value);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail12IsWindowSlowEP8JSObject"]
                pub fn IsWindowSlow(obj: *mut root::JSObject) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail25ToWindowProxyIfWindowSlowEP8JSObject"]
                pub fn ToWindowProxyIfWindowSlow(obj: *mut root::JSObject) -> *mut root::JSObject;
            }
        }
        pub type Vector = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseScript {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseShape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GetterSetter {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropMap {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpShared {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Shape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Scope {
            _unused: [u8; 0],
        }
        pub mod jit {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct JitCode {
                _unused: [u8; 0],
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum InlinableNative {
                __bindgen_cannot_repr_c_on_empty_enum = 0,
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js29CurrentThreadCanAccessRuntimeEPK9JSRuntime"]
            pub fn CurrentThreadCanAccessRuntime(rt: *const root::JSRuntime) -> bool;
        }
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Cell {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Arena {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TenuredChunk {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct StoreBuffer {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TenuredCell {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ChunkBase {
                pub storeBuffer: *mut root::js::gc::StoreBuffer,
                pub runtime: *mut root::JSRuntime,
            }
            #[test]
            fn bindgen_test_layout_ChunkBase() {
                const UNINIT: ::std::mem::MaybeUninit<ChunkBase> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ChunkBase>(),
                    16usize,
                    concat!("Size of: ", stringify!(ChunkBase))
                );
                assert_eq!(
                    ::std::mem::align_of::<ChunkBase>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ChunkBase))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).storeBuffer) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ChunkBase),
                        "::",
                        stringify!(storeBuffer)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).runtime) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ChunkBase),
                        "::",
                        stringify!(runtime)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TenuredChunkInfo {
                pub next: *mut root::js::gc::TenuredChunk,
                pub prev: *mut root::js::gc::TenuredChunk,
                pub numArenasFree: u32,
                pub numArenasFreeCommitted: u32,
            }
            #[test]
            fn bindgen_test_layout_TenuredChunkInfo() {
                const UNINIT: ::std::mem::MaybeUninit<TenuredChunkInfo> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<TenuredChunkInfo>(),
                    24usize,
                    concat!("Size of: ", stringify!(TenuredChunkInfo))
                );
                assert_eq!(
                    ::std::mem::align_of::<TenuredChunkInfo>(),
                    8usize,
                    concat!("Alignment of ", stringify!(TenuredChunkInfo))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkInfo),
                        "::",
                        stringify!(next)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkInfo),
                        "::",
                        stringify!(prev)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).numArenasFree) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkInfo),
                        "::",
                        stringify!(numArenasFree)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).numArenasFreeCommitted) as usize - ptr as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkInfo),
                        "::",
                        stringify!(numArenasFreeCommitted)
                    )
                );
            }
            #[doc = " Atomic<T> implementation for integral types.\n\n In addition to atomic store and load operations, compound assignment and\n increment/decrement operators are implemented which perform the\n corresponding read-modify-write operation atomically.  Finally, an atomic\n swap method is provided."]
            pub type MarkBitmapWord = u64;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ColorBit {
                BlackBit = 0,
                GrayOrBlackBit = 1,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum MarkColor {
                Gray = 1,
                Black = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MarkBitmap {
                pub bitmap: [root::js::gc::MarkBitmapWord; 2016usize],
            }
            pub const MarkBitmap_WordCount: usize = 2016;
            #[test]
            fn bindgen_test_layout_MarkBitmap() {
                const UNINIT: ::std::mem::MaybeUninit<MarkBitmap> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<MarkBitmap>(),
                    16128usize,
                    concat!("Size of: ", stringify!(MarkBitmap))
                );
                assert_eq!(
                    ::std::mem::align_of::<MarkBitmap>(),
                    8usize,
                    concat!("Alignment of ", stringify!(MarkBitmap))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).bitmap) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MarkBitmap),
                        "::",
                        stringify!(bitmap)
                    )
                );
            }
            #[doc = " An object like std::bitset but which provides access to the underlying\n storage.\n\n The limited API is due to expedience only; feel free to flesh out any\n std::bitset-like members."]
            pub type ChunkPageBitmap = [u32; 8usize];
            #[doc = " An object like std::bitset but which provides access to the underlying\n storage.\n\n The limited API is due to expedience only; feel free to flesh out any\n std::bitset-like members."]
            pub type ChunkArenaBitmap = [u32; 8usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TenuredChunkBase {
                pub _base: root::js::gc::ChunkBase,
                pub info: root::js::gc::TenuredChunkInfo,
                pub markBits: root::js::gc::MarkBitmap,
                pub freeCommittedArenas: root::js::gc::ChunkArenaBitmap,
                pub decommittedPages: root::js::gc::ChunkPageBitmap,
            }
            #[test]
            fn bindgen_test_layout_TenuredChunkBase() {
                const UNINIT: ::std::mem::MaybeUninit<TenuredChunkBase> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<TenuredChunkBase>(),
                    16232usize,
                    concat!("Size of: ", stringify!(TenuredChunkBase))
                );
                assert_eq!(
                    ::std::mem::align_of::<TenuredChunkBase>(),
                    8usize,
                    concat!("Alignment of ", stringify!(TenuredChunkBase))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkBase),
                        "::",
                        stringify!(info)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).markBits) as usize - ptr as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkBase),
                        "::",
                        stringify!(markBits)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).freeCommittedArenas) as usize - ptr as usize
                    },
                    16168usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkBase),
                        "::",
                        stringify!(freeCommittedArenas)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).decommittedPages) as usize - ptr as usize
                    },
                    16200usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TenuredChunkBase),
                        "::",
                        stringify!(decommittedPages)
                    )
                );
            }
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}_ZN2js2gc6detail16CanCheckGrayBitsEPKNS0_11TenuredCellE"]
                    pub fn CanCheckGrayBits(cell: *const root::js::gc::TenuredCell) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2js2gc6detail23CellIsMarkedGrayIfKnownEPKNS0_11TenuredCellE"]
                    pub fn CellIsMarkedGrayIfKnown(cell: *const root::js::gc::TenuredCell) -> bool;
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc29PerformIncrementalReadBarrierEN2JS9GCCellPtrE"]
                pub fn PerformIncrementalReadBarrier(thing: root::JS::GCCellPtr);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPPN2JS6BigIntEPKc"]
                pub fn TraceExternalEdge(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JS::BigInt,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPPN2JS6SymbolEPKc"]
                pub fn TraceExternalEdge1(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JS::Symbol,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP6JSAtomPKc"]
                pub fn TraceExternalEdge2(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSAtom,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP10JSFunctionPKc"]
                pub fn TraceExternalEdge3(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSFunction,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP14JSLinearStringPKc"]
                pub fn TraceExternalEdge4(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSLinearString,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSObjectPKc"]
                pub fn TraceExternalEdge5(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSObject,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSScriptPKc"]
                pub fn TraceExternalEdge6(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSScript,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSStringPKc"]
                pub fn TraceExternalEdge7(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSString,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPN2JS5ValueEPKc"]
                pub fn TraceExternalEdge8(
                    trc: *mut root::JSTracer,
                    thingp: *mut root::JS::Value,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPN2JS11PropertyKeyEPKc"]
                pub fn TraceExternalEdge9(
                    trc: *mut root::JSTracer,
                    thingp: *mut root::JS::PropertyKey,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc10TraceRealmEP8JSTracerPN2JS5RealmEPKc"]
                pub fn TraceRealm(
                    trc: *mut root::JSTracer,
                    realm: *mut root::JS::Realm,
                    name: *const ::std::os::raw::c_char,
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GCRuntime {
                _unused: [u8; 0],
            }
            extern "C" {
                #[doc = " Create an object providing access to the garbage collector's internal notion\n of the current state of memory (both GC heap memory and GCthing-controlled\n malloc memory."]
                #[link_name = "\u{1}_ZN2js2gc19NewMemoryInfoObjectEP9JSContext"]
                pub fn NewMemoryInfoObject(cx: *mut root::JSContext) -> *mut root::JSObject;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc25FinalizeDeadNurseryObjectEP9JSContextP8JSObject"]
                pub fn FinalizeDeadNurseryObject(
                    cx: *mut root::JSContext,
                    obj: *mut root::JSObject,
                );
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NurseryDecommitTask {
            _unused: [u8; 0],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26CurrentThreadCanAccessZoneEPN2JS4ZoneE"]
            pub fn CurrentThreadCanAccessZone(zone: *mut root::JS::Zone) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GenericTracerImpl {
            pub _base: root::JSTracer,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AbstractGeneratorObject {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SavedFrame {
            _unused: [u8; 0],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js32UnsafeTraceManuallyBarrieredEdgeEP8JSTracerPP8JSObjectPKc"]
            pub fn UnsafeTraceManuallyBarrieredEdge(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
        }
        pub type HashNumber = root::mozilla::HashNumber;
        pub type DefaultHasher = root::mozilla::DefaultHasher;
        pub type PointerHasher = root::mozilla::PointerHasher;
        pub type HashSet = u8;
        pub type HashMap = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ProfilingStackFrame {
            pub label_: u64,
            pub dynamicString_: u64,
            pub spOrScript: u64,
            pub realmID_: u64,
            pub pcOffsetIfJS_: u32,
            pub flagsAndCategoryPair_: u32,
        }
        impl root::js::ProfilingStackFrame_Flags {
            pub const FLAGS_BITCOUNT: root::js::ProfilingStackFrame_Flags =
                ProfilingStackFrame_Flags::STRING_TEMPLATE_METHOD;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingStackFrame_Flags {
            IS_LABEL_FRAME = 1,
            IS_SP_MARKER_FRAME = 2,
            IS_JS_FRAME = 4,
            JS_OSR = 8,
            STRING_TEMPLATE_METHOD = 16,
            STRING_TEMPLATE_GETTER = 32,
            STRING_TEMPLATE_SETTER = 64,
            RELEVANT_FOR_JS = 128,
            LABEL_DETERMINED_BY_CATEGORY_PAIR = 256,
            NONSENSITIVE = 512,
            IS_BLINTERP_FRAME = 1024,
            FLAGS_MASK = 65535,
        }
        pub const ProfilingStackFrame_NullPCOffset: i32 = -1;
        #[test]
        fn bindgen_test_layout_ProfilingStackFrame() {
            const UNINIT: ::std::mem::MaybeUninit<ProfilingStackFrame> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ProfilingStackFrame>(),
                40usize,
                concat!("Size of: ", stringify!(ProfilingStackFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<ProfilingStackFrame>(),
                8usize,
                concat!("Alignment of ", stringify!(ProfilingStackFrame))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).label_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(label_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).dynamicString_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(dynamicString_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).spOrScript) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(spOrScript)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).realmID_) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(realmID_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).pcOffsetIfJS_) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(pcOffsetIfJS_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).flagsAndCategoryPair_) as usize - ptr as usize
                },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(flagsAndCategoryPair_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24SetContextProfilingStackEP9JSContextP14ProfilingStack"]
            pub fn SetContextProfilingStack(
                cx: *mut root::JSContext,
                profilingStack: *mut root::ProfilingStack,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27EnableContextProfilingStackEP9JSContextb"]
            pub fn EnableContextProfilingStack(cx: *mut root::JSContext, enabled: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js35RegisterContextProfilingEventMarkerEP9JSContextPFvPKcS3_E"]
            pub fn RegisterContextProfilingEventMarker(
                cx: *mut root::JSContext,
                fn_: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_char,
                        arg2: *const ::std::os::raw::c_char,
                    ),
                >,
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoGeckoProfilerEntry {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerEntryMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerBaselineOSRMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerThread {
            pub profilingStack_: *mut root::ProfilingStack,
            pub profilingStackIfEnabled_: *mut root::ProfilingStack,
        }
        #[test]
        fn bindgen_test_layout_GeckoProfilerThread() {
            const UNINIT: ::std::mem::MaybeUninit<GeckoProfilerThread> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GeckoProfilerThread>(),
                16usize,
                concat!("Size of: ", stringify!(GeckoProfilerThread))
            );
            assert_eq!(
                ::std::mem::align_of::<GeckoProfilerThread>(),
                8usize,
                concat!("Alignment of ", stringify!(GeckoProfilerThread))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).profilingStack_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GeckoProfilerThread),
                    "::",
                    stringify!(profilingStack_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).profilingStackIfEnabled_) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GeckoProfilerThread),
                    "::",
                    stringify!(profilingStackIfEnabled_)
                )
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StackFormat {
            SpiderMonkey = 0,
            V8 = 1,
            Default = 2,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14SetStackFormatEP9JSContextNS_11StackFormatE"]
            pub fn SetStackFormat(cx: *mut root::JSContext, format: root::js::StackFormat);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetStackFormatEP9JSContext"]
            pub fn GetStackFormat(cx: *mut root::JSContext) -> root::js::StackFormat;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ThreadType {
            THREAD_TYPE_NONE = 0,
            THREAD_TYPE_MAIN = 1,
            THREAD_TYPE_WASM_COMPILE_TIER1 = 2,
            THREAD_TYPE_WASM_COMPILE_TIER2 = 3,
            THREAD_TYPE_ION = 4,
            THREAD_TYPE_PARSE = 5,
            THREAD_TYPE_COMPRESS = 6,
            THREAD_TYPE_GCPARALLEL = 7,
            THREAD_TYPE_PROMISE_TASK = 8,
            THREAD_TYPE_ION_FREE = 9,
            THREAD_TYPE_WASM_GENERATOR_TIER2 = 10,
            THREAD_TYPE_WORKER = 11,
            THREAD_TYPE_DELAZIFY = 12,
            THREAD_TYPE_DELAZIFY_FREE = 13,
            THREAD_TYPE_MAX = 14,
        }
        pub mod oom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoEnterOOMUnsafeRegion {
            pub _address: u8,
        }
        pub type AutoEnterOOMUnsafeRegion_AnnotateOOMAllocationSizeCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: usize)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2js24AutoEnterOOMUnsafeRegion23annotateOOMSizeCallbackE"]
            pub static mut AutoEnterOOMUnsafeRegion_annotateOOMSizeCallback: u64;
        }
        #[test]
        fn bindgen_test_layout_AutoEnterOOMUnsafeRegion() {
            assert_eq!(
                ::std::mem::size_of::<AutoEnterOOMUnsafeRegion>(),
                1usize,
                concat!("Size of: ", stringify!(AutoEnterOOMUnsafeRegion))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoEnterOOMUnsafeRegion>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoEnterOOMUnsafeRegion))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19InitMallocAllocatorEv"]
            pub fn InitMallocAllocator();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23ShutDownMallocAllocatorEv"]
            pub fn ShutDownMallocAllocator();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34AssertJSStringBufferInCorrectArenaEPKv"]
            pub fn AssertJSStringBufferInCorrectArena(ptr: *const ::std::os::raw::c_void);
        }
        pub type UniquePtr = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BarrierMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableWrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RootedOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsHeapConstructibleType {
            pub _base: root::std::false_type,
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_BigInt_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_Symbol_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSAtom_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSFunction_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSLinearString_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSObject_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSScript_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSString_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_Value_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_PropertyKey_void_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_ptr_JSObject_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_ptr_JSFunction_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_ptr_JSString_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_ptr_BigInt_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MovableCellHasher {
            pub _address: u8,
        }
        pub type MovableCellHasher_Key<T> = T;
        pub type MovableCellHasher_Lookup<T> = T;
        #[repr(C)]
        pub struct VirtualTraceable__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct VirtualTraceable {
            pub vtable_: *const VirtualTraceable__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_VirtualTraceable() {
            assert_eq!(
                ::std::mem::size_of::<VirtualTraceable>(),
                8usize,
                concat!("Size of: ", stringify!(VirtualTraceable))
            );
            assert_eq!(
                ::std::mem::align_of::<VirtualTraceable>(),
                8usize,
                concat!("Alignment of ", stringify!(VirtualTraceable))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StackRootedBase {
            pub stack: *mut *mut root::js::StackRootedBase,
            pub prev: *mut root::js::StackRootedBase,
        }
        #[test]
        fn bindgen_test_layout_StackRootedBase() {
            const UNINIT: ::std::mem::MaybeUninit<StackRootedBase> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<StackRootedBase>(),
                16usize,
                concat!("Size of: ", stringify!(StackRootedBase))
            );
            assert_eq!(
                ::std::mem::align_of::<StackRootedBase>(),
                8usize,
                concat!("Alignment of ", stringify!(StackRootedBase))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StackRootedBase),
                    "::",
                    stringify!(stack)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StackRootedBase),
                    "::",
                    stringify!(prev)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PersistentRootedBase {
            pub _base: root::mozilla::LinkedListElement,
        }
        #[test]
        fn bindgen_test_layout_PersistentRootedBase() {
            assert_eq!(
                ::std::mem::size_of::<PersistentRootedBase>(),
                24usize,
                concat!("Size of: ", stringify!(PersistentRootedBase))
            );
            assert_eq!(
                ::std::mem::align_of::<PersistentRootedBase>(),
                8usize,
                concat!("Alignment of ", stringify!(PersistentRootedBase))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StackRootedTraceableBase {
            pub _base: root::js::StackRootedBase,
            pub _base_1: root::js::VirtualTraceable,
        }
        #[test]
        fn bindgen_test_layout_StackRootedTraceableBase() {
            assert_eq!(
                ::std::mem::size_of::<StackRootedTraceableBase>(),
                24usize,
                concat!("Size of: ", stringify!(StackRootedTraceableBase))
            );
            assert_eq!(
                ::std::mem::align_of::<StackRootedTraceableBase>(),
                8usize,
                concat!("Alignment of ", stringify!(StackRootedTraceableBase))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PersistentRootedTraceableBase {
            pub _base: root::js::PersistentRootedBase,
            pub _base_1: root::js::VirtualTraceable,
        }
        #[test]
        fn bindgen_test_layout_PersistentRootedTraceableBase() {
            assert_eq!(
                ::std::mem::size_of::<PersistentRootedTraceableBase>(),
                32usize,
                concat!("Size of: ", stringify!(PersistentRootedTraceableBase))
            );
            assert_eq!(
                ::std::mem::align_of::<PersistentRootedTraceableBase>(),
                8usize,
                concat!("Alignment of ", stringify!(PersistentRootedTraceableBase))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TypedRootedGCThingBase<Base> {
            pub _base: Base,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TypedRootedTraceableBase<Base> {
            pub _base: Base,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RootedTraceableTraits {
            pub _address: u8,
        }
        pub type RootedTraceableTraits_StackBase =
            root::js::TypedRootedTraceableBase<root::js::StackRootedTraceableBase>;
        pub type RootedTraceableTraits_PersistentBase =
            root::js::TypedRootedTraceableBase<root::js::PersistentRootedTraceableBase>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RootedGCThingTraits {
            pub _address: u8,
        }
        pub type RootedGCThingTraits_StackBase =
            root::js::TypedRootedGCThingBase<root::js::StackRootedBase>;
        pub type RootedGCThingTraits_PersistentBase =
            root::js::TypedRootedGCThingBase<root::js::PersistentRootedBase>;
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_Value_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableValueOperations {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26ReportBadValueTypeAndCrashERKN2JS5ValueE"]
            pub fn ReportBadValueTypeAndCrash(val: *const root::JS::Value) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13ToBooleanSlowEN2JS6HandleINS0_5ValueEEE"]
            pub fn ToBooleanSlow(v: root::JS::HandleValue) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToNumberSlowEP9JSContextN2JS6HandleINS2_5ValueEEEPd"]
            pub fn ToNumberSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                dp: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10ToInt8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPa"]
            pub fn ToInt8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i8,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToUint8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPh"]
            pub fn ToUint8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u8,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPs"]
            pub fn ToInt16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPi"]
            pub fn ToInt32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPj"]
            pub fn ToUint32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPt"]
            pub fn ToUint16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPl"]
            pub fn ToInt64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPm"]
            pub fn ToUint64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToStringSlowEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ToStringSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToObjectSlowEP9JSContextN2JS6HandleINS2_5ValueEEEb"]
            pub fn ToObjectSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                reportScanStack: bool,
            ) -> *mut root::JSObject;
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_PropertyKey_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ErrorContext {
            _unused: [u8; 0],
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AllocFunction {
            Malloc = 0,
            Calloc = 1,
            Realloc = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocPolicyBase {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AllocPolicyBase() {
            assert_eq!(
                ::std::mem::size_of::<AllocPolicyBase>(),
                1usize,
                concat!("Size of: ", stringify!(AllocPolicyBase))
            );
            assert_eq!(
                ::std::mem::align_of::<AllocPolicyBase>(),
                1usize,
                concat!("Alignment of ", stringify!(AllocPolicyBase))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_SystemAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<SystemAllocPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(SystemAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<SystemAllocPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(SystemAllocPolicy))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17ReportOutOfMemoryEP9JSContext"]
            pub fn ReportOutOfMemory(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17ReportOutOfMemoryEPNS_12ErrorContextE"]
            pub fn ReportOutOfMemory1(ec: *mut root::js::ErrorContext);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TempAllocPolicy {
            pub cx_: *mut root::JSContext,
        }
        #[test]
        fn bindgen_test_layout_TempAllocPolicy() {
            const UNINIT: ::std::mem::MaybeUninit<TempAllocPolicy> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TempAllocPolicy>(),
                8usize,
                concat!("Size of: ", stringify!(TempAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<TempAllocPolicy>(),
                8usize,
                concat!("Alignment of ", stringify!(TempAllocPolicy))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).cx_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TempAllocPolicy),
                    "::",
                    stringify!(cx_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_MallocAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<MallocAllocPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(MallocAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<MallocAllocPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(MallocAllocPolicy))
            );
        }
        extern "C" {
            #[doc = " In memory reporting, we have concept of \"sundries\", line items which are too\n small to be worth reporting individually.  Under some circumstances, a memory\n reporter gets tossed into the sundries bucket if it's smaller than\n MemoryReportingSundriesThreshold() bytes.\n\n We need to define this value here, rather than in the code which actually\n generates the memory reports, because NotableStringInfo uses this value."]
            #[link_name = "\u{1}_ZN2js32MemoryReportingSundriesThresholdEv"]
            pub fn MemoryReportingSundriesThreshold() -> usize;
        }
        #[doc = " This hash policy avoids flattening ropes (which perturbs the site being\n measured and requires a JSContext) at the expense of doing a FULL ROPE COPY\n on every hash and match! Beware."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InefficientNonFlatteningStringHashPolicy {
            pub _address: u8,
        }
        pub type InefficientNonFlatteningStringHashPolicy_Lookup = *mut root::JSString;
        #[test]
        fn bindgen_test_layout_InefficientNonFlatteningStringHashPolicy() {
            assert_eq!(
                ::std::mem::size_of::<InefficientNonFlatteningStringHashPolicy>(),
                1usize,
                concat!(
                    "Size of: ",
                    stringify!(InefficientNonFlatteningStringHashPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<InefficientNonFlatteningStringHashPolicy>(),
                1usize,
                concat!(
                    "Alignment of ",
                    stringify!(InefficientNonFlatteningStringHashPolicy)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyResult {
            _unused: [u8; 0],
        }
        pub type LookupPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                objp: root::JS::MutableHandleObject,
                propp: *mut root::js::PropertyResult,
            ) -> bool,
        >;
        pub type DefinePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type HasPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                foundp: *mut bool,
            ) -> bool,
        >;
        pub type GetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >;
        pub type SetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type GetOwnPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: u8,
            ) -> bool,
        >;
        pub type DeletePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        #[repr(C)]
        pub struct ElementAdder {
            pub resObj_: root::JS::RootedObject,
            pub vp_: *mut root::JS::Value,
            pub index_: u32,
            pub getBehavior_: root::js::ElementAdder_GetBehavior,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ElementAdder_GetBehavior {
            CheckHasElemPreserveHoles = 0,
            GetElement = 1,
        }
        #[test]
        fn bindgen_test_layout_ElementAdder() {
            const UNINIT: ::std::mem::MaybeUninit<ElementAdder> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ElementAdder>(),
                40usize,
                concat!("Size of: ", stringify!(ElementAdder))
            );
            assert_eq!(
                ::std::mem::align_of::<ElementAdder>(),
                8usize,
                concat!("Alignment of ", stringify!(ElementAdder))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).resObj_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(resObj_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).vp_) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(vp_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).index_) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(index_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).getBehavior_) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(getBehavior_)
                )
            );
        }
        pub type GetElementsOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool,
        >;
        #[doc = " Callback for the creation of constructor and prototype objects."]
        pub type ClassObjectCreationOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
            ) -> *mut root::JSObject,
        >;
        #[doc = " Callback for custom post-processing after class initialization via\n ClassSpec."]
        pub type FinishClassInitOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                ctor: root::JS::HandleObject,
                proto: root::JS::HandleObject,
            ) -> bool,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClassSpec {
            pub createConstructor: root::js::ClassObjectCreationOp,
            pub createPrototype: root::js::ClassObjectCreationOp,
            pub constructorFunctions: *const root::JSFunctionSpec,
            pub constructorProperties: *const root::JSPropertySpec,
            pub prototypeFunctions: *const root::JSFunctionSpec,
            pub prototypeProperties: *const root::JSPropertySpec,
            pub finishInit: root::js::FinishClassInitOp,
            pub flags: usize,
        }
        pub const ClassSpec_ProtoKeyWidth: usize = 7;
        pub const ClassSpec_ProtoKeyMask: usize = 127;
        pub const ClassSpec_DontDefineConstructor: usize = 128;
        #[test]
        fn bindgen_test_layout_ClassSpec() {
            const UNINIT: ::std::mem::MaybeUninit<ClassSpec> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClassSpec>(),
                64usize,
                concat!("Size of: ", stringify!(ClassSpec))
            );
            assert_eq!(
                ::std::mem::align_of::<ClassSpec>(),
                8usize,
                concat!("Alignment of ", stringify!(ClassSpec))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).createConstructor) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(createConstructor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).createPrototype) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(createPrototype)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).constructorFunctions) as usize - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(constructorFunctions)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).constructorProperties) as usize - ptr as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(constructorProperties)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).prototypeFunctions) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(prototypeFunctions)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).prototypeProperties) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(prototypeProperties)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).finishInit) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(finishInit)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(flags)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClassExtension {
            #[doc = " Optional hook called when an object is moved by generational or\n compacting GC.\n\n There may exist weak pointers to an object that are not traced through\n when the normal trace APIs are used, for example objects in the wrapper\n cache. This hook allows these pointers to be updated.\n\n Note that this hook can be called before JS_NewObject() returns if a GC\n is triggered during construction of the object. This can happen for\n global objects for example.\n\n The function should return the difference between nursery bytes used and\n tenured bytes used, which may be nonzero e.g. if some nursery-allocated\n data beyond the actual GC thing is moved into malloced memory.\n\n This is used to compute the nursery promotion rate."]
            pub objectMovedOp: root::JSObjectMovedOp,
        }
        #[test]
        fn bindgen_test_layout_ClassExtension() {
            const UNINIT: ::std::mem::MaybeUninit<ClassExtension> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClassExtension>(),
                8usize,
                concat!("Size of: ", stringify!(ClassExtension))
            );
            assert_eq!(
                ::std::mem::align_of::<ClassExtension>(),
                8usize,
                concat!("Alignment of ", stringify!(ClassExtension))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).objectMovedOp) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassExtension),
                    "::",
                    stringify!(objectMovedOp)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectOps {
            pub lookupProperty: root::js::LookupPropertyOp,
            pub defineProperty: root::js::DefinePropertyOp,
            pub hasProperty: root::js::HasPropertyOp,
            pub getProperty: root::js::GetPropertyOp,
            pub setProperty: root::js::SetPropertyOp,
            pub getOwnPropertyDescriptor: root::js::GetOwnPropertyOp,
            pub deleteProperty: root::js::DeletePropertyOp,
            pub getElements: root::js::GetElementsOp,
            pub funToString: root::JSFunToStringOp,
        }
        #[test]
        fn bindgen_test_layout_ObjectOps() {
            const UNINIT: ::std::mem::MaybeUninit<ObjectOps> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ObjectOps>(),
                72usize,
                concat!("Size of: ", stringify!(ObjectOps))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectOps>(),
                8usize,
                concat!("Alignment of ", stringify!(ObjectOps))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).lookupProperty) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(lookupProperty)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).defineProperty) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(defineProperty)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).hasProperty) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(hasProperty)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).getProperty) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(getProperty)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).setProperty) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(setProperty)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).getOwnPropertyDescriptor) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(getOwnPropertyDescriptor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).deleteProperty) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(deleteProperty)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).getElements) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(getElements)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).funToString) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(funToString)
                )
            );
        }
        #[repr(i32)]
        #[doc = " Enumeration describing possible values of the [[Class]] internal property\n value of objects."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ESClass {
            Object = 0,
            Array = 1,
            Number = 2,
            String = 3,
            Boolean = 4,
            RegExp = 5,
            ArrayBuffer = 6,
            SharedArrayBuffer = 7,
            Date = 8,
            Set = 9,
            Map = 10,
            Promise = 11,
            MapIterator = 12,
            SetIterator = 13,
            Arguments = 14,
            Error = 15,
            BigInt = 16,
            Function = 17,
            #[doc = " None of the above."]
            Other = 18,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js5UnboxEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleINS2_5ValueEEE"]
            pub fn Unbox(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        #[repr(C)]
        pub struct BaseProxyHandler__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseProxyHandler {
            pub vtable_: *const BaseProxyHandler__bindgen_vtable,
            pub mFamily: *const ::std::os::raw::c_void,
            pub mHasPrototype: bool,
            pub mHasSecurityPolicy: bool,
        }
        pub type BaseProxyHandler_Action = u32;
        pub const BaseProxyHandler_NONE: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::NONE;
        pub const BaseProxyHandler_GET: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::GET;
        pub const BaseProxyHandler_SET: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::SET;
        pub const BaseProxyHandler_CALL: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::CALL;
        pub const BaseProxyHandler_ENUMERATE: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::ENUMERATE;
        pub const BaseProxyHandler_GET_PROPERTY_DESCRIPTOR:
            root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::GET_PROPERTY_DESCRIPTOR;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BaseProxyHandler__bindgen_ty_1 {
            NONE = 0,
            GET = 1,
            SET = 2,
            CALL = 4,
            ENUMERATE = 8,
            GET_PROPERTY_DESCRIPTOR = 16,
        }
        #[test]
        fn bindgen_test_layout_BaseProxyHandler() {
            const UNINIT: ::std::mem::MaybeUninit<BaseProxyHandler> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<BaseProxyHandler>(),
                18usize,
                concat!("Size of: ", stringify!(BaseProxyHandler))
            );
            assert_eq!(
                ::std::mem::align_of::<BaseProxyHandler>(),
                1usize,
                concat!("Alignment of ", stringify!(BaseProxyHandler))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mFamily) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BaseProxyHandler),
                    "::",
                    stringify!(mFamily)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mHasPrototype) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BaseProxyHandler),
                    "::",
                    stringify!(mHasPrototype)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mHasSecurityPolicy) as usize - ptr as usize },
                17usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BaseProxyHandler),
                    "::",
                    stringify!(mHasSecurityPolicy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10ProxyClassE"]
            pub static ProxyClass: root::JSClass;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ProxyOptions {
            pub lazyProto_: bool,
            pub clasp_: *const root::JSClass,
        }
        #[test]
        fn bindgen_test_layout_ProxyOptions() {
            const UNINIT: ::std::mem::MaybeUninit<ProxyOptions> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ProxyOptions>(),
                16usize,
                concat!("Size of: ", stringify!(ProxyOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<ProxyOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(ProxyOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).lazyProto_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProxyOptions),
                    "::",
                    stringify!(lazyProto_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).clasp_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProxyOptions),
                    "::",
                    stringify!(clasp_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14NewProxyObjectEP9JSContextPKNS_16BaseProxyHandlerEN2JS6HandleINS5_5ValueEEEP8JSObjectRKNS_12ProxyOptionsE"]
            pub fn NewProxyObject(
                cx: *mut root::JSContext,
                handler: *const root::js::BaseProxyHandler,
                priv_: root::JS::HandleValue,
                proto: *mut root::JSObject,
                options: *const root::js::ProxyOptions,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16RenewProxyObjectEP9JSContextP8JSObjectPNS_16BaseProxyHandlerERKN2JS5ValueE"]
            pub fn RenewProxyObject(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                handler: *mut root::js::BaseProxyHandler,
                priv_: *const root::JS::Value,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        pub struct AutoEnterPolicy__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoEnterPolicy {
            pub vtable_: *const AutoEnterPolicy__bindgen_vtable,
            pub allow: bool,
            pub rv: bool,
        }
        pub type AutoEnterPolicy_Action = root::js::BaseProxyHandler_Action;
        #[test]
        fn bindgen_test_layout_AutoEnterPolicy() {
            const UNINIT: ::std::mem::MaybeUninit<AutoEnterPolicy> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoEnterPolicy>(),
                16usize,
                concat!("Size of: ", stringify!(AutoEnterPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoEnterPolicy>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoEnterPolicy))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).allow) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoEnterPolicy),
                    "::",
                    stringify!(allow)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).rv) as usize - ptr as usize },
                9usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoEnterPolicy),
                    "::",
                    stringify!(rv)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoWaivePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoWaivePolicy() {
            assert_eq!(
                ::std::mem::size_of::<AutoWaivePolicy>(),
                1usize,
                concat!("Size of: ", stringify!(AutoWaivePolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoWaivePolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoWaivePolicy))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13ProxyClassOpsE"]
            pub static ProxyClassOps: root::JSClassOps;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19ProxyClassExtensionE"]
            pub static ProxyClassExtension: root::js::ClassExtension;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14ProxyObjectOpsE"]
            pub static ProxyObjectOps: root::js::ObjectOps;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15NukeNonCCWProxyEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn NukeNonCCWProxy(cx: *mut root::JSContext, proxy: root::JS::HandleObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34NukeRemovedCrossCompartmentWrapperEP9JSContextP8JSObject"]
            pub fn NukeRemovedCrossCompartmentWrapper(
                cx: *mut root::JSContext,
                wrapper: *mut root::JSObject,
            );
        }
        extern "C" {
            #[doc = " Get the first SavedFrame object in this SavedFrame stack whose principals are\n subsumed by the given |principals|. If there is no such frame, return\n nullptr.\n\n Do NOT pass a non-SavedFrame object here."]
            #[link_name = "\u{1}_ZN2js26GetFirstSubsumedSavedFrameEP9JSContextP12JSPrincipalsN2JS6HandleIP8JSObjectEENS4_20SavedFrameSelfHostedE"]
            pub fn GetFirstSubsumedSavedFrame(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SharedArrayRawBuffer {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SharedArrayRawBufferRefs {
            pub refs_: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_SharedArrayRawBufferRefs() {
            const UNINIT: ::std::mem::MaybeUninit<SharedArrayRawBufferRefs> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SharedArrayRawBufferRefs>(),
                24usize,
                concat!("Size of: ", stringify!(SharedArrayRawBufferRefs))
            );
            assert_eq!(
                ::std::mem::align_of::<SharedArrayRawBufferRefs>(),
                8usize,
                concat!("Alignment of ", stringify!(SharedArrayRawBufferRefs))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).refs_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayRawBufferRefs),
                    "::",
                    stringify!(refs_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferIterator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RefCounted {
            pub mRefCnt: root::MozRefCountType,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AtomicRefCounted {
            pub mRefCnt: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ParseTask {
            _unused: [u8; 0],
        }
        pub mod frontend {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationStencil {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationGCOutput {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WrapperOptions {
            pub _base: root::js::ProxyOptions,
            pub proto_: [u64; 4usize],
        }
        #[test]
        fn bindgen_test_layout_WrapperOptions() {
            const UNINIT: ::std::mem::MaybeUninit<WrapperOptions> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<WrapperOptions>(),
                48usize,
                concat!("Size of: ", stringify!(WrapperOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<WrapperOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(WrapperOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).proto_) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WrapperOptions),
                    "::",
                    stringify!(proto_)
                )
            );
        }
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct ForwardingProxyHandler {
            pub _base: root::js::BaseProxyHandler,
        }
        #[test]
        fn bindgen_test_layout_ForwardingProxyHandler() {
            assert_eq!(
                ::std::mem::size_of::<ForwardingProxyHandler>(),
                18usize,
                concat!("Size of: ", stringify!(ForwardingProxyHandler))
            );
            assert_eq!(
                ::std::mem::align_of::<ForwardingProxyHandler>(),
                1usize,
                concat!("Alignment of ", stringify!(ForwardingProxyHandler))
            );
        }
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct Wrapper {
            pub _base: root::js::ForwardingProxyHandler,
            pub mFlags: ::std::os::raw::c_uint,
        }
        impl root::js::Wrapper_Flags {
            pub const LAST_USED_FLAG: root::js::Wrapper_Flags = Wrapper_Flags::CROSS_COMPARTMENT;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Wrapper_Flags {
            CROSS_COMPARTMENT = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper6familyE"]
            pub static Wrapper_family: ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper9singletonE"]
            pub static Wrapper_singleton: root::js::Wrapper;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper22singletonWithPrototypeE"]
            pub static Wrapper_singletonWithPrototype: root::js::Wrapper;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper12defaultProtoE"]
            pub static Wrapper_defaultProto: *mut root::JSObject;
        }
        #[test]
        fn bindgen_test_layout_Wrapper() {
            const UNINIT: ::std::mem::MaybeUninit<Wrapper> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Wrapper>(),
                22usize,
                concat!("Size of: ", stringify!(Wrapper))
            );
            assert_eq!(
                ::std::mem::align_of::<Wrapper>(),
                1usize,
                concat!("Alignment of ", stringify!(Wrapper))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mFlags) as usize - ptr as usize },
                18usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Wrapper),
                    "::",
                    stringify!(mFlags)
                )
            );
        }
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct CrossCompartmentWrapper {
            pub _base: root::js::Wrapper,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23CrossCompartmentWrapper9singletonE"]
            pub static CrossCompartmentWrapper_singleton: root::js::CrossCompartmentWrapper;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23CrossCompartmentWrapper22singletonWithPrototypeE"]
            pub static CrossCompartmentWrapper_singletonWithPrototype:
                root::js::CrossCompartmentWrapper;
        }
        #[test]
        fn bindgen_test_layout_CrossCompartmentWrapper() {
            assert_eq!(
                ::std::mem::size_of::<CrossCompartmentWrapper>(),
                22usize,
                concat!("Size of: ", stringify!(CrossCompartmentWrapper))
            );
            assert_eq!(
                ::std::mem::align_of::<CrossCompartmentWrapper>(),
                1usize,
                concat!("Alignment of ", stringify!(CrossCompartmentWrapper))
            );
        }
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct OpaqueCrossCompartmentWrapper {
            pub _base: root::js::CrossCompartmentWrapper,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js29OpaqueCrossCompartmentWrapper9singletonE"]
            pub static OpaqueCrossCompartmentWrapper_singleton:
                root::js::OpaqueCrossCompartmentWrapper;
        }
        #[test]
        fn bindgen_test_layout_OpaqueCrossCompartmentWrapper() {
            assert_eq!(
                ::std::mem::size_of::<OpaqueCrossCompartmentWrapper>(),
                22usize,
                concat!("Size of: ", stringify!(OpaqueCrossCompartmentWrapper))
            );
            assert_eq!(
                ::std::mem::align_of::<OpaqueCrossCompartmentWrapper>(),
                1usize,
                concat!("Alignment of ", stringify!(OpaqueCrossCompartmentWrapper))
            );
        }
        #[repr(C)]
        pub struct SecurityWrapper__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SecurityWrapper<Base> {
            pub vtable_: *const SecurityWrapper__bindgen_vtable,
            pub _base: Base,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
        }
        pub type SecurityWrapper_Permissive<Base> = Base;
        pub type SecurityWrapper_Restrictive<Base> = root::js::SecurityWrapper<Base>;
        pub type CrossCompartmentSecurityWrapper =
            root::js::SecurityWrapper<root::js::CrossCompartmentWrapper>;
        extern "C" {
            #[link_name = "\u{1}_ZN2js24TransparentObjectWrapperEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn TransparentObjectWrapper(
                cx: *mut root::JSContext,
                existing: root::JS::HandleObject,
                obj: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15UncheckedUnwrapEP8JSObjectbPj"]
            pub fn UncheckedUnwrap(
                obj: *mut root::JSObject,
                stopAtWindowProxy: bool,
                flagsp: *mut ::std::os::raw::c_uint,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19CheckedUnwrapStaticEP8JSObject"]
            pub fn CheckedUnwrapStatic(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js22UnwrapOneCheckedStaticEP8JSObject"]
            pub fn UnwrapOneCheckedStatic(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20CheckedUnwrapDynamicEP8JSObjectP9JSContextb"]
            pub fn CheckedUnwrapDynamic(
                obj: *mut root::JSObject,
                cx: *mut root::JSContext,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23UnwrapOneCheckedDynamicEN2JS6HandleIP8JSObjectEEP9JSContextb"]
            pub fn UnwrapOneCheckedDynamic(
                obj: root::JS::HandleObject,
                cx: *mut root::JSContext,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28UncheckedUnwrapWithoutExposeEP8JSObject"]
            pub fn UncheckedUnwrapWithoutExpose(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18ReportAccessDeniedEP9JSContext"]
            pub fn ReportAccessDenied(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27NukeCrossCompartmentWrapperEP9JSContextP8JSObject"]
            pub fn NukeCrossCompartmentWrapper(
                cx: *mut root::JSContext,
                wrapper: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js35NukeCrossCompartmentWrapperIfExistsEP9JSContextPN2JS11CompartmentEP8JSObject"]
            pub fn NukeCrossCompartmentWrapperIfExists(
                cx: *mut root::JSContext,
                source: *mut root::JS::Compartment,
                target: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12RemapWrapperEP9JSContextP8JSObjectS3_"]
            pub fn RemapWrapper(
                cx: *mut root::JSContext,
                wobj: *mut root::JSObject,
                newTarget: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16RemapDeadWrapperEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn RemapDeadWrapper(
                cx: *mut root::JSContext,
                wobj: root::JS::HandleObject,
                newTarget: root::JS::HandleObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25RemapAllWrappersForObjectEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn RemapAllWrappersForObject(
                cx: *mut root::JSContext,
                oldTarget: root::JS::HandleObject,
                newTarget: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17RecomputeWrappersEP9JSContextRKNS_17CompartmentFilterES4_"]
            pub fn RecomputeWrappers(
                cx: *mut root::JSContext,
                sourceFilter: *const root::js::CompartmentFilter,
                targetFilter: *const root::js::CompartmentFilter,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21UnwrapArrayBufferViewEP8JSObject"]
            pub fn UnwrapArrayBufferView(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20UnwrapReadableStreamEP8JSObject"]
            pub fn UnwrapReadableStream(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31GetArrayBufferViewLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferViewLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15UnwrapInt8ArrayEP8JSObject"]
            pub fn UnwrapInt8Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapUint8ArrayEP8JSObject"]
            pub fn UnwrapUint8Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapInt16ArrayEP8JSObject"]
            pub fn UnwrapInt16Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17UnwrapUint16ArrayEP8JSObject"]
            pub fn UnwrapUint16Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapInt32ArrayEP8JSObject"]
            pub fn UnwrapInt32Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17UnwrapUint32ArrayEP8JSObject"]
            pub fn UnwrapUint32Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18UnwrapFloat32ArrayEP8JSObject"]
            pub fn UnwrapFloat32Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18UnwrapFloat64ArrayEP8JSObject"]
            pub fn UnwrapFloat64Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23UnwrapUint8ClampedArrayEP8JSObject"]
            pub fn UnwrapUint8ClampedArray(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19UnwrapBigInt64ArrayEP8JSObject"]
            pub fn UnwrapBigInt64Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20UnwrapBigUint64ArrayEP8JSObject"]
            pub fn UnwrapBigUint64Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        pub type EnableIfABOVType = root::std::enable_if_t;
        extern "C" {
            #[doc = " A JSErrorCallback suitable for passing to |JS_ReportErrorNumberASCII| and\n similar functions in concert with one of the |JSErrNum| error numbers.\n\n This function is a function only of |errorNumber|: |userRef| and ambient\n state have no effect on its behavior."]
            #[link_name = "\u{1}_ZN2js15GetErrorMessageEPvj"]
            pub fn GetErrorMessage(
                userRef: *mut ::std::os::raw::c_void,
                errorNumber: ::std::os::raw::c_uint,
            ) -> *const root::JSErrorFormatString;
        }
        extern "C" {
            #[doc = " Tell the JS engine which Class is used for WindowProxy objects. Used by the\n functions below."]
            #[link_name = "\u{1}_ZN2js19SetWindowProxyClassEP9JSContextPK7JSClass"]
            pub fn SetWindowProxyClass(cx: *mut root::JSContext, clasp: *const root::JSClass);
        }
        extern "C" {
            #[doc = " Associates a WindowProxy with a Window (global object). `windowProxy` must\n have the Class set by SetWindowProxyClass."]
            #[link_name = "\u{1}_ZN2js14SetWindowProxyEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn SetWindowProxy(
                cx: *mut root::JSContext,
                global: root::JS::Handle<*mut root::JSObject>,
                windowProxy: root::JS::Handle<*mut root::JSObject>,
            );
        }
        extern "C" {
            #[doc = " Returns true iff `obj` has the WindowProxy Class (see SetWindowProxyClass)."]
            #[link_name = "\u{1}_ZN2js13IsWindowProxyEP8JSObject"]
            pub fn IsWindowProxy(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " If `obj` is a WindowProxy, get its associated Window (the compartment's\n global), else return `obj`. This function is infallible and never returns\n nullptr."]
            #[link_name = "\u{1}_ZN2js21ToWindowIfWindowProxyEP8JSObject"]
            pub fn ToWindowIfWindowProxy(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15TraceValueArrayEP8JSTracermPN2JS5ValueE"]
            pub fn TraceValueArray(
                trc: *mut root::JSTracer,
                length: usize,
                elements: *mut root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16AssertHeapIsIdleEv"]
            pub fn AssertHeapIsIdle();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeBudget {
            pub budget: root::mozilla::TimeDuration,
            pub deadline: root::mozilla::TimeStamp,
        }
        #[test]
        fn bindgen_test_layout_TimeBudget() {
            const UNINIT: ::std::mem::MaybeUninit<TimeBudget> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TimeBudget>(),
                16usize,
                concat!("Size of: ", stringify!(TimeBudget))
            );
            assert_eq!(
                ::std::mem::align_of::<TimeBudget>(),
                8usize,
                concat!("Alignment of ", stringify!(TimeBudget))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).budget) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimeBudget),
                    "::",
                    stringify!(budget)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).deadline) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimeBudget),
                    "::",
                    stringify!(deadline)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WorkBudget {
            pub budget: i64,
        }
        #[test]
        fn bindgen_test_layout_WorkBudget() {
            const UNINIT: ::std::mem::MaybeUninit<WorkBudget> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<WorkBudget>(),
                8usize,
                concat!("Size of: ", stringify!(WorkBudget))
            );
            assert_eq!(
                ::std::mem::align_of::<WorkBudget>(),
                8usize,
                concat!("Alignment of ", stringify!(WorkBudget))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).budget) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WorkBudget),
                    "::",
                    stringify!(budget)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UnlimitedBudget {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_UnlimitedBudget() {
            assert_eq!(
                ::std::mem::size_of::<UnlimitedBudget>(),
                1usize,
                concat!("Size of: ", stringify!(UnlimitedBudget))
            );
            assert_eq!(
                ::std::mem::align_of::<UnlimitedBudget>(),
                1usize,
                concat!("Alignment of ", stringify!(UnlimitedBudget))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SliceBudget {
            pub idle: bool,
            pub extended: bool,
            pub budget: [u64; 3usize],
            pub interruptRequested: *mut root::js::SliceBudget_InterruptRequestFlag,
            pub counter: i64,
            pub interrupted: bool,
        }
        pub type SliceBudget_InterruptRequestFlag = u8;
        pub const SliceBudget_UnlimitedCounter: isize = isize::MAX;
        pub const SliceBudget_StepsPerExpensiveCheck: isize = 1000;
        #[test]
        fn bindgen_test_layout_SliceBudget() {
            const UNINIT: ::std::mem::MaybeUninit<SliceBudget> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SliceBudget>(),
                56usize,
                concat!("Size of: ", stringify!(SliceBudget))
            );
            assert_eq!(
                ::std::mem::align_of::<SliceBudget>(),
                8usize,
                concat!("Alignment of ", stringify!(SliceBudget))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).idle) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SliceBudget),
                    "::",
                    stringify!(idle)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).extended) as usize - ptr as usize },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SliceBudget),
                    "::",
                    stringify!(extended)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).budget) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SliceBudget),
                    "::",
                    stringify!(budget)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).interruptRequested) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SliceBudget),
                    "::",
                    stringify!(interruptRequested)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SliceBudget),
                    "::",
                    stringify!(counter)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).interrupted) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SliceBudget),
                    "::",
                    stringify!(interrupted)
                )
            );
        }
        pub mod gcstats {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Statistics {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Debugger {
            _unused: [u8; 0],
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ErrorArgumentsType {
            ArgumentsAreUnicode = 0,
            ArgumentsAreASCII = 1,
            ArgumentsAreLatin1 = 2,
            ArgumentsAreUTF8 = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptSource {
            _unused: [u8; 0],
        }
        extern "C" {
            #[doc = " Hint that we expect a crash. Currently, the only thing that cares is the\n breakpad injector, which (if loaded) will suppress minidump generation."]
            #[link_name = "\u{1}_ZN2js20NoteIntentionalCrashEv"]
            pub fn NoteIntentionalCrash();
        }
        extern "C" {
            #[doc = " Get the script private value associated with an object, if any.\n\n The private value is set with SetScriptPrivate() or SetModulePrivate() and is\n internally stored on the relevant ScriptSourceObject.\n\n This is used by the cycle collector to trace through\n ScriptSourceObjects. This allows private values to contain an nsISupports\n pointer and hence support references to cycle collected C++ objects."]
            #[link_name = "\u{1}_ZN2js21MaybeGetScriptPrivateEP8JSObject"]
            pub fn MaybeGetScriptPrivate(object: *mut root::JSObject) -> root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17IsArgumentsObjectEN2JS6HandleIP8JSObjectEE"]
            pub fn IsArgumentsObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15AddRawValueRootEP9JSContextPN2JS5ValueEPKc"]
            pub fn AddRawValueRoot(
                cx: *mut root::JSContext,
                vp: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18RemoveRawValueRootEP9JSContextPN2JS5ValueE"]
            pub fn RemoveRawValueRoot(cx: *mut root::JSContext, vp: *mut root::JS::Value);
        }
        extern "C" {
            #[doc = " Use the runtime's internal handling of job queues for Promise jobs.\n\n Most embeddings, notably web browsers, will have their own task scheduling\n systems and need to integrate handling of Promise jobs into that, so they\n will want to manage job queues themselves. For basic embeddings such as the\n JS shell that don't have an event loop of their own, it's easier to have\n SpiderMonkey handle job queues internally.\n\n Note that the embedding still has to trigger processing of job queues at\n right time(s), such as after evaluation of a script has run to completion."]
            #[link_name = "\u{1}_ZN2js20UseInternalJobQueuesEP9JSContext"]
            pub fn UseInternalJobQueues(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Enqueue |job| on the internal job queue.\n\n This is useful in tests for creating situations where a call occurs with no\n other JavaScript on the stack."]
            #[link_name = "\u{1}_ZN2js10EnqueueJobEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn EnqueueJob(cx: *mut root::JSContext, job: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[doc = " Instruct the runtime to stop draining the internal job queue.\n\n Useful if the embedding is in the process of quitting in reaction to a\n builtin being called, or if it wants to resume executing jobs later on."]
            #[link_name = "\u{1}_ZN2js20StopDrainingJobQueueEP9JSContext"]
            pub fn StopDrainingJobQueue(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7RunJobsEP9JSContext"]
            pub fn RunJobs(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12GetRealmZoneEPN2JS5RealmE"]
            pub fn GetRealmZone(realm: *mut root::JS::Realm) -> *mut root::JS::Zone;
        }
        pub type PreserveWrapperCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::JSContext, arg2: root::JS::HandleObject) -> bool,
        >;
        pub type HasReleasedWrapperCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: root::JS::HandleObject) -> bool>;
        extern "C" {
            #[link_name = "\u{1}_ZN2js13IsSystemRealmEPN2JS5RealmE"]
            pub fn IsSystemRealm(realm: *mut root::JS::Realm) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19IsSystemCompartmentEPN2JS11CompartmentE"]
            pub fn IsSystemCompartment(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12IsSystemZoneEPN2JS4ZoneE"]
            pub fn IsSystemZone(zone: *mut root::JS::Zone) -> bool;
        }
        #[repr(C)]
        pub struct WeakMapTracer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WeakMapTracer {
            pub vtable_: *const WeakMapTracer__bindgen_vtable,
            pub runtime: *mut root::JSRuntime,
        }
        #[test]
        fn bindgen_test_layout_WeakMapTracer() {
            const UNINIT: ::std::mem::MaybeUninit<WeakMapTracer> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<WeakMapTracer>(),
                16usize,
                concat!("Size of: ", stringify!(WeakMapTracer))
            );
            assert_eq!(
                ::std::mem::align_of::<WeakMapTracer>(),
                8usize,
                concat!("Alignment of ", stringify!(WeakMapTracer))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).runtime) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WeakMapTracer),
                    "::",
                    stringify!(runtime)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13TraceWeakMapsEPNS_13WeakMapTracerE"]
            pub fn TraceWeakMaps(trc: *mut root::js::WeakMapTracer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18AreGCGrayBitsValidEP9JSRuntime"]
            pub fn AreGCGrayBitsValid(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21ZoneGlobalsAreAllGrayEPN2JS4ZoneE"]
            pub fn ZoneGlobalsAreAllGray(zone: *mut root::JS::Zone) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js37IsCompartmentZoneSweepingOrCompactingEPN2JS11CompartmentE"]
            pub fn IsCompartmentZoneSweepingOrCompacting(comp: *mut root::JS::Compartment) -> bool;
        }
        pub type IterateGCThingCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: root::JS::GCCellPtr,
                arg3: *const root::JS::AutoRequireNoGC,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2js23TraceGrayWrapperTargetsEP8JSTracerPN2JS4ZoneE"]
            pub fn TraceGrayWrapperTargets(trc: *mut root::JSTracer, zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Invoke cellCallback on every gray JSObject in the given zone."]
            #[link_name = "\u{1}_ZN2js18IterateGrayObjectsEPN2JS4ZoneEPFvPvNS0_9GCCellPtrERKNS0_15AutoRequireNoGCEES3_"]
            pub fn IterateGrayObjects(
                zone: *mut root::JS::Zone,
                cellCallback: root::js::IterateGCThingCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17GetAnyRealmInZoneEPN2JS4ZoneE"]
            pub fn GetAnyRealmInZone(zone: *mut root::JS::Zone) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27GetFirstGlobalInCompartmentEPN2JS11CompartmentE"]
            pub fn GetFirstGlobalInCompartment(
                comp: *mut root::JS::Compartment,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24CompartmentHasLiveGlobalEPN2JS11CompartmentE"]
            pub fn CompartmentHasLiveGlobal(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21IsSharableCompartmentEPN2JS11CompartmentE"]
            pub fn IsSharableCompartment(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15ProtoKeyToClassE10JSProtoKey"]
            pub fn ProtoKeyToClass(key: root::JSProtoKey) -> *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js30ShouldIgnorePropertyDefinitionEP9JSContext10JSProtoKeyN2JS11PropertyKeyE"]
            pub fn ShouldIgnorePropertyDefinition(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                id: root::jsid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16IsFunctionObjectEP8JSObject"]
            pub fn IsFunctionObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34UninlinedIsCrossCompartmentWrapperEPK8JSObject"]
            pub fn UninlinedIsCrossCompartmentWrapper(obj: *const root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextP8JSObject"]
            pub fn AssertSameCompartment(cx: *mut root::JSContext, obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn AssertSameCompartment1(cx: *mut root::JSContext, v: root::JS::HandleValue);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23NotifyAnimationActivityEP8JSObject"]
            pub fn NotifyAnimationActivity(obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26DefineFunctionWithReservedEP9JSContextP8JSObjectPKcPFbS1_jPN2JS5ValueEEjj"]
            pub fn DefineFunctionWithReserved(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                attrs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23NewFunctionWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjPKc"]
            pub fn NewFunctionWithReserved(
                cx: *mut root::JSContext,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                name: *const ::std::os::raw::c_char,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27NewFunctionByIdWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjNS2_11PropertyKeyE"]
            pub fn NewFunctionByIdWithReserved(
                cx: *mut root::JSContext,
                native: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                id: root::jsid,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25GetFunctionNativeReservedEP8JSObjectm"]
            pub fn GetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
            ) -> *const root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25SetFunctionNativeReservedEP8JSObjectmRKN2JS5ValueE"]
            pub fn SetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
                val: *const root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25FunctionHasNativeReservedEP8JSObject"]
            pub fn FunctionHasNativeReserved(fun: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetObjectProtoEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleIS5_EE"]
            pub fn GetObjectProto(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                proto: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18GetStaticPrototypeEP8JSObject"]
            pub fn GetStaticPrototype(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20GetRealmOriginalEvalEP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
            pub fn GetRealmOriginalEval(
                cx: *mut root::JSContext,
                eval: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Add some or all property keys of obj to the id vector *props.\n\n The flags parameter controls which property keys are added. Pass a\n combination of the following bits:\n\n     JSITER_OWNONLY - Don't also search the prototype chain; only consider\n       obj's own properties.\n\n     JSITER_HIDDEN - Include nonenumerable properties.\n\n     JSITER_SYMBOLS - Include property keys that are symbols. The default\n       behavior is to filter out symbols.\n\n     JSITER_SYMBOLSONLY - Exclude non-symbol property keys.\n\n This is the closest C++ API we have to `Reflect.ownKeys(obj)`, or\n equivalently, the ES6 [[OwnPropertyKeys]] internal method. Pass\n `JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS` as flags to get\n results that match the output of Reflect.ownKeys."]
            #[link_name = "\u{1}_ZN2js15GetPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEEjNS2_13MutableHandleINS2_13StackGCVectorINS2_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn GetPropertyKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                flags: ::std::os::raw::c_uint,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Determine whether the given string is an array index in the sense of\n <https://tc39.github.io/ecma262/#array-index>.\n\n If it isn't, returns false.\n\n If it is, returns true and outputs the index in *indexp."]
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEP14JSLinearStringPj"]
            pub fn StringIsArrayIndex(str_: *mut root::JSLinearString, indexp: *mut u32) -> bool;
        }
        extern "C" {
            #[doc = " Overload of StringIsArrayIndex taking a (char16_t*,length) pair. Behaves\n the same as the JSLinearString version."]
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEPKDsjPj"]
            pub fn StringIsArrayIndex1(str_: *const u16, length: u32, indexp: *mut u32) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27SetPreserveWrapperCallbacksEP9JSContextPFbS1_N2JS6HandleIP8JSObjectEEEPFbS6_E"]
            pub fn SetPreserveWrapperCallbacks(
                cx: *mut root::JSContext,
                preserveWrapper: root::js::PreserveWrapperCallback,
                hasReleasedWrapper: root::js::HasReleasedWrapperCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28IsObjectInContextCompartmentEP8JSObjectPK9JSContext"]
            pub fn IsObjectInContextCompartment(
                obj: *mut root::JSObject,
                cx: *const root::JSContext,
            ) -> bool;
        }
        pub type DOMInstanceClassHasProtoAtDepth = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::JSClass, arg2: u32, arg3: u32) -> bool,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct JSDOMCallbacks {
            pub instanceClassMatchesProto: root::js::DOMInstanceClassHasProtoAtDepth,
        }
        #[test]
        fn bindgen_test_layout_JSDOMCallbacks() {
            const UNINIT: ::std::mem::MaybeUninit<JSDOMCallbacks> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<JSDOMCallbacks>(),
                8usize,
                concat!("Size of: ", stringify!(JSDOMCallbacks))
            );
            assert_eq!(
                ::std::mem::align_of::<JSDOMCallbacks>(),
                8usize,
                concat!("Alignment of ", stringify!(JSDOMCallbacks))
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).instanceClassMatchesProto) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSDOMCallbacks),
                    "::",
                    stringify!(instanceClassMatchesProto)
                )
            );
        }
        pub type DOMCallbacks = root::js::JSDOMCallbacks;
        extern "C" {
            #[link_name = "\u{1}_ZN2js15SetDOMCallbacksEP9JSContextPKNS_14JSDOMCallbacksE"]
            pub fn SetDOMCallbacks(
                cx: *mut root::JSContext,
                callbacks: *const root::js::DOMCallbacks,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15GetDOMCallbacksEP9JSContext"]
            pub fn GetDOMCallbacks(cx: *mut root::JSContext) -> *const root::js::DOMCallbacks;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19GetTestingFunctionsEP9JSContext"]
            pub fn GetTestingFunctions(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get an error type name from a JSExnType constant.\n Returns nullptr for invalid arguments and JSEXN_INTERNALERR"]
            #[link_name = "\u{1}_ZN2js16GetErrorTypeNameEP9JSContexts"]
            pub fn GetErrorTypeName(
                cx: *mut root::JSContext,
                exnType: i16,
            ) -> *mut root::JSLinearString;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NukeReferencesToWindow {
            NukeWindowReferences = 0,
            DontNukeWindowReferences = 1,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NukeReferencesFromTarget {
            NukeAllReferences = 0,
            NukeIncomingReferences = 1,
        }
        #[repr(C)]
        pub struct CompartmentFilter__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CompartmentFilter {
            pub vtable_: *const CompartmentFilter__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_CompartmentFilter() {
            assert_eq!(
                ::std::mem::size_of::<CompartmentFilter>(),
                8usize,
                concat!("Size of: ", stringify!(CompartmentFilter))
            );
            assert_eq!(
                ::std::mem::align_of::<CompartmentFilter>(),
                8usize,
                concat!("Alignment of ", stringify!(CompartmentFilter))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllCompartments {
            pub _base: root::js::CompartmentFilter,
        }
        #[test]
        fn bindgen_test_layout_AllCompartments() {
            assert_eq!(
                ::std::mem::size_of::<AllCompartments>(),
                8usize,
                concat!("Size of: ", stringify!(AllCompartments))
            );
            assert_eq!(
                ::std::mem::align_of::<AllCompartments>(),
                8usize,
                concat!("Alignment of ", stringify!(AllCompartments))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SingleCompartment {
            pub _base: root::js::CompartmentFilter,
            pub ours: *mut root::JS::Compartment,
        }
        #[test]
        fn bindgen_test_layout_SingleCompartment() {
            const UNINIT: ::std::mem::MaybeUninit<SingleCompartment> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SingleCompartment>(),
                16usize,
                concat!("Size of: ", stringify!(SingleCompartment))
            );
            assert_eq!(
                ::std::mem::align_of::<SingleCompartment>(),
                8usize,
                concat!("Alignment of ", stringify!(SingleCompartment))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ours) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SingleCompartment),
                    "::",
                    stringify!(ours)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28NukeCrossCompartmentWrappersEP9JSContextRKNS_17CompartmentFilterEPN2JS5RealmENS_22NukeReferencesToWindowENS_24NukeReferencesFromTargetE"]
            pub fn NukeCrossCompartmentWrappers(
                cx: *mut root::JSContext,
                sourceFilter: *const root::js::CompartmentFilter,
                target: *mut root::JS::Realm,
                nukeReferencesToWindow: root::js::NukeReferencesToWindow,
                nukeReferencesFromTarget: root::js::NukeReferencesFromTarget,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15AllowNewWrapperEPN2JS11CompartmentEP8JSObject"]
            pub fn AllowNewWrapper(
                target: *mut root::JS::Compartment,
                obj: *mut root::JSObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16NukedObjectRealmEP8JSObject"]
            pub fn NukedObjectRealm(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Detect whether the internal date value is NaN."]
            #[link_name = "\u{1}_ZN2js11DateIsValidEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn DateIsValid(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isValid: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21DateGetMsecSinceEpochEP9JSContextN2JS6HandleIP8JSObjectEEPd"]
            pub fn DateGetMsecSinceEpoch(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                msecSinceEpoch: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11GetSCOffsetEP23JSStructuredCloneWriter"]
            pub fn GetSCOffset(writer: *mut root::JSStructuredCloneWriter) -> u64;
        }
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " PrepareScriptEnvironmentAndInvoke asserts the embedder has registered a\n ScriptEnvironmentPreparer and then it calls the preparer's 'invoke' method\n with the given |closure|, with the assumption that the preparer will set up\n any state necessary to run script in |global|, invoke |closure| with a valid\n JSContext*, report any exceptions thrown from the closure, and return.\n\n PrepareScriptEnvironmentAndInvoke will report any exceptions that are thrown\n by the closure.  Consumers who want to propagate back whether the closure\n succeeded should do so via members of the closure itself."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptEnvironmentPreparer {
            pub vtable_: *const ScriptEnvironmentPreparer__bindgen_vtable,
        }
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer_Closure__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptEnvironmentPreparer_Closure {
            pub vtable_: *const ScriptEnvironmentPreparer_Closure__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ScriptEnvironmentPreparer_Closure() {
            assert_eq!(
                ::std::mem::size_of::<ScriptEnvironmentPreparer_Closure>(),
                8usize,
                concat!("Size of: ", stringify!(ScriptEnvironmentPreparer_Closure))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptEnvironmentPreparer_Closure>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ScriptEnvironmentPreparer_Closure)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_ScriptEnvironmentPreparer() {
            assert_eq!(
                ::std::mem::size_of::<ScriptEnvironmentPreparer>(),
                8usize,
                concat!("Size of: ", stringify!(ScriptEnvironmentPreparer))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptEnvironmentPreparer>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptEnvironmentPreparer))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js33PrepareScriptEnvironmentAndInvokeEP9JSContextN2JS6HandleIP8JSObjectEERNS_25ScriptEnvironmentPreparer7ClosureE"]
            pub fn PrepareScriptEnvironmentAndInvoke(
                cx: *mut root::JSContext,
                global: root::JS::HandleObject,
                closure: *mut root::js::ScriptEnvironmentPreparer_Closure,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28SetScriptEnvironmentPreparerEP9JSContextPNS_25ScriptEnvironmentPreparerE"]
            pub fn SetScriptEnvironmentPreparer(
                cx: *mut root::JSContext,
                preparer: *mut root::js::ScriptEnvironmentPreparer,
            );
        }
        #[repr(C)]
        pub struct AllocationMetadataBuilder__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocationMetadataBuilder {
            pub vtable_: *const AllocationMetadataBuilder__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_AllocationMetadataBuilder() {
            assert_eq!(
                ::std::mem::size_of::<AllocationMetadataBuilder>(),
                8usize,
                concat!("Size of: ", stringify!(AllocationMetadataBuilder))
            );
            assert_eq!(
                ::std::mem::align_of::<AllocationMetadataBuilder>(),
                8usize,
                concat!("Alignment of ", stringify!(AllocationMetadataBuilder))
            );
        }
        extern "C" {
            #[doc = " Specify a callback to invoke when creating each JS object in the current\n compartment, which may return a metadata object to associate with the\n object."]
            #[link_name = "\u{1}_ZN2js28SetAllocationMetadataBuilderEP9JSContextPKNS_25AllocationMetadataBuilderE"]
            pub fn SetAllocationMetadataBuilder(
                cx: *mut root::JSContext,
                callback: *const root::js::AllocationMetadataBuilder,
            );
        }
        extern "C" {
            #[doc = " Get the metadata associated with an object."]
            #[link_name = "\u{1}_ZN2js21GetAllocationMetadataEP8JSObject"]
            pub fn GetAllocationMetadata(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20GetElementsWithAdderEP9JSContextN2JS6HandleIP8JSObjectEES6_jjPNS_12ElementAdderE"]
            pub fn GetElementsWithAdder(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15ForwardToNativeEP9JSContextPFbS1_jPN2JS5ValueEERKNS2_8CallArgsE"]
            pub fn ForwardToNative(
                cx: *mut root::JSContext,
                native: root::JSNative,
                args: *const root::JS::CallArgs,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31ExecuteInFrameScriptEnvironmentEP9JSContextN2JS6HandleIP8JSObjectEENS3_IP8JSScriptEENS2_13MutableHandleIS5_EE"]
            pub fn ExecuteInFrameScriptEnvironment(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                script: root::JS::HandleScript,
                scope: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12IsSavedFrameEP8JSObject"]
            pub fn IsSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19ReportIsNotFunctionEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ReportIsNotFunction(cx: *mut root::JSContext, v: root::JS::HandleValue) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoAssertNoContentJS {
            pub context_: *mut root::JSContext,
            pub prevAllowContentJS_: bool,
        }
        #[test]
        fn bindgen_test_layout_AutoAssertNoContentJS() {
            const UNINIT: ::std::mem::MaybeUninit<AutoAssertNoContentJS> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoAssertNoContentJS>(),
                16usize,
                concat!("Size of: ", stringify!(AutoAssertNoContentJS))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoAssertNoContentJS>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoAssertNoContentJS))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).context_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoAssertNoContentJS),
                    "::",
                    stringify!(context_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).prevAllowContentJS_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoAssertNoContentJS),
                    "::",
                    stringify!(prevAllowContentJS_)
                )
            );
        }
        extern "C" {
            #[doc = " This function only reports GC heap memory,\n and not malloc allocated memory associated with GC things."]
            #[link_name = "\u{1}_ZN2js27GetGCHeapUsageForObjectZoneEP8JSObject"]
            pub fn GetGCHeapUsageForObjectZone(obj: *mut root::JSObject) -> u64;
        }
        #[repr(C)]
        pub struct CompartmentTransplantCallback__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CompartmentTransplantCallback {
            pub vtable_: *const CompartmentTransplantCallback__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_CompartmentTransplantCallback() {
            assert_eq!(
                ::std::mem::size_of::<CompartmentTransplantCallback>(),
                8usize,
                concat!("Size of: ", stringify!(CompartmentTransplantCallback))
            );
            assert_eq!(
                ::std::mem::align_of::<CompartmentTransplantCallback>(),
                8usize,
                concat!("Alignment of ", stringify!(CompartmentTransplantCallback))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24RemapRemoteWindowProxiesEP9JSContextPNS_29CompartmentTransplantCallbackEN2JS13MutableHandleIP8JSObjectEE"]
            pub fn RemapRemoteWindowProxies(
                cx: *mut root::JSContext,
                callback: *mut root::js::CompartmentTransplantCallback,
                newTarget: root::JS::MutableHandleObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26GetObjectZoneFromAnyThreadEPK8JSObject"]
            pub fn GetObjectZoneFromAnyThread(obj: *const root::JSObject) -> *mut root::JS::Zone;
        }
    }
    pub type jsbytecode = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtom {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunction {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSObject {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSRuntime {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSScript {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSString {
        _unused: [u8; 0],
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type Heap<T> = crate::jsgc::Heap<T>;
        pub type Rooted<T> = crate::jsgc::Rooted<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCContext {
            _unused: [u8; 0],
        }
        pub type Latin1Char = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Symbol {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BigInt {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Compartment {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Realm {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Runtime {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Zone {
            _unused: [u8; 0],
        }
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleFunction = root::JS::Handle<*mut root::JSFunction>;
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleId = root::JS::Handle<root::JS::PropertyKey>;
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleObject = root::JS::Handle<*mut root::JSObject>;
        pub type HandleScript = root::JS::Handle<*mut root::JSScript>;
        pub type HandleString = root::JS::Handle<*mut root::JSString>;
        pub type HandleSymbol = root::JS::Handle<*mut root::JS::Symbol>;
        pub type HandleBigInt = root::JS::Handle<*mut root::JS::BigInt>;
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleValue = root::JS::Handle<root::JS::Value>;
        pub type HandleValueVector = u8;
        pub type HandleIdVector = u8;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleFunction = root::JS::MutableHandle<*mut root::JSFunction>;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleId = root::JS::MutableHandle<root::JS::PropertyKey>;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleObject = root::JS::MutableHandle<*mut root::JSObject>;
        pub type MutableHandleScript = root::JS::MutableHandle<*mut root::JSScript>;
        pub type MutableHandleString = root::JS::MutableHandle<*mut root::JSString>;
        pub type MutableHandleSymbol = root::JS::MutableHandle<*mut root::JS::Symbol>;
        pub type MutableHandleBigInt = root::JS::MutableHandle<*mut root::JS::BigInt>;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleValue = root::JS::MutableHandle<root::JS::Value>;
        pub type MutableHandleValueVector = u8;
        #[doc = " Local variable of type T whose value is always rooted. This is typically\n used for local variables, or for non-rooted values being passed to a\n function that requires a handle, e.g. Foo(Root<T>(cx, x)).\n\n If you want to add additional methods to Rooted for a specific\n specialization, define a RootedOperations<T> specialization containing them."]
        pub type RootedObject = root::JS::Rooted<*mut root::JSObject>;
        pub type RootedFunction = root::JS::Rooted<*mut root::JSFunction>;
        pub type RootedScript = root::JS::Rooted<*mut root::JSScript>;
        pub type RootedString = root::JS::Rooted<*mut root::JSString>;
        pub type RootedSymbol = root::JS::Rooted<*mut root::JS::Symbol>;
        pub type RootedBigInt = root::JS::Rooted<*mut root::JS::BigInt>;
        pub type RootedId = root::JS::Rooted<root::JS::PropertyKey>;
        #[doc = " Local variable of type T whose value is always rooted. This is typically\n used for local variables, or for non-rooted values being passed to a\n function that requires a handle, e.g. Foo(Root<T>(cx, x)).\n\n If you want to add additional methods to Rooted for a specific\n specialization, define a RootedOperations<T> specialization containing them."]
        pub type RootedValue = root::JS::Rooted<root::JS::Value>;
        pub type PersistentRootedFunction = u8;
        pub type PersistentRootedId = u8;
        #[doc = " A copyable, assignable global GC root type with arbitrary lifetime, an\n infallible constructor, and automatic unrooting on destruction.\n\n These roots can be used in heap-allocated data structures, so they are not\n associated with any particular JSContext or stack. They are registered with\n the JSRuntime itself, without locking. Initialization may take place on\n construction, or in two phases if the no-argument constructor is called\n followed by init().\n\n Note that you must not use an PersistentRooted in an object owned by a JS\n object:\n\n Whenever one object whose lifetime is decided by the GC refers to another\n such object, that edge must be traced only if the owning JS object is traced.\n This applies not only to JS objects (which obviously are managed by the GC)\n but also to C++ objects owned by JS objects.\n\n If you put a PersistentRooted in such a C++ object, that is almost certainly\n a leak. When a GC begins, the referent of the PersistentRooted is treated as\n live, unconditionally (because a PersistentRooted is a *root*), even if the\n JS object that owns it is unreachable. If there is any path from that\n referent back to the JS object, then the C++ object containing the\n PersistentRooted will not be destructed, and the whole blob of objects will\n not be freed, even if there are no references to them from the outside.\n\n In the context of Firefox, this is a severe restriction: almost everything in\n Firefox is owned by some JS object or another, so using PersistentRooted in\n such objects would introduce leaks. For these kinds of edges, Heap<T> or\n TenuredHeap<T> would be better types. It's up to the implementor of the type\n containing Heap<T> or TenuredHeap<T> members to make sure their referents get\n marked when the object itself is marked."]
        pub type PersistentRootedObject = [u64; 4usize];
        pub type PersistentRootedScript = u8;
        pub type PersistentRootedString = u8;
        pub type PersistentRootedSymbol = u8;
        pub type PersistentRootedBigInt = u8;
        pub type PersistentRootedValue = u8;
        pub type PersistentRootedIdVector = u8;
        pub type PersistentRootedObjectVector = u8;
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given byte length."]
            #[link_name = "\u{1}_ZN2JS14NewArrayBufferEP9JSContextm"]
            pub fn NewArrayBuffer(cx: *mut root::JSContext, nbytes: usize) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given |contents|, which may be null only\n if |nbytes == 0|.  |contents| must be allocated compatible with deallocation\n by |JS_free|.\n\n If and only if an ArrayBuffer is successfully created and returned,\n ownership of |contents| is transferred to the new ArrayBuffer.\n\n Care must be taken that |nbytes| bytes of |content| remain valid for the\n duration of this call.  In particular, passing the length/pointer of existing\n typed array or ArrayBuffer data is generally unsafe: if a GC occurs during a\n call to this function, it could move those contents to a different location\n and invalidate the provided pointer."]
            #[link_name = "\u{1}_ZN2JS26NewArrayBufferWithContentsEP9JSContextmPv"]
            pub fn NewArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer, whose bytes are set to the values of the bytes in\n the provided ArrayBuffer.\n\n |maybeArrayBuffer| is asserted to be non-null.  An error is thrown if\n |maybeArrayBuffer| would fail the |IsArrayBufferObject| test given further\n below or if |maybeArrayBuffer| is detached.\n\n |maybeArrayBuffer| may store its contents in any fashion (i.e. it doesn't\n matter whether |maybeArrayBuffer| was allocated using |JS::NewArrayBuffer|,\n |JS::NewExternalArrayBuffer|, or any other ArrayBuffer-allocating function).\n\n The newly-created ArrayBuffer is effectively creatd as if by\n |JS::NewArrayBufferWithContents| passing in |maybeArrayBuffer|'s internal\n data pointer and length, in a manner safe against |maybeArrayBuffer|'s data\n being moved around by the GC.  In particular, the new ArrayBuffer will not\n behave like one created for WASM or asm.js, so it *can* be detached."]
            #[link_name = "\u{1}_ZN2JS15CopyArrayBufferEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn CopyArrayBuffer(
                cx: *mut root::JSContext,
                maybeArrayBuffer: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        pub type BufferContentsFreeFunc = ::std::option::Option<
            unsafe extern "C" fn(
                contents: *mut ::std::os::raw::c_void,
                userData: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given contents. The contents must not be\n modified by any other code, internal or external.\n\n When the ArrayBuffer is ready to be disposed of, `freeFunc(contents,\n freeUserData)` will be called to release the ArrayBuffer's reference on the\n contents.\n\n `freeFunc()` must not call any JSAPI functions that could cause a garbage\n collection.\n\n The caller must keep the buffer alive until `freeFunc()` is called, or, if\n `freeFunc` is null, until the JSRuntime is destroyed.\n\n The caller must not access the buffer on other threads. The JS engine will\n not allow the buffer to be transferred to other threads. If you try to\n transfer an external ArrayBuffer to another thread, the data is copied to a\n new malloc buffer. `freeFunc()` must be threadsafe, and may be called from\n any thread.\n\n This allows ArrayBuffers to be used with embedder objects that use reference\n counting, for example. In that case the caller is responsible\n for incrementing the reference count before passing the contents to this\n function. This also allows using non-reference-counted contents that must be\n freed with some function other than free()."]
            #[link_name = "\u{1}_ZN2JS22NewExternalArrayBufferEP9JSContextmPvPFvS2_S2_ES2_"]
            pub fn NewExternalArrayBuffer(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
                freeFunc: root::JS::BufferContentsFreeFunc,
                freeUserData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given non-null |contents|.\n\n Ownership of |contents| remains with the caller: it isn't transferred to the\n returned ArrayBuffer.  Callers of this function *must* ensure that they\n perform these two steps, in this order, to properly relinquish ownership of\n |contents|:\n\n   1. Call |JS::DetachArrayBuffer| on the buffer returned by this function.\n      (|JS::DetachArrayBuffer| is generally fallible, but a call under these\n      circumstances is guaranteed to succeed.)\n   2. |contents| may be deallocated or discarded consistent with the manner\n      in which it was allocated.\n\n Do not simply allow the returned buffer to be garbage-collected before\n deallocating |contents|, because in general there is no way to know *when*\n an object is fully garbage-collected to the point where this would be safe."]
            #[link_name = "\u{1}_ZN2JS35NewArrayBufferWithUserOwnedContentsEP9JSContextmPv"]
            pub fn NewArrayBufferWithUserOwnedContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new mapped ArrayBuffer with the given memory mapped contents. It\n must be legal to free the contents pointer by unmapping it. On success,\n ownership is transferred to the new mapped ArrayBuffer."]
            #[link_name = "\u{1}_ZN2JS32NewMappedArrayBufferWithContentsEP9JSContextmPv"]
            pub fn NewMappedArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create memory mapped ArrayBuffer contents.\n Caller must take care of closing fd after calling this function."]
            #[link_name = "\u{1}_ZN2JS31CreateMappedArrayBufferContentsEimm"]
            pub fn CreateMappedArrayBufferContents(
                fd: ::std::os::raw::c_int,
                offset: usize,
                length: usize,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Release the allocated resource of mapped ArrayBuffer contents before the\n object is created.\n If a new object has been created by JS::NewMappedArrayBufferWithContents()\n with this content, then JS::DetachArrayBuffer() should be used instead to\n release the resource used by the object."]
            #[link_name = "\u{1}_ZN2JS32ReleaseMappedArrayBufferContentsEPvm"]
            pub fn ReleaseMappedArrayBufferContents(
                contents: *mut ::std::os::raw::c_void,
                length: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19IsArrayBufferObjectEP8JSObject"]
            pub fn IsArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Check whether the obj is a detached ArrayBufferObject. Note that this may\n return false if a security wrapper is encountered that denies the\n unwrapping."]
            #[link_name = "\u{1}_ZN2JS27IsDetachedArrayBufferObjectEP8JSObject"]
            pub fn IsDetachedArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Check whether the obj is ArrayBufferObject and memory mapped. Note that this\n may return false if a security wrapper is encountered that denies the\n unwrapping."]
            #[link_name = "\u{1}_ZN2JS25IsMappedArrayBufferObjectEP8JSObject"]
            pub fn IsMappedArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true if the ArrayBuffer |obj| contains any data, i.e. it is not a\n detached ArrayBuffer.  (ArrayBuffer.prototype is not an ArrayBuffer.)\n\n |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known\n that it would pass such a test: it is an ArrayBuffer or a wrapper of an\n ArrayBuffer, and the unwrapping will succeed."]
            #[link_name = "\u{1}_ZN2JS18ArrayBufferHasDataEP8JSObject"]
            pub fn ArrayBufferHasData(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17UnwrapArrayBufferEP8JSObject"]
            pub fn UnwrapArrayBuffer(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Attempt to unwrap |obj| as an ArrayBuffer.\n\n If |obj| *is* an ArrayBuffer, return it unwrapped and set |*length| and\n |*data| to weakly refer to the ArrayBuffer's contents.\n\n If |obj| isn't an ArrayBuffer, return nullptr and do not modify |*length| or\n |*data|."]
            #[link_name = "\u{1}_ZN2JS22GetObjectAsArrayBufferEP8JSObjectPmPPh"]
            pub fn GetObjectAsArrayBuffer(
                obj: *mut root::JSObject,
                length: *mut usize,
                data: *mut *mut u8,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Return the available byte length of an ArrayBuffer.\n\n |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known\n that it would pass such a test: it is an ArrayBuffer or a wrapper of an\n ArrayBuffer, and the unwrapping will succeed."]
            #[link_name = "\u{1}_ZN2JS24GetArrayBufferByteLengthEP8JSObject"]
            pub fn GetArrayBufferByteLength(obj: *mut root::JSObject) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetArrayBufferLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        extern "C" {
            #[doc = " Return a pointer to the start of the data referenced by a typed array. The\n data is still owned by the typed array, and should not be modified on\n another thread. Furthermore, the pointer can become invalid on GC (if the\n data is small and fits inside the array's GC header), so callers must take\n care not to hold on across anything that could GC.\n\n |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known\n that it would pass such a test: it is an ArrayBuffer or a wrapper of an\n ArrayBuffer, and the unwrapping will succeed.\n\n |*isSharedMemory| is always set to false.  The argument is present to\n simplify its use from code that also interacts with SharedArrayBuffer."]
            #[link_name = "\u{1}_ZN2JS18GetArrayBufferDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetArrayBufferData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
        }
        extern "C" {
            #[doc = " Detach an ArrayBuffer, causing all associated views to no longer refer to\n the ArrayBuffer's original attached memory.\n\n This function throws only if it is provided a non-ArrayBuffer object or if\n the provided ArrayBuffer is a WASM-backed ArrayBuffer or an ArrayBuffer used\n in asm.js code."]
            #[link_name = "\u{1}_ZN2JS17DetachArrayBufferEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn DetachArrayBuffer(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30HasDefinedArrayBufferDetachKeyEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn HasDefinedArrayBufferDetachKey(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isDefined: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Steal the contents of the given ArrayBuffer. The ArrayBuffer has its length\n set to 0 and its contents array cleared. The caller takes ownership of the\n return value and must free it or transfer ownership via\n JS::NewArrayBufferWithContents when done using it."]
            #[link_name = "\u{1}_ZN2JS24StealArrayBufferContentsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn StealArrayBufferContents(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Enable or disable support for large (>= 2 GB) ArrayBuffers on 64-bit builds.\n Has no effect on 32-bit builds."]
            #[link_name = "\u{1}_ZN2JS27SetLargeArrayBuffersEnabledEb"]
            pub fn SetLargeArrayBuffersEnabled(enable: bool);
        }
        extern "C" {
            #[doc = " Copy data from one array buffer to another.\n\n Both fromBuffer and toBuffer must be (possibly wrapped)\n ArrayBufferObjectMaybeShared.\n\n This method may throw if the sizes don't match, or if unwrapping fails.\n\n The API for this is modelled on CopyDataBlockBytes from the spec:\n https://tc39.es/ecma262/#sec-copydatablockbytes"]
            #[link_name = "\u{1}_ZN2JS19ArrayBufferCopyDataEP9JSContextNS_6HandleIP8JSObjectEEmS5_mm"]
            pub fn ArrayBufferCopyData(
                cx: *mut root::JSContext,
                toBlock: root::JS::Handle<*mut root::JSObject>,
                toIndex: usize,
                fromBlock: root::JS::Handle<*mut root::JSObject>,
                fromIndex: usize,
                count: usize,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Copy data from one array buffer to another.\n\n srcBuffer must be a (possibly wrapped) ArrayBufferObjectMaybeShared.\n\n This method may throw if unwrapping or allocation fails.\n\n The API for this is modelled on CloneArrayBuffer from the spec:\n https://tc39.es/ecma262/#sec-clonearraybuffer"]
            #[link_name = "\u{1}_ZN2JS16ArrayBufferCloneEP9JSContextNS_6HandleIP8JSObjectEEmm"]
            pub fn ArrayBufferClone(
                cx: *mut root::JSContext,
                srcBuffer: root::JS::Handle<*mut root::JSObject>,
                srcByteOffset: usize,
                srcLength: usize,
            ) -> *mut root::JSObject;
        }
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type Int64Limits = root::std::numeric_limits;
            pub type Uint64Limits = root::std::numeric_limits;
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail15BigIntFromInt64EP9JSContextl"]
                pub fn BigIntFromInt64(cx: *mut root::JSContext, num: i64)
                    -> *mut root::JS::BigInt;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail16BigIntFromUint64EP9JSContextm"]
                pub fn BigIntFromUint64(
                    cx: *mut root::JSContext,
                    num: u64,
                ) -> *mut root::JS::BigInt;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail14BigIntFromBoolEP9JSContextb"]
                pub fn BigIntFromBool(cx: *mut root::JSContext, b: bool) -> *mut root::JS::BigInt;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NumberToBigIntConverter {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_NumberToBigIntConverter_open0_bool__void_close0_instantiation()
            {
                assert_eq!(
                    ::std::mem::size_of::<root::JS::detail::NumberToBigIntConverter>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::JS::detail::NumberToBigIntConverter)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::JS::detail::NumberToBigIntConverter>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::JS::detail::NumberToBigIntConverter)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail13BigIntIsInt64EPNS_6BigIntEPl"]
                pub fn BigIntIsInt64(bi: *mut root::JS::BigInt, result: *mut i64) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail14BigIntIsUint64EPNS_6BigIntEPm"]
                pub fn BigIntIsUint64(bi: *mut root::JS::BigInt, result: *mut u64) -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BigIntToNumberChecker {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DefineComparisonOps {
                pub _base: root::std::false_type,
            }
            pub type RootedTraits = root::std::conditional_t;
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum InitState {
                Uninitialized = 0,
                Initializing = 1,
                Running = 2,
                ShutDown = 3,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail25InitWithFailureDiagnosticEb"]
                pub fn InitWithFailureDiagnostic(
                    isDebugBuild: bool,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail11ComputeThisEP9JSContextPNS_5ValueENS_13MutableHandleIP8JSObjectEE"]
                pub fn ComputeThis(
                    cx: *mut root::JSContext,
                    vp: *mut root::JS::Value,
                    thisObject: root::JS::MutableHandleObject,
                ) -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IncludeUsedRval {
                pub usedRval_: bool,
            }
            #[test]
            fn bindgen_test_layout_IncludeUsedRval() {
                const UNINIT: ::std::mem::MaybeUninit<IncludeUsedRval> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<IncludeUsedRval>(),
                    1usize,
                    concat!("Size of: ", stringify!(IncludeUsedRval))
                );
                assert_eq!(
                    ::std::mem::align_of::<IncludeUsedRval>(),
                    1usize,
                    concat!("Alignment of ", stringify!(IncludeUsedRval))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).usedRval_) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(IncludeUsedRval),
                        "::",
                        stringify!(usedRval_)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NoUsedRval {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_NoUsedRval() {
                assert_eq!(
                    ::std::mem::size_of::<NoUsedRval>(),
                    1usize,
                    concat!("Size of: ", stringify!(NoUsedRval))
                );
                assert_eq!(
                    ::std::mem::align_of::<NoUsedRval>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NoUsedRval))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CallArgsBase {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail26SetReservedSlotWithBarrierEP8JSObjectmRKNS_5ValueE"]
                pub fn SetReservedSlotWithBarrier(
                    obj: *mut root::JSObject,
                    slot: usize,
                    value: *const root::JS::Value,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail19CallMethodIfWrappedEP9JSContextPFbNS_6HandleINS_5ValueEEEEPFbS2_RKNS_8CallArgsEESA_"]
                pub fn CallMethodIfWrapped(
                    cx: *mut root::JSContext,
                    test: root::JS::IsAcceptableThis,
                    impl_: root::JS::NativeImpl,
                    args: *const root::JS::CallArgs,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail19ReportSourceTooLongEP9JSContext"]
                pub fn ReportSourceTooLong(cx: *mut root::JSContext);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail24StringToLinearStringSlowEP9JSContextP8JSString"]
                pub fn StringToLinearStringSlow(
                    cx: *mut root::JSContext,
                    str_: *mut root::JSString,
                ) -> *mut root::JSLinearString;
            }
            pub type ExternalTypeOf_t = u8;
        }
        extern "C" {
            #[doc = " Create a BigInt from a floating-point value. If the number isn't integral\n (that is, if it's NaN, an infinity, or contains a fractional component),\n this function returns null and throws an exception.\n\n Passing -0.0 will produce the bigint 0n."]
            #[link_name = "\u{1}_ZN2JS14NumberToBigIntEP9JSContextd"]
            pub fn NumberToBigInt(cx: *mut root::JSContext, num: f64) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Create a BigInt by parsing a string using the ECMAScript StringToBigInt\n algorithm (https://tc39.es/ecma262/#sec-stringtobigint). Latin1 and two-byte\n character ranges are supported. It may be convenient to use\n JS::ConstLatin1Chars or JS::ConstTwoByteChars.\n\n (StringToBigInt performs parsing similar to that performed by the |Number|\n global function when passed a string, but it doesn't allow infinities,\n decimal points, or exponential notation, and neither algorithm allows numeric\n separators or an 'n' suffix character. This fast-and-loose description is\n offered purely as a convenience to the reader: see the specification\n algorithm for exact behavior.)\n\n If parsing fails, this function returns null and throws an exception."]
            #[link_name = "\u{1}_ZN2JS14StringToBigIntEP9JSContextN7mozilla5RangeIKhEE"]
            pub fn StringToBigInt(
                cx: *mut root::JSContext,
                chars: root::mozilla::Range<root::JS::Latin1Char>,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14StringToBigIntEP9JSContextN7mozilla5RangeIKDsEE"]
            pub fn StringToBigInt1(
                cx: *mut root::JSContext,
                chars: root::mozilla::Range<u16>,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Create a BigInt by parsing a string consisting of an optional sign character\n followed by one or more alphanumeric ASCII digits in the provided radix.\n\n If the radix is not in the range [2, 36], or the string fails to parse, this\n function returns null and throws an exception."]
            #[link_name = "\u{1}_ZN2JS20SimpleStringToBigIntEP9JSContextN7mozilla4SpanIKcLm18446744073709551615EEEh"]
            pub fn SimpleStringToBigInt(
                cx: *mut root::JSContext,
                chars: [u32; 2usize],
                radix: u8,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Convert a JS::Value to a BigInt using the ECMAScript ToBigInt algorithm\n (https://tc39.es/ecma262/#sec-tobigint).\n\n (Note in particular that this will throw if passed a value whose type is\n 'number'. To convert a number to a BigInt, use one of the overloads of\n JS::NumberToBigInt().)"]
            #[link_name = "\u{1}_ZN2JS8ToBigIntEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn ToBigInt(
                cx: *mut root::JSContext,
                val: root::JS::Handle<root::JS::Value>,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Convert the given BigInt, modulo 2**64, to a signed 64-bit integer."]
            #[link_name = "\u{1}_ZN2JS10ToBigInt64EPNS_6BigIntE"]
            pub fn ToBigInt64(bi: *mut root::JS::BigInt) -> i64;
        }
        extern "C" {
            #[doc = " Convert the given BigInt, modulo 2**64, to an unsigned 64-bit integer."]
            #[link_name = "\u{1}_ZN2JS11ToBigUint64EPNS_6BigIntE"]
            pub fn ToBigUint64(bi: *mut root::JS::BigInt) -> u64;
        }
        extern "C" {
            #[doc = " Convert the given BigInt to a Number value as if calling the Number\n constructor on it\n (https://tc39.es/ecma262/#sec-number-constructor-number-value). The value\n may be rounded if it doesn't fit without loss of precision."]
            #[link_name = "\u{1}_ZN2JS14BigIntToNumberEPNS_6BigIntE"]
            pub fn BigIntToNumber(bi: *mut root::JS::BigInt) -> f64;
        }
        extern "C" {
            #[doc = " Return true if the given BigInt is negative."]
            #[link_name = "\u{1}_ZN2JS16BigIntIsNegativeEPNS_6BigIntE"]
            pub fn BigIntIsNegative(bi: *mut root::JS::BigInt) -> bool;
        }
        extern "C" {
            #[doc = " Same as BigIntFits(), but checks if the value fits inside a JS Number value."]
            #[link_name = "\u{1}_ZN2JS16BigIntFitsNumberEPNS_6BigIntEPd"]
            pub fn BigIntFitsNumber(bi: *mut root::JS::BigInt, out: *mut f64) -> bool;
        }
        extern "C" {
            #[doc = " Convert the given BigInt to a String value as if toString() were called on\n it.\n\n If the radix is not in the range [2, 36], then this function returns null and\n throws an exception."]
            #[link_name = "\u{1}_ZN2JS14BigIntToStringEP9JSContextNS_6HandleIPNS_6BigIntEEEh"]
            pub fn BigIntToString(
                cx: *mut root::JSContext,
                bi: root::JS::Handle<*mut root::JS::BigInt>,
                radix: u8,
            ) -> *mut root::JSString;
        }
        #[doc = " Vector of characters used for holding build ids."]
        pub type BuildIdCharVector = u8;
        #[doc = " Return the buildId (represented as a sequence of characters) associated with\n the currently-executing build. If the JS engine is embedded such that a\n single cache entry can be observed by different compiled versions of the JS\n engine, it is critical that the buildId shall change for each new build of\n the JS engine."]
        pub type BuildIdOp = ::std::option::Option<
            unsafe extern "C" fn(buildId: *mut root::JS::BuildIdCharVector) -> bool,
        >;
        extern "C" {
            #[doc = " Embedder hook to set the buildId-generating function."]
            #[link_name = "\u{1}_ZN2JS19SetProcessBuildIdOpEPFbPN7mozilla6VectorIcLm0EN2js17SystemAllocPolicyEEEE"]
            pub fn SetProcessBuildIdOp(buildIdOp: root::JS::BuildIdOp);
        }
        #[doc = " Type representing a JS error or exception. At the moment this only\n \"represents\" an error in a rather abstract way."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Error {
            pub kind: root::JS::Error_ErrorKind,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Error_ErrorKind {
            Unspecified = 2,
            OOM = 4,
        }
        #[test]
        fn bindgen_test_layout_Error() {
            const UNINIT: ::std::mem::MaybeUninit<Error> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Error>(),
                8usize,
                concat!("Size of: ", stringify!(Error))
            );
            assert_eq!(
                ::std::mem::align_of::<Error>(),
                8usize,
                concat!("Alignment of ", stringify!(Error))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Error),
                    "::",
                    stringify!(kind)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OOM {
            pub _base: root::JS::Error,
        }
        #[test]
        fn bindgen_test_layout_OOM() {
            assert_eq!(
                ::std::mem::size_of::<OOM>(),
                8usize,
                concat!("Size of: ", stringify!(OOM))
            );
            assert_eq!(
                ::std::mem::align_of::<OOM>(),
                8usize,
                concat!("Alignment of ", stringify!(OOM))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UnusedZero {
            pub _address: u8,
        }
        pub type UnusedZero_StorageType = root::std::underlying_type_t;
        #[doc = " `Result` is intended to be the return type of JSAPI calls and internal\n functions that can run JS code or allocate memory from the JS GC heap. Such\n functions can:\n\n -   succeed, possibly returning a value;\n\n -   fail with a JS exception (out-of-memory falls in this category); or\n\n -   fail because JS execution was terminated, which occurs when e.g. a\n     user kills a script from the \"slow script\" UI. This is also how we\n     unwind the stack when the debugger forces the current function to\n     return. JS `catch` blocks can't catch this kind of failure,\n     and JS `finally` blocks don't execute."]
        pub type Result = root::mozilla::Result;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TraceKind {
            Object = 0,
            BigInt = 1,
            String = 2,
            Symbol = 3,
            Shape = 4,
            BaseShape = 5,
            Null = 6,
            JitCode = 7,
            Script = 8,
            Scope = 9,
            RegExpShared = 10,
            GetterSetter = 11,
            PropMap = 12,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MapTypeToTraceKind {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsBaseTraceType {
            pub _base: root::std::false_type,
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_BaseShape_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_JitCode_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_Scope_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_JSObject_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_BaseScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_Shape_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_JSString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_Symbol_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_BigInt_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_RegExpShared_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_GetterSetter_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsBaseTraceType_open0_PropMap_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::IsBaseTraceType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::IsBaseTraceType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_BaseShape_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JitCode_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_Scope_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSObject_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_BaseScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_Shape_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_Symbol_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_BigInt_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_RegExpShared_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_GetterSetter_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_PropMap_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSLinearString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSFunction_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[repr(i8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RootKind {
            BaseShape = 0,
            JitCode = 1,
            Scope = 2,
            Object = 3,
            Script = 4,
            Shape = 5,
            String = 6,
            Symbol = 7,
            BigInt = 8,
            RegExpShared = 9,
            GetterSetter = 10,
            PropMap = 11,
            Id = 12,
            Value = 13,
            Traceable = 14,
            Limit = 15,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MapTypeToRootKind {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_ptr_Realm_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_Value_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_PropertyKey_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoEnterCycleCollection {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoEnterCycleCollection() {
            assert_eq!(
                ::std::mem::size_of::<AutoEnterCycleCollection>(),
                1usize,
                concat!("Size of: ", stringify!(AutoEnterCycleCollection))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoEnterCycleCollection>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoEnterCycleCollection))
            );
        }
        pub mod shadow {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct String {
                pub flags_: usize,
                pub __bindgen_anon_1: root::JS::shadow::String__bindgen_ty_1,
                pub externalCallbacks: *const root::JSExternalStringCallbacks,
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub union String__bindgen_ty_1 {
                pub nonInlineCharsLatin1: *const root::JS::Latin1Char,
                pub nonInlineCharsTwoByte: *const u16,
                pub inlineStorageLatin1: [root::JS::Latin1Char; 1usize],
                pub inlineStorageTwoByte: [u16; 1usize],
            }
            #[test]
            fn bindgen_test_layout_String__bindgen_ty_1() {
                const UNINIT: ::std::mem::MaybeUninit<String__bindgen_ty_1> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<String__bindgen_ty_1>(),
                    8usize,
                    concat!("Size of: ", stringify!(String__bindgen_ty_1))
                );
                assert_eq!(
                    ::std::mem::align_of::<String__bindgen_ty_1>(),
                    8usize,
                    concat!("Alignment of ", stringify!(String__bindgen_ty_1))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).nonInlineCharsLatin1) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(nonInlineCharsLatin1)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).nonInlineCharsTwoByte) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(nonInlineCharsTwoByte)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).inlineStorageLatin1) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(inlineStorageLatin1)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).inlineStorageTwoByte) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(inlineStorageTwoByte)
                    )
                );
            }
            pub const String_ATOM_BIT: u32 = 8;
            pub const String_LINEAR_BIT: u32 = 16;
            pub const String_INLINE_CHARS_BIT: u32 = 64;
            pub const String_LATIN1_CHARS_BIT: u32 = 512;
            pub const String_EXTERNAL_FLAGS: u32 = 272;
            pub const String_TYPE_FLAGS_MASK: u32 = 504;
            pub const String_PERMANENT_ATOM_MASK: u32 = 264;
            #[test]
            fn bindgen_test_layout_String() {
                const UNINIT: ::std::mem::MaybeUninit<String> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<String>(),
                    24usize,
                    concat!("Size of: ", stringify!(String))
                );
                assert_eq!(
                    ::std::mem::align_of::<String>(),
                    8usize,
                    concat!("Alignment of ", stringify!(String))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).flags_) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String),
                        "::",
                        stringify!(flags_)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).externalCallbacks) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String),
                        "::",
                        stringify!(externalCallbacks)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Symbol {
                pub _1: *mut ::std::os::raw::c_void,
                pub code_: u32,
            }
            pub const Symbol_WellKnownAPILimit: u32 = 2147483648;
            #[test]
            fn bindgen_test_layout_Symbol() {
                const UNINIT: ::std::mem::MaybeUninit<Symbol> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Symbol>(),
                    16usize,
                    concat!("Size of: ", stringify!(Symbol))
                );
                assert_eq!(
                    ::std::mem::align_of::<Symbol>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Symbol))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr)._1) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Symbol),
                        "::",
                        stringify!(_1)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).code_) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Symbol),
                        "::",
                        stringify!(code_)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Zone {
                pub runtime_: *mut root::JSRuntime,
                pub barrierTracer_: *mut root::JSTracer,
                pub needsIncrementalBarrier_: root::JS::shadow::Zone_BarrierState,
                pub gcState_: root::JS::shadow::Zone_GCState,
                pub kind_: root::JS::shadow::Zone_Kind,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Zone_GCState {
                NoGC = 0,
                Prepare = 1,
                MarkBlackOnly = 2,
                MarkBlackAndGray = 3,
                Sweep = 4,
                Finished = 5,
                Compact = 6,
                VerifyPreBarriers = 7,
                Limit = 8,
            }
            #[doc = " Atomic<T> implementation for integral types.\n\n In addition to atomic store and load operations, compound assignment and\n increment/decrement operators are implemented which perform the\n corresponding read-modify-write operation atomically.  Finally, an atomic\n swap method is provided."]
            pub type Zone_BarrierState = u32;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Zone_Kind {
                NormalZone = 0,
                AtomsZone = 1,
                SystemZone = 2,
            }
            #[test]
            fn bindgen_test_layout_Zone() {
                const UNINIT: ::std::mem::MaybeUninit<Zone> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Zone>(),
                    32usize,
                    concat!("Size of: ", stringify!(Zone))
                );
                assert_eq!(
                    ::std::mem::align_of::<Zone>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Zone))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).runtime_) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(runtime_)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).barrierTracer_) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(barrierTracer_)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).needsIncrementalBarrier_) as usize
                            - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(needsIncrementalBarrier_)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).gcState_) as usize - ptr as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(gcState_)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).kind_) as usize - ptr as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(kind_)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Realm {
                pub compartment_: *mut root::JS::Compartment,
            }
            #[test]
            fn bindgen_test_layout_Realm() {
                const UNINIT: ::std::mem::MaybeUninit<Realm> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Realm>(),
                    8usize,
                    concat!("Size of: ", stringify!(Realm))
                );
                assert_eq!(
                    ::std::mem::align_of::<Realm>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Realm))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).compartment_) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Realm),
                        "::",
                        stringify!(compartment_)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BaseShape {
                pub clasp: *const root::JSClass,
                pub realm: *mut root::JS::Realm,
            }
            #[test]
            fn bindgen_test_layout_BaseShape() {
                const UNINIT: ::std::mem::MaybeUninit<BaseShape> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<BaseShape>(),
                    16usize,
                    concat!("Size of: ", stringify!(BaseShape))
                );
                assert_eq!(
                    ::std::mem::align_of::<BaseShape>(),
                    8usize,
                    concat!("Alignment of ", stringify!(BaseShape))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).clasp) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BaseShape),
                        "::",
                        stringify!(clasp)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).realm) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BaseShape),
                        "::",
                        stringify!(realm)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Shape {
                pub base: *mut root::JS::shadow::BaseShape,
                pub immutableFlags: u32,
            }
            pub const Shape_FIXED_SLOTS_SHIFT: u32 = 5;
            pub const Shape_FIXED_SLOTS_MASK: u32 = 992;
            #[test]
            fn bindgen_test_layout_Shape() {
                const UNINIT: ::std::mem::MaybeUninit<Shape> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Shape>(),
                    16usize,
                    concat!("Size of: ", stringify!(Shape))
                );
                assert_eq!(
                    ::std::mem::align_of::<Shape>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Shape))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Shape),
                        "::",
                        stringify!(base)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).immutableFlags) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Shape),
                        "::",
                        stringify!(immutableFlags)
                    )
                );
            }
            #[doc = " This layout is shared by all native objects. For non-native objects, the\n shape may always be accessed safely, and other members may be as well,\n depending on the object's specific layout."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Object {
                pub shape: *mut root::JS::shadow::Shape,
                pub slots: *mut root::JS::Value,
                pub _1: *mut ::std::os::raw::c_void,
            }
            pub const Object_MAX_FIXED_SLOTS: usize = 16;
            #[test]
            fn bindgen_test_layout_Object() {
                const UNINIT: ::std::mem::MaybeUninit<Object> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Object>(),
                    24usize,
                    concat!("Size of: ", stringify!(Object))
                );
                assert_eq!(
                    ::std::mem::align_of::<Object>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Object))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Object),
                        "::",
                        stringify!(shape)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Object),
                        "::",
                        stringify!(slots)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr)._1) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Object),
                        "::",
                        stringify!(_1)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Function {
                pub _base: root::JS::shadow::Object,
            }
            pub const Function_FlagsAndArgCountSlot: root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::FlagsAndArgCountSlot;
            pub const Function_NativeFuncOrInterpretedEnvSlot:
                root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::NativeFuncOrInterpretedEnvSlot;
            pub const Function_NativeJitInfoOrInterpretedScriptSlot:
                root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::NativeJitInfoOrInterpretedScriptSlot;
            pub const Function_AtomSlot: root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::AtomSlot;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Function__bindgen_ty_1 {
                FlagsAndArgCountSlot = 0,
                NativeFuncOrInterpretedEnvSlot = 1,
                NativeJitInfoOrInterpretedScriptSlot = 2,
                AtomSlot = 3,
            }
            #[test]
            fn bindgen_test_layout_Function() {
                assert_eq!(
                    ::std::mem::size_of::<Function>(),
                    24usize,
                    concat!("Size of: ", stringify!(Function))
                );
                assert_eq!(
                    ::std::mem::align_of::<Function>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Function))
                );
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum HeapState {
            Idle = 0,
            Tracing = 1,
            MajorCollecting = 2,
            MinorCollecting = 3,
            CycleCollecting = 4,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16RuntimeHeapStateEv"]
            pub fn RuntimeHeapState() -> root::JS::HeapState;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StackKind {
            StackForSystemCode = 0,
            StackForTrustedScript = 1,
            StackForUntrustedScript = 2,
            StackKindCount = 3,
        }
        #[doc = " A GC pointer, tagged with the trace kind.\n\n In general, a GC pointer should be stored with an exact type. This class\n is for use when that is not possible because a single pointer must point\n to several kinds of GC thing."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCCellPtr {
            pub ptr: usize,
        }
        #[test]
        fn bindgen_test_layout_GCCellPtr() {
            const UNINIT: ::std::mem::MaybeUninit<GCCellPtr> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GCCellPtr>(),
                8usize,
                concat!("Size of: ", stringify!(GCCellPtr))
            );
            assert_eq!(
                ::std::mem::align_of::<GCCellPtr>(),
                8usize,
                concat!("Alignment of ", stringify!(GCCellPtr))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCCellPtr),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetNurseryCellZoneEPN2js2gc4CellE"]
            pub fn GetNurseryCellZone(cell: *mut root::js::gc::Cell) -> *mut root::JS::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13GetObjectZoneEP8JSObject"]
            pub fn GetObjectZone(obj: *mut root::JSObject) -> *mut root::JS::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16GCThingTraceKindEPv"]
            pub fn GCThingTraceKind(thing: *mut ::std::os::raw::c_void) -> root::JS::TraceKind;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20EnableNurseryStringsEP9JSContext"]
            pub fn EnableNurseryStrings(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21DisableNurseryStringsEP9JSContext"]
            pub fn DisableNurseryStrings(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20EnableNurseryBigIntsEP9JSContext"]
            pub fn EnableNurseryBigInts(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21DisableNurseryBigIntsEP9JSContext"]
            pub fn DisableNurseryBigInts(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IsIncrementalBarrierNeededEP9JSContext"]
            pub fn IsIncrementalBarrierNeeded(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierEP8JSObject"]
            pub fn IncrementalPreWriteBarrier(obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierENS_9GCCellPtrE"]
            pub fn IncrementalPreWriteBarrier1(thing: root::JS::GCCellPtr);
        }
        extern "C" {
            #[doc = " Unsets the gray bit for anything reachable from |thing|. |kind| should not be\n JS::TraceKind::Shape. |thing| should be non-null. The return value indicates\n if anything was unmarked."]
            #[link_name = "\u{1}_ZN2JS28UnmarkGrayGCThingRecursivelyENS_9GCCellPtrE"]
            pub fn UnmarkGrayGCThingRecursively(thing: root::JS::GCCellPtr) -> bool;
        }
        extern "C" {
            #[doc = " Returns a static string equivalent of |kind|."]
            #[link_name = "\u{1}_ZN2JS18GCTraceKindToAsciiENS_9TraceKindE"]
            pub fn GCTraceKindToAscii(kind: root::JS::TraceKind) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Returns the base size in bytes of the GC thing of kind |kind|."]
            #[link_name = "\u{1}_ZN2JS15GCTraceKindSizeENS_9TraceKindE"]
            pub fn GCTraceKindSize(kind: root::JS::TraceKind) -> usize;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TracerKind {
            Marking = 0,
            Tenuring = 1,
            Moving = 2,
            ClearEdges = 3,
            Sweeping = 4,
            MinorSweeping = 5,
            Barrier = 6,
            Callback = 7,
            UnmarkGray = 8,
            VerifyTraceProtoAndIface = 9,
            CompartmentCheck = 10,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WeakMapTraceAction {
            #[doc = " Do not trace into weak map keys or values during traversal. Users must\n handle weak maps manually."]
            Skip = 0,
            #[doc = " Do true ephemeron marking with a weak key lookup marking phase. This is\n the default for GCMarker."]
            Expand = 1,
            #[doc = " Trace through to all values, irrespective of whether the keys are live\n or not. Used for non-marking tracers."]
            TraceValues = 2,
            #[doc = " Trace through to all keys and values, irrespective of whether the keys\n are live or not. Used for non-marking tracers."]
            TraceKeysAndValues = 3,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WeakEdgeTraceAction {
            Skip = 0,
            Trace = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TraceOptions {
            pub weakMapAction: root::JS::WeakMapTraceAction,
            pub weakEdgeAction: root::JS::WeakEdgeTraceAction,
        }
        #[test]
        fn bindgen_test_layout_TraceOptions() {
            const UNINIT: ::std::mem::MaybeUninit<TraceOptions> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TraceOptions>(),
                8usize,
                concat!("Size of: ", stringify!(TraceOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<TraceOptions>(),
                4usize,
                concat!("Alignment of ", stringify!(TraceOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).weakMapAction) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TraceOptions),
                    "::",
                    stringify!(weakMapAction)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).weakEdgeAction) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TraceOptions),
                    "::",
                    stringify!(weakEdgeAction)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TracingContext {
            pub index_: usize,
            pub functor_: *mut root::JS::TracingContext_Functor,
        }
        #[repr(C)]
        pub struct TracingContext_Functor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TracingContext_Functor {
            pub vtable_: *const TracingContext_Functor__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_TracingContext_Functor() {
            assert_eq!(
                ::std::mem::size_of::<TracingContext_Functor>(),
                8usize,
                concat!("Size of: ", stringify!(TracingContext_Functor))
            );
            assert_eq!(
                ::std::mem::align_of::<TracingContext_Functor>(),
                8usize,
                concat!("Alignment of ", stringify!(TracingContext_Functor))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14TracingContext12InvalidIndexE"]
            pub static TracingContext_InvalidIndex: usize;
        }
        #[test]
        fn bindgen_test_layout_TracingContext() {
            const UNINIT: ::std::mem::MaybeUninit<TracingContext> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TracingContext>(),
                16usize,
                concat!("Size of: ", stringify!(TracingContext))
            );
            assert_eq!(
                ::std::mem::align_of::<TracingContext>(),
                8usize,
                concat!("Alignment of ", stringify!(TracingContext))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).index_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TracingContext),
                    "::",
                    stringify!(index_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).functor_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TracingContext),
                    "::",
                    stringify!(functor_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CallbackTracer {
            pub _base: root::js::GenericTracerImpl,
        }
        #[test]
        fn bindgen_test_layout_CallbackTracer() {
            assert_eq!(
                ::std::mem::size_of::<CallbackTracer>(),
                48usize,
                concat!("Size of: ", stringify!(CallbackTracer))
            );
            assert_eq!(
                ::std::mem::align_of::<CallbackTracer>(),
                8usize,
                concat!("Alignment of ", stringify!(CallbackTracer))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoTracingIndex {
            pub trc_: *mut root::JSTracer,
        }
        #[test]
        fn bindgen_test_layout_AutoTracingIndex() {
            const UNINIT: ::std::mem::MaybeUninit<AutoTracingIndex> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoTracingIndex>(),
                8usize,
                concat!("Size of: ", stringify!(AutoTracingIndex))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoTracingIndex>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoTracingIndex))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).trc_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoTracingIndex),
                    "::",
                    stringify!(trc_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoTracingDetails {
            pub trc_: *mut root::JSTracer,
        }
        #[test]
        fn bindgen_test_layout_AutoTracingDetails() {
            const UNINIT: ::std::mem::MaybeUninit<AutoTracingDetails> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoTracingDetails>(),
                8usize,
                concat!("Size of: ", stringify!(AutoTracingDetails))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoTracingDetails>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoTracingDetails))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).trc_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoTracingDetails),
                    "::",
                    stringify!(trc_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoClearTracingContext {
            pub trc_: *mut root::JSTracer,
            pub prev_: root::JS::TracingContext,
        }
        #[test]
        fn bindgen_test_layout_AutoClearTracingContext() {
            const UNINIT: ::std::mem::MaybeUninit<AutoClearTracingContext> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoClearTracingContext>(),
                24usize,
                concat!("Size of: ", stringify!(AutoClearTracingContext))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoClearTracingContext>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoClearTracingContext))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).trc_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoClearTracingContext),
                    "::",
                    stringify!(trc_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).prev_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoClearTracingContext),
                    "::",
                    stringify!(prev_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPNS_6BigIntEPKc"]
            pub fn TraceRoot(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JS::BigInt,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPNS_6SymbolEPKc"]
            pub fn TraceRoot1(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JS::Symbol,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP6JSAtomPKc"]
            pub fn TraceRoot2(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSAtom,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP10JSFunctionPKc"]
            pub fn TraceRoot3(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSFunction,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP14JSLinearStringPKc"]
            pub fn TraceRoot4(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSLinearString,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSObjectPKc"]
            pub fn TraceRoot5(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSScriptPKc"]
            pub fn TraceRoot6(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSScript,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSStringPKc"]
            pub fn TraceRoot7(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSString,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPNS_5ValueEPKc"]
            pub fn TraceRoot8(
                trc: *mut root::JSTracer,
                edgep: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPNS_11PropertyKeyEPKc"]
            pub fn TraceRoot9(
                trc: *mut root::JSTracer,
                edgep: *mut root::JS::PropertyKey,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPN2js23AbstractGeneratorObjectEPKc"]
            pub fn TraceRoot10(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::js::AbstractGeneratorObject,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPN2js10SavedFrameEPKc"]
            pub fn TraceRoot11(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::js::SavedFrame,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13TraceChildrenEP8JSTracerNS_9GCCellPtrE"]
            pub fn TraceChildren(trc: *mut root::JSTracer, thing: root::JS::GCCellPtr);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StructGCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IgnoreGCPolicy {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_unsigned_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_unsigned_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_bool__close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCPointerPolicy {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_BigInt_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_BigInt_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Symbol_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Symbol_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSAtom_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSAtom_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSFunction_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSFunction_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSLinearString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSLinearString_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSObject_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSObject_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSScript_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSString_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NonGCPointerPolicy {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_Nothing_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_Ok_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        impl root::JS::ProfilingCategoryPair {
            pub const LAST: root::JS::ProfilingCategoryPair = ProfilingCategoryPair::PROFILER;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingCategoryPair {
            IDLE = 0,
            OTHER = 1,
            OTHER_PreferenceRead = 2,
            OTHER_Profiling = 3,
            TEST = 4,
            LAYOUT = 5,
            LAYOUT_FrameConstruction = 6,
            LAYOUT_Reflow = 7,
            LAYOUT_CSSParsing = 8,
            LAYOUT_SelectorQuery = 9,
            LAYOUT_StyleComputation = 10,
            LAYOUT_Destroy = 11,
            JS = 12,
            JS_Parsing = 13,
            JS_BaselineCompilation = 14,
            JS_IonCompilation = 15,
            JS_Interpreter = 16,
            JS_BaselineInterpret = 17,
            JS_Baseline = 18,
            JS_IonMonkey = 19,
            JS_Builtin = 20,
            JS_Wasm = 21,
            GCCC = 22,
            GCCC_MinorGC = 23,
            GCCC_MajorGC = 24,
            GCCC_MajorGC_Mark = 25,
            GCCC_MajorGC_Sweep = 26,
            GCCC_MajorGC_Compact = 27,
            GCCC_UnmarkGray = 28,
            GCCC_Barrier = 29,
            GCCC_FreeSnowWhite = 30,
            GCCC_BuildGraph = 31,
            GCCC_ScanRoots = 32,
            GCCC_CollectWhite = 33,
            GCCC_Finalize = 34,
            NETWORK = 35,
            GRAPHICS = 36,
            GRAPHICS_DisplayListBuilding = 37,
            GRAPHICS_DisplayListMerging = 38,
            GRAPHICS_LayerBuilding = 39,
            GRAPHICS_TileAllocation = 40,
            GRAPHICS_WRDisplayList = 41,
            GRAPHICS_Rasterization = 42,
            GRAPHICS_FlushingAsyncPaints = 43,
            GRAPHICS_ImageDecoding = 44,
            DOM = 45,
            JAVA_ANDROID = 46,
            JAVA_ANDROIDX = 47,
            JAVA_LANGUAGE = 48,
            JAVA_MOZILLA = 49,
            JAVA_KOTLIN = 50,
            JAVA_BLOCKED = 51,
            IPC = 52,
            MEDIA = 53,
            MEDIA_CUBEB = 54,
            MEDIA_PLAYBACK = 55,
            MEDIA_RT = 56,
            PROFILER = 57,
            COUNT = 58,
        }
        impl root::JS::ProfilingCategory {
            pub const LAST: root::JS::ProfilingCategory = ProfilingCategory::PROFILER;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingCategory {
            IDLE = 0,
            OTHER = 1,
            TEST = 2,
            LAYOUT = 3,
            JS = 4,
            GCCC = 5,
            NETWORK = 6,
            GRAPHICS = 7,
            DOM = 8,
            JAVA_ANDROID = 9,
            JAVA_ANDROIDX = 10,
            JAVA_LANGUAGE = 11,
            JAVA_MOZILLA = 12,
            JAVA_KOTLIN = 13,
            JAVA_BLOCKED = 14,
            IPC = 15,
            MEDIA = 16,
            PROFILER = 17,
            COUNT = 18,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ProfilingCategoryPairInfo {
            pub mCategory: root::JS::ProfilingCategory,
            pub mSubcategoryIndex: u32,
            pub mLabel: *const ::std::os::raw::c_char,
        }
        #[test]
        fn bindgen_test_layout_ProfilingCategoryPairInfo() {
            const UNINIT: ::std::mem::MaybeUninit<ProfilingCategoryPairInfo> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ProfilingCategoryPairInfo>(),
                16usize,
                concat!("Size of: ", stringify!(ProfilingCategoryPairInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ProfilingCategoryPairInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ProfilingCategoryPairInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mCategory) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingCategoryPairInfo),
                    "::",
                    stringify!(mCategory)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mSubcategoryIndex) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingCategoryPairInfo),
                    "::",
                    stringify!(mSubcategoryIndex)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mLabel) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingCategoryPairInfo),
                    "::",
                    stringify!(mLabel)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28GetProfilingCategoryPairInfoENS_21ProfilingCategoryPairE"]
            pub fn GetProfilingCategoryPairInfo(
                aCategoryPair: root::JS::ProfilingCategoryPair,
            ) -> *const root::JS::ProfilingCategoryPairInfo;
        }
        pub type RegisterThreadCallback = ::std::option::Option<
            unsafe extern "C" fn(
                threadName: *const ::std::os::raw::c_char,
                stackBase: *mut ::std::os::raw::c_void,
            ) -> *mut root::ProfilingStack,
        >;
        pub type UnregisterThreadCallback = ::std::option::Option<unsafe extern "C" fn()>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27SetProfilingThreadCallbacksEPFP14ProfilingStackPKcPvEPFvvE"]
            pub fn SetProfilingThreadCallbacks(
                registerThread: root::JS::RegisterThreadCallback,
                unregisterThread: root::JS::UnregisterThreadCallback,
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Realm_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetCurrentRealmOrNullEP9JSContext"]
            pub fn GetCurrentRealmOrNull(cx: *mut root::JSContext) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetObjectRealmOrNullEP8JSObject"]
            pub fn GetObjectRealmOrNull(obj: *mut root::JSObject) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetRealmPrivateEPNS_5RealmE"]
            pub fn GetRealmPrivate(realm: *mut root::JS::Realm) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetRealmPrivateEPNS_5RealmEPv"]
            pub fn SetRealmPrivate(realm: *mut root::JS::Realm, data: *mut ::std::os::raw::c_void);
        }
        pub type DestroyRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(gcx: *mut root::JS::GCContext, realm: *mut root::JS::Realm),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23SetDestroyRealmCallbackEP9JSContextPFvPNS_9GCContextEPNS_5RealmEE"]
            pub fn SetDestroyRealmCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DestroyRealmCallback,
            );
        }
        pub type RealmNameCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                realm: *mut root::JS::Realm,
                buf: *mut ::std::os::raw::c_char,
                bufsize: usize,
                nogc: *const root::JS::AutoRequireNoGC,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20SetRealmNameCallbackEP9JSContextPFvS1_PNS_5RealmEPcmRKNS_15AutoRequireNoGCEE"]
            pub fn SetRealmNameCallback(
                cx: *mut root::JSContext,
                callback: root::JS::RealmNameCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetRealmGlobalOrNullEPNS_5RealmE"]
            pub fn GetRealmGlobalOrNull(realm: *mut root::JS::Realm) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InitRealmStandardClassesEP9JSContext"]
            pub fn InitRealmStandardClasses(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27MaybeFreezeCtorAndPrototypeEP9JSContextNS_6HandleIP8JSObjectEES5_"]
            pub fn MaybeFreezeCtorAndPrototype(
                cx: *mut root::JSContext,
                ctor: root::JS::HandleObject,
                maybeProto: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetRealmObjectPrototypeEP9JSContext"]
            pub fn GetRealmObjectPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS29GetRealmObjectPrototypeHandleEP9JSContext"]
            pub fn GetRealmObjectPrototypeHandle(
                cx: *mut root::JSContext,
            ) -> root::JS::Handle<*mut root::JSObject>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetRealmFunctionPrototypeEP9JSContext"]
            pub fn GetRealmFunctionPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22GetRealmArrayPrototypeEP9JSContext"]
            pub fn GetRealmArrayPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22GetRealmErrorPrototypeEP9JSContext"]
            pub fn GetRealmErrorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetRealmIteratorPrototypeEP9JSContext"]
            pub fn GetRealmIteratorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30GetRealmAsyncIteratorPrototypeEP9JSContext"]
            pub fn GetRealmAsyncIteratorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17GetRealmKeyObjectEP9JSContext"]
            pub fn GetRealmKeyObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16GetFunctionRealmEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetFunctionRealm(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
            ) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[doc = " NB: This API is infallible; a nullptr return value does not indicate error.\n\n |target| must not be a cross-compartment wrapper because CCWs are not\n associated with a single realm.\n\n Entering a realm roots the realm and its global object until the matching\n JS::LeaveRealm() call."]
            #[link_name = "\u{1}_ZN2JS10EnterRealmEP9JSContextP8JSObject"]
            pub fn EnterRealm(
                cx: *mut root::JSContext,
                target: *mut root::JSObject,
            ) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10LeaveRealmEP9JSContextPNS_5RealmE"]
            pub fn LeaveRealm(cx: *mut root::JSContext, oldRealm: *mut root::JS::Realm);
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RuntimeCode {
            JS = 0,
            WASM = 1,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoHoldPrincipals {
            pub cx_: *mut root::JSContext,
            pub principals_: *mut root::JSPrincipals,
        }
        #[test]
        fn bindgen_test_layout_AutoHoldPrincipals() {
            const UNINIT: ::std::mem::MaybeUninit<AutoHoldPrincipals> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoHoldPrincipals>(),
                16usize,
                concat!("Size of: ", stringify!(AutoHoldPrincipals))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoHoldPrincipals>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoHoldPrincipals))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).cx_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoHoldPrincipals),
                    "::",
                    stringify!(cx_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).principals_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoHoldPrincipals),
                    "::",
                    stringify!(principals_)
                )
            );
        }
        pub type NativeStackSize = usize;
        pub type NativeStackBase = usize;
        pub type NativeStackLimit = usize;
        #[doc = " Capture all frames."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllFrames {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AllFrames() {
            assert_eq!(
                ::std::mem::size_of::<AllFrames>(),
                1usize,
                concat!("Size of: ", stringify!(AllFrames))
            );
            assert_eq!(
                ::std::mem::align_of::<AllFrames>(),
                1usize,
                concat!("Alignment of ", stringify!(AllFrames))
            );
        }
        #[doc = " Capture at most this many frames."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MaxFrames {
            pub maxFrames: u32,
        }
        #[test]
        fn bindgen_test_layout_MaxFrames() {
            const UNINIT: ::std::mem::MaybeUninit<MaxFrames> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<MaxFrames>(),
                4usize,
                concat!("Size of: ", stringify!(MaxFrames))
            );
            assert_eq!(
                ::std::mem::align_of::<MaxFrames>(),
                4usize,
                concat!("Alignment of ", stringify!(MaxFrames))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).maxFrames) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MaxFrames),
                    "::",
                    stringify!(maxFrames)
                )
            );
        }
        #[doc = " Capture the first frame with the given principals. By default, do not\n consider self-hosted frames with the given principals as satisfying the stack\n capture."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct FirstSubsumedFrame {
            pub cx: *mut root::JSContext,
            pub principals: *mut root::JSPrincipals,
            pub ignoreSelfHosted: bool,
        }
        #[test]
        fn bindgen_test_layout_FirstSubsumedFrame() {
            const UNINIT: ::std::mem::MaybeUninit<FirstSubsumedFrame> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<FirstSubsumedFrame>(),
                24usize,
                concat!("Size of: ", stringify!(FirstSubsumedFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<FirstSubsumedFrame>(),
                8usize,
                concat!("Alignment of ", stringify!(FirstSubsumedFrame))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FirstSubsumedFrame),
                    "::",
                    stringify!(cx)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).principals) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FirstSubsumedFrame),
                    "::",
                    stringify!(principals)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ignoreSelfHosted) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FirstSubsumedFrame),
                    "::",
                    stringify!(ignoreSelfHosted)
                )
            );
        }
        #[doc = " # mozilla::Variant\n\n A variant / tagged union / heterogenous disjoint union / sum-type template\n class. Similar in concept to (but not derived from) `boost::variant`.\n\n Sometimes, you may wish to use a C union with non-POD types. However, this is\n forbidden in C++ because it is not clear which type in the union should have\n its constructor and destructor run on creation and deletion\n respectively. This is the problem that `mozilla::Variant` solves.\n\n ## Usage\n\n A `mozilla::Variant` instance is constructed (via move or copy) from one of\n its variant types (ignoring const and references). It does *not* support\n construction from subclasses of variant types or types that coerce to one of\n the variant types.\n\n     Variant<char, uint32_t> v1('a');\n     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());\n     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed\n     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int\n\n Because specifying the full type of a Variant value is often verbose,\n there are two easier ways to construct values:\n\n A. AsVariant() can be used to construct a Variant value using type inference\n in contexts such as expressions or when returning values from functions.\n Because AsVariant() must copy or move the value into a temporary and this\n cannot necessarily be elided by the compiler, it's mostly appropriate only\n for use with primitive or very small types.\n\n     Variant<char, uint32_t> Foo() { return AsVariant('x'); }\n     // ...\n     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x').\n\n B. Brace-construction with VariantType or VariantIndex; this also allows\n in-place construction with any number of arguments.\n\n     struct AB { AB(int, int){...} };\n     static Variant<AB, bool> foo()\n     {\n       return {VariantIndex<0>{}, 1, 2};\n     }\n     // ...\n     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2).\n\n All access to the contained value goes through type-safe accessors.\n Either the stored type, or the type index may be provided.\n\n     void\n     Foo(Variant<A, B, C> v)\n     {\n       if (v.is<A>()) {\n         A& ref = v.as<A>();\n         ...\n       } else (v.is<1>()) { // Instead of v.is<B>.\n         ...\n       } else {\n         ...\n       }\n     }\n\n In some situation, a Variant may be constructed from templated types, in\n which case it is possible that the same type could be given multiple times by\n an external developer. Or seemingly-different types could be aliases.\n In this case, repeated types can only be accessed through their index, to\n prevent ambiguous access by type.\n\n    // Bad!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(int(0)) {} // Error '0' by default\n      ResultOrError(const T& r) : m(r) {}\n      bool IsResult() const { return m.is<T>(); }\n      bool IsError() const { return m.is<int>(); }\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // Fail!\n    // In Variant<int, int>, which 'int' are we refering to, from inside\n    // ResultOrError functions?\n\n    // Good!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default\n      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}\n      bool IsResult() const { return m.is<0>(); } // 0 -> T\n      bool IsError() const { return m.is<1>(); } // 1 -> int\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // It now works!\n\n Attempting to use the contained value as type `T1` when the `Variant`\n instance contains a value of type `T2` causes an assertion failure.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<B>(); // <--- Assertion failure!\n\n Trying to use a `Variant<Ts...>` instance as some type `U` that is not a\n member of the set of `Ts...` is a compiler error.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<SomeRandomType>(); // <--- Compiler error!\n\n Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it\n out of the containing `Variant` instance with the `extract<T>` method:\n\n     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());\n     auto ptr = v.extract<UniquePtr<A>>();\n\n Finally, you can exhaustively match on the contained variant and branch into\n different code paths depending on which type is contained. This is preferred\n to manually checking every variant type T with is<T>() because it provides\n compile-time checking that you handled every type, rather than runtime\n assertion failures.\n\n     // Bad!\n     char* foo(Variant<A, B, C, D>& v) {\n       if (v.is<A>()) {\n         return ...;\n       } else if (v.is<B>()) {\n         return ...;\n       } else {\n         return doSomething(v.as<C>()); // Forgot about case D!\n       }\n     }\n\n     // Instead, a single function object (that can deal with all possible\n     // options) may be provided:\n     struct FooMatcher\n     {\n       // The return type of all matchers must be identical.\n       char* operator()(A& a) { ... }\n       char* operator()(B& b) { ... }\n       char* operator()(C& c) { ... }\n       char* operator()(D& d) { ... } // Compile-time error to forget D!\n     }\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match(FooMatcher());\n     }\n\n     // In some situations, a single generic lambda may also be appropriate:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto&) {...});\n     }\n\n     // Alternatively, multiple function objects may be provided, each one\n     // corresponding to an option, in the same order:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](A&) { ... },\n                      [](B&) { ... },\n                      [](C&) { ... },\n                      [](D&) { ... });\n     }\n\n     // In rare cases, the index of the currently-active alternative is\n     // needed, it may be obtained by adding a first parameter in the matcner\n     // callback, which will receive the index in its most compact type (just\n     // use `size_t` if the exact type is not important), e.g.:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto aIndex, auto& aAlternative) {...});\n       // --OR--\n       return v.match([](size_t aIndex, auto& aAlternative) {...});\n     }\n\n ## Examples\n\n A tree is either an empty leaf, or a node with a value and two children:\n\n     struct Leaf { };\n\n     template<typename T>\n     struct Node\n     {\n       T value;\n       Tree<T>* left;\n       Tree<T>* right;\n     };\n\n     template<typename T>\n     using Tree = Variant<Leaf, Node<T>>;\n\n A copy-on-write string is either a non-owning reference to some existing\n string, or an owning reference to our copy:\n\n     class CopyOnWriteString\n     {\n       Variant<const char*, UniquePtr<char[]>> string;\n\n       ...\n     };\n\n Because Variant must be aligned suitable to hold any value stored within it,\n and because |alignas| requirements don't affect platform ABI with respect to\n how parameters are laid out in memory, Variant can't be used as the type of a\n function parameter.  Pass Variant to functions by pointer or reference\n instead."]
        pub type StackCapture = [u64; 4usize];
        extern "C" {
            #[doc = " Capture the current call stack as a chain of SavedFrame JSObjects, and set\n |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there\n are no JS frames on the stack.\n\n The |capture| parameter describes the portion of the JS stack to capture:\n\n   * |JS::AllFrames|: Capture all frames on the stack.\n\n   * |JS::MaxFrames|: Capture no more than |JS::MaxFrames::maxFrames| from the\n      stack.\n\n   * |JS::FirstSubsumedFrame|: Capture the first frame whose principals are\n     subsumed by |JS::FirstSubsumedFrame::principals|. By default, do not\n     consider self-hosted frames; this can be controlled via the\n     |JS::FirstSubsumedFrame::ignoreSelfHosted| flag. Do not capture any async\n     stack."]
            #[link_name = "\u{1}_ZN2JS19CaptureCurrentStackEP9JSContextNS_13MutableHandleIP8JSObjectEEON7mozilla7VariantIJNS_9AllFramesENS_9MaxFramesENS_18FirstSubsumedFrameEEEE"]
            pub fn CaptureCurrentStack(
                cx: *mut root::JSContext,
                stackp: root::JS::MutableHandleObject,
                capture: *mut root::JS::StackCapture,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if capturing stack trace data to associate with an asynchronous\n operation is currently enabled for the current context realm.\n\n Users should check this state before capturing a stack that will be passed\n back to AutoSetAsyncStackForNewCalls later, in order to avoid capturing a\n stack for async use when we don't actually want to capture it."]
            #[link_name = "\u{1}_ZN2JS34IsAsyncStackCaptureEnabledForRealmEP9JSContext"]
            pub fn IsAsyncStackCaptureEnabledForRealm(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject stack, stringify it in the same format as\n Error.prototype.stack. The stringified stack out parameter is placed in the\n cx's compartment. Defaults to the empty string.\n\n The same notes above about SavedFrame accessors applies here as well: cx\n doesn't need to be in stack's compartment, and stack can be null, a\n SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object.\n SavedFrames not subsumed by |principals| are skipped.\n\n Optional indent parameter specifies the number of white spaces to indent\n each line."]
            #[link_name = "\u{1}_ZN2JS16BuildStackStringEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEEmN2js11StackFormatE"]
            pub fn BuildStackString(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                stack: root::JS::HandleObject,
                stringp: root::JS::MutableHandleString,
                indent: usize,
                stackFormat: root::js::StackFormat,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeletePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FreePolicy() {
            assert_eq!(
                ::std::mem::size_of::<FreePolicy>(),
                1usize,
                concat!("Size of: ", stringify!(FreePolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<FreePolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(FreePolicy))
            );
        }
        pub type UniqueChars = u64;
        pub type UniqueTwoByteChars = u8;
        pub type UniqueLatin1Chars = u8;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26HeapObjectPostWriteBarrierEPP8JSObjectS1_S1_"]
            pub fn HeapObjectPostWriteBarrier(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26HeapStringPostWriteBarrierEPP8JSStringS1_S1_"]
            pub fn HeapStringPostWriteBarrier(
                objp: *mut *mut root::JSString,
                prev: *mut root::JSString,
                next: *mut root::JSString,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26HeapBigIntPostWriteBarrierEPPNS_6BigIntES1_S1_"]
            pub fn HeapBigIntPostWriteBarrier(
                bip: *mut *mut root::JS::BigInt,
                prev: *mut root::JS::BigInt,
                next: *mut root::JS::BigInt,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapObjectWriteBarriersEPP8JSObjectS1_S1_"]
            pub fn HeapObjectWriteBarriers(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapStringWriteBarriersEPP8JSStringS1_S1_"]
            pub fn HeapStringWriteBarriers(
                objp: *mut *mut root::JSString,
                prev: *mut root::JSString,
                next: *mut root::JSString,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapBigIntWriteBarriersEPPNS_6BigIntES1_S1_"]
            pub fn HeapBigIntWriteBarriers(
                bip: *mut *mut root::JS::BigInt,
                prev: *mut root::JS::BigInt,
                next: *mut root::JS::BigInt,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapScriptWriteBarriersEPP8JSScriptS1_S1_"]
            pub fn HeapScriptWriteBarriers(
                objp: *mut *mut root::JSScript,
                prev: *mut root::JSScript,
                next: *mut root::JSScript,
            );
        }
        #[doc = " SafelyInitialized<T>::create() creates a safely-initialized |T|, suitable for\n use as a default value in situations requiring a safe but arbitrary |T|\n value. Implemented as a static method of a struct to allow partial\n specialization for subclasses via the Enable template parameter."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SafelyInitialized {
            pub _address: u8,
        }
        pub type Heap_ElementType<T> = T;
        #[doc = " The TenuredHeap<T> class is similar to the Heap<T> class above in that it\n encapsulates the GC concerns of an on-heap reference to a JS object. However,\n it has two important differences:\n\n  1) Pointers which are statically known to only reference \"tenured\" objects\n     can avoid the extra overhead of SpiderMonkey's write barriers.\n\n  2) Objects in the \"tenured\" heap have stronger alignment restrictions than\n     those in the \"nursery\", so it is possible to store flags in the lower\n     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged\n     pointer with a nice API for accessing the flag bits and adds various\n     assertions to ensure that it is not mis-used.\n\n GC things are said to be \"tenured\" when they are located in the long-lived\n heap: e.g. they have gained tenure as an object by surviving past at least\n one GC. For performance, SpiderMonkey allocates some things which are known\n to normally be long lived directly into the tenured generation; for example,\n global objects. Additionally, SpiderMonkey does not visit individual objects\n when deleting non-tenured objects, so object with finalizers are also always\n tenured; for instance, this includes most DOM objects.\n\n The considerations to keep in mind when using a TenuredHeap<T> vs a normal\n Heap<T> are:\n\n  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.\n  - It is however valid for a Heap<T> to refer to a tenured thing.\n  - It is not possible to store flag bits in a Heap<T>."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TenuredHeap {
            pub bits: usize,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TenuredHeap__bindgen_ty_1 {
            maskBits = 0,
        }
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Handle<T> {
            pub ptr: *const T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type Handle_ElementType<T> = T;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Handle_Disambiguator {
            DeliberatelyChoosingThisOverload = 0,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Handle_CallerIdentity {
            ImUsingThisOnlyInFromFromMarkedLocation = 0,
        }
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandle<T> {
            pub ptr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type MutableHandle_ElementType<T> = T;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AutoGCRooterKind {
            WrapperVector = 0,
            Wrapper = 1,
            Custom = 2,
            Limit = 3,
        }
        #[doc = " EnumeratedArray is a fixed-size array container for use when an\n array is indexed by a specific enum class.\n\n This provides type safety by guarding at compile time against accidentally\n indexing such arrays with unrelated values. This also removes the need\n for manual casting when using a typed enum value to index arrays.\n\n Aside from the typing of indices, EnumeratedArray is similar to Array.\n\n Example:\n\n   enum class AnimalSpecies {\n     Cow,\n     Sheep,\n     Count\n   };\n\n   EnumeratedArray<AnimalSpecies, AnimalSpecies::Count, int> headCount;\n\n   headCount[AnimalSpecies::Cow] = 17;\n   headCount[AnimalSpecies::Sheep] = 30;\n"]
        pub type RootedListHeads = [u64; 15usize];
        #[doc = " EnumeratedArray is a fixed-size array container for use when an\n array is indexed by a specific enum class.\n\n This provides type safety by guarding at compile time against accidentally\n indexing such arrays with unrelated values. This also removes the need\n for manual casting when using a typed enum value to index arrays.\n\n Aside from the typing of indices, EnumeratedArray is similar to Array.\n\n Example:\n\n   enum class AnimalSpecies {\n     Cow,\n     Sheep,\n     Count\n   };\n\n   EnumeratedArray<AnimalSpecies, AnimalSpecies::Count, int> headCount;\n\n   headCount[AnimalSpecies::Cow] = 17;\n   headCount[AnimalSpecies::Sheep] = 30;\n"]
        pub type AutoRooterListHeads = [u64; 3usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RootingContext {
            pub stackRoots_: root::JS::RootedListHeads,
            pub autoGCRooters_: root::JS::AutoRooterListHeads,
            pub geckoProfiler_: root::js::GeckoProfilerThread,
            pub realm_: *mut root::JS::Realm,
            pub zone_: *mut root::JS::Zone,
            pub nativeStackLimit: [root::JS::NativeStackLimit; 3usize],
        }
        #[test]
        fn bindgen_test_layout_RootingContext() {
            const UNINIT: ::std::mem::MaybeUninit<RootingContext> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RootingContext>(),
                200usize,
                concat!("Size of: ", stringify!(RootingContext))
            );
            assert_eq!(
                ::std::mem::align_of::<RootingContext>(),
                8usize,
                concat!("Alignment of ", stringify!(RootingContext))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).stackRoots_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(stackRoots_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).autoGCRooters_) as usize - ptr as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(autoGCRooters_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).geckoProfiler_) as usize - ptr as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(geckoProfiler_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).realm_) as usize - ptr as usize },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(realm_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).zone_) as usize - ptr as usize },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(zone_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).nativeStackLimit) as usize - ptr as usize },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(nativeStackLimit)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoGCRooter {
            pub down: *mut root::JS::AutoGCRooter,
            pub stackTop: *mut *mut root::JS::AutoGCRooter,
            pub kind_: root::JS::AutoGCRooter_Kind,
        }
        pub use self::super::super::root::JS::AutoGCRooterKind as AutoGCRooter_Kind;
        #[test]
        fn bindgen_test_layout_AutoGCRooter() {
            const UNINIT: ::std::mem::MaybeUninit<AutoGCRooter> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoGCRooter>(),
                24usize,
                concat!("Size of: ", stringify!(AutoGCRooter))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoGCRooter>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoGCRooter))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).down) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoGCRooter),
                    "::",
                    stringify!(down)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).stackTop) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoGCRooter),
                    "::",
                    stringify!(stackTop)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).kind_) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoGCRooter),
                    "::",
                    stringify!(kind_)
                )
            );
        }
        #[repr(C)]
        pub struct CustomAutoRooter__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Custom rooting behavior for internal and external clients.\n\n Deprecated. Where possible, use Rooted<> instead."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CustomAutoRooter {
            pub vtable_: *const CustomAutoRooter__bindgen_vtable,
            pub _base: root::JS::AutoGCRooter,
        }
        #[test]
        fn bindgen_test_layout_CustomAutoRooter() {
            assert_eq!(
                ::std::mem::size_of::<CustomAutoRooter>(),
                32usize,
                concat!("Size of: ", stringify!(CustomAutoRooter))
            );
            assert_eq!(
                ::std::mem::align_of::<CustomAutoRooter>(),
                8usize,
                concat!("Alignment of ", stringify!(CustomAutoRooter))
            );
        }
        pub type Rooted_ElementType<T> = T;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEPNS_14RootingContextENS_8RootKindEPN2js20PersistentRootedBaseE"]
            pub fn AddPersistentRoot(
                cx: *mut root::JS::RootingContext,
                kind: root::JS::RootKind,
                root: *mut root::js::PersistentRootedBase,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEP9JSRuntimeNS_8RootKindEPN2js20PersistentRootedBaseE"]
            pub fn AddPersistentRoot1(
                rt: *mut root::JSRuntime,
                kind: root::JS::RootKind,
                root: *mut root::js::PersistentRootedBase,
            );
        }
        #[doc = " A copyable, assignable global GC root type with arbitrary lifetime, an\n infallible constructor, and automatic unrooting on destruction.\n\n These roots can be used in heap-allocated data structures, so they are not\n associated with any particular JSContext or stack. They are registered with\n the JSRuntime itself, without locking. Initialization may take place on\n construction, or in two phases if the no-argument constructor is called\n followed by init().\n\n Note that you must not use an PersistentRooted in an object owned by a JS\n object:\n\n Whenever one object whose lifetime is decided by the GC refers to another\n such object, that edge must be traced only if the owning JS object is traced.\n This applies not only to JS objects (which obviously are managed by the GC)\n but also to C++ objects owned by JS objects.\n\n If you put a PersistentRooted in such a C++ object, that is almost certainly\n a leak. When a GC begins, the referent of the PersistentRooted is treated as\n live, unconditionally (because a PersistentRooted is a *root*), even if the\n JS object that owns it is unreachable. If there is any path from that\n referent back to the JS object, then the C++ object containing the\n PersistentRooted will not be destructed, and the whole blob of objects will\n not be freed, even if there are no references to them from the outside.\n\n In the context of Firefox, this is a severe restriction: almost everything in\n Firefox is owned by some JS object or another, so using PersistentRooted in\n such objects would introduce leaks. For these kinds of edges, Heap<T> or\n TenuredHeap<T> would be better types. It's up to the implementor of the type\n containing Heap<T> or TenuredHeap<T> members to make sure their referents get\n marked when the object itself is marked."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PersistentRooted {
            pub _address: u8,
        }
        pub type PersistentRooted_ElementType = u8;
        extern "C" {
            #[doc = " Evaluate the given source buffer in the scope of the current global of cx,\n and return the completion value in |rval|."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " As above, but providing an explicit scope chain.  envChain must not include\n the global object on it; that's implicit.  It needs to contain the other\n objects that should end up on the script's scope chain."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate1(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the provided UTF-8 data in the scope of the current global of |cx|,\n and return the completion value in |rval|.  If the data contains invalid\n UTF-8, an error is reported."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate2(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the UTF-8 contents of the file at the given path, and return the\n completion value in |rval|.  (The path itself is in the system encoding, not\n [necessarily] UTF-8.)  If the contents contain any malformed UTF-8, an error\n is reported."]
            #[link_name = "\u{1}_ZN2JS16EvaluateUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleINS_5ValueEEE"]
            pub fn EvaluateUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Compile the provided script using the given options.  Return the script on\n success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn Compile(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the provided script using the given options.  Return the script on\n success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn Compile1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the given file into a script.  It is an error\n if the file contains invalid UTF-8.  Return the script on success, or return\n null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS15CompileUtf8FileEP9JSContextRKNS_22ReadOnlyCompileOptionsEP8_IO_FILE"]
            pub fn CompileUtf8File(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                file: *mut root::FILE,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the file at the given path into a script.\n (The path itself is in the system encoding, not [necessarily] UTF-8.)  It\n is an error if the file's contents are invalid UTF-8.  Return the script on\n success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS15CompileUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKc"]
            pub fn CompileUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile a function with envChain plus the global as its scope chain.\n envChain must contain objects in the current compartment of cx.  The actual\n scope chain used for the function will consist of With wrappers for those\n objects, followed by the current global of the compartment cx is in.  This\n global must not be explicitly included in the scope chain."]
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_RNS_10SourceTextIDsEE"]
            pub fn CompileFunction(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Compile a function with envChain plus the global as its scope chain.\n envChain must contain objects in the current compartment of cx.  The actual\n scope chain used for the function will consist of With wrappers for those\n objects, followed by the current global of the compartment cx is in.  This\n global must not be explicitly included in the scope chain."]
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_RNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileFunction1(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Identical to the CompileFunction overload above for UTF-8, but with\n Rust-friendly ergonomics."]
            #[link_name = "\u{1}_ZN2JS19CompileFunctionUtf8EP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_SE_m"]
            pub fn CompileFunctionUtf8(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                utf8: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22ExposeScriptToDebuggerEP9JSContextNS_6HandleIP8JSScriptEE"]
            pub fn ExposeScriptToDebugger(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19UpdateDebugMetadataEP9JSContextNS_6HandleIP8JSScriptEERKNS_18InstantiateOptionsENS2_INS_5ValueEEENS2_IP8JSStringEES5_S5_"]
            pub fn UpdateDebugMetadata(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                options: *const root::JS::InstantiateOptions,
                privateValue: root::JS::HandleValue,
                elementAttributeName: root::JS::HandleString,
                introScript: root::JS::HandleScript,
                scriptOrModule: root::JS::HandleScript,
            ) -> bool;
        }
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct ContextOptions {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
        }
        #[test]
        fn bindgen_test_layout_ContextOptions() {
            assert_eq!(
                ::std::mem::size_of::<ContextOptions>(),
                4usize,
                concat!("Size of: ", stringify!(ContextOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<ContextOptions>(),
                1usize,
                concat!("Alignment of ", stringify!(ContextOptions))
            );
        }
        impl ContextOptions {
            #[inline]
            pub fn asmJS_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asmJS_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasm_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasm_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmForTrustedPrinciples_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmForTrustedPrinciples_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmVerbose_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmVerbose_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmBaseline_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmBaseline_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmIon_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmIon_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmExtendedConst_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmExtendedConst_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmExceptions_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmExceptions_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmFunctionReferences_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmFunctionReferences_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmGc_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmGc_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmRelaxedSimd_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmRelaxedSimd_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmMemory64_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmMemory64_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmMozIntGemm_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmMozIntGemm_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmTestSerialization_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmTestSerialization_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn testWasmAwaitTier2_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_testWasmAwaitTier2_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn throwOnAsmJSValidationFailure_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_throwOnAsmJSValidationFailure_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn disableIon_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_disableIon_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn disableEvalSecurityChecks_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_disableEvalSecurityChecks_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn asyncStack_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asyncStack_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn asyncStackCaptureDebuggeeOnly_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asyncStackCaptureDebuggeeOnly_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn sourcePragmas_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_sourcePragmas_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn throwOnDebuggeeWouldRun_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_throwOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dumpStackOnDebuggeeWouldRun_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_dumpStackOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn strictMode_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_strictMode_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn fuzzing_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_fuzzing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn importAssertions_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_importAssertions_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                asmJS_: bool,
                wasm_: bool,
                wasmForTrustedPrinciples_: bool,
                wasmVerbose_: bool,
                wasmBaseline_: bool,
                wasmIon_: bool,
                wasmExtendedConst_: bool,
                wasmExceptions_: bool,
                wasmFunctionReferences_: bool,
                wasmGc_: bool,
                wasmRelaxedSimd_: bool,
                wasmMemory64_: bool,
                wasmMozIntGemm_: bool,
                wasmTestSerialization_: bool,
                testWasmAwaitTier2_: bool,
                throwOnAsmJSValidationFailure_: bool,
                disableIon_: bool,
                disableEvalSecurityChecks_: bool,
                asyncStack_: bool,
                asyncStackCaptureDebuggeeOnly_: bool,
                sourcePragmas_: bool,
                throwOnDebuggeeWouldRun_: bool,
                dumpStackOnDebuggeeWouldRun_: bool,
                strictMode_: bool,
                fuzzing_: bool,
                importAssertions_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let asmJS_: u8 = unsafe { ::std::mem::transmute(asmJS_) };
                    asmJS_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let wasm_: u8 = unsafe { ::std::mem::transmute(wasm_) };
                    wasm_ as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let wasmForTrustedPrinciples_: u8 =
                        unsafe { ::std::mem::transmute(wasmForTrustedPrinciples_) };
                    wasmForTrustedPrinciples_ as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let wasmVerbose_: u8 = unsafe { ::std::mem::transmute(wasmVerbose_) };
                    wasmVerbose_ as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let wasmBaseline_: u8 = unsafe { ::std::mem::transmute(wasmBaseline_) };
                    wasmBaseline_ as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let wasmIon_: u8 = unsafe { ::std::mem::transmute(wasmIon_) };
                    wasmIon_ as u64
                });
                __bindgen_bitfield_unit.set(6usize, 1u8, {
                    let wasmExtendedConst_: u8 =
                        unsafe { ::std::mem::transmute(wasmExtendedConst_) };
                    wasmExtendedConst_ as u64
                });
                __bindgen_bitfield_unit.set(7usize, 1u8, {
                    let wasmExceptions_: u8 = unsafe { ::std::mem::transmute(wasmExceptions_) };
                    wasmExceptions_ as u64
                });
                __bindgen_bitfield_unit.set(8usize, 1u8, {
                    let wasmFunctionReferences_: u8 =
                        unsafe { ::std::mem::transmute(wasmFunctionReferences_) };
                    wasmFunctionReferences_ as u64
                });
                __bindgen_bitfield_unit.set(9usize, 1u8, {
                    let wasmGc_: u8 = unsafe { ::std::mem::transmute(wasmGc_) };
                    wasmGc_ as u64
                });
                __bindgen_bitfield_unit.set(10usize, 1u8, {
                    let wasmRelaxedSimd_: u8 = unsafe { ::std::mem::transmute(wasmRelaxedSimd_) };
                    wasmRelaxedSimd_ as u64
                });
                __bindgen_bitfield_unit.set(11usize, 1u8, {
                    let wasmMemory64_: u8 = unsafe { ::std::mem::transmute(wasmMemory64_) };
                    wasmMemory64_ as u64
                });
                __bindgen_bitfield_unit.set(12usize, 1u8, {
                    let wasmMozIntGemm_: u8 = unsafe { ::std::mem::transmute(wasmMozIntGemm_) };
                    wasmMozIntGemm_ as u64
                });
                __bindgen_bitfield_unit.set(13usize, 1u8, {
                    let wasmTestSerialization_: u8 =
                        unsafe { ::std::mem::transmute(wasmTestSerialization_) };
                    wasmTestSerialization_ as u64
                });
                __bindgen_bitfield_unit.set(14usize, 1u8, {
                    let testWasmAwaitTier2_: u8 =
                        unsafe { ::std::mem::transmute(testWasmAwaitTier2_) };
                    testWasmAwaitTier2_ as u64
                });
                __bindgen_bitfield_unit.set(15usize, 1u8, {
                    let throwOnAsmJSValidationFailure_: u8 =
                        unsafe { ::std::mem::transmute(throwOnAsmJSValidationFailure_) };
                    throwOnAsmJSValidationFailure_ as u64
                });
                __bindgen_bitfield_unit.set(16usize, 1u8, {
                    let disableIon_: u8 = unsafe { ::std::mem::transmute(disableIon_) };
                    disableIon_ as u64
                });
                __bindgen_bitfield_unit.set(17usize, 1u8, {
                    let disableEvalSecurityChecks_: u8 =
                        unsafe { ::std::mem::transmute(disableEvalSecurityChecks_) };
                    disableEvalSecurityChecks_ as u64
                });
                __bindgen_bitfield_unit.set(18usize, 1u8, {
                    let asyncStack_: u8 = unsafe { ::std::mem::transmute(asyncStack_) };
                    asyncStack_ as u64
                });
                __bindgen_bitfield_unit.set(19usize, 1u8, {
                    let asyncStackCaptureDebuggeeOnly_: u8 =
                        unsafe { ::std::mem::transmute(asyncStackCaptureDebuggeeOnly_) };
                    asyncStackCaptureDebuggeeOnly_ as u64
                });
                __bindgen_bitfield_unit.set(20usize, 1u8, {
                    let sourcePragmas_: u8 = unsafe { ::std::mem::transmute(sourcePragmas_) };
                    sourcePragmas_ as u64
                });
                __bindgen_bitfield_unit.set(21usize, 1u8, {
                    let throwOnDebuggeeWouldRun_: u8 =
                        unsafe { ::std::mem::transmute(throwOnDebuggeeWouldRun_) };
                    throwOnDebuggeeWouldRun_ as u64
                });
                __bindgen_bitfield_unit.set(22usize, 1u8, {
                    let dumpStackOnDebuggeeWouldRun_: u8 =
                        unsafe { ::std::mem::transmute(dumpStackOnDebuggeeWouldRun_) };
                    dumpStackOnDebuggeeWouldRun_ as u64
                });
                __bindgen_bitfield_unit.set(23usize, 1u8, {
                    let strictMode_: u8 = unsafe { ::std::mem::transmute(strictMode_) };
                    strictMode_ as u64
                });
                __bindgen_bitfield_unit.set(24usize, 1u8, {
                    let fuzzing_: u8 = unsafe { ::std::mem::transmute(fuzzing_) };
                    fuzzing_ as u64
                });
                __bindgen_bitfield_unit.set(25usize, 1u8, {
                    let importAssertions_: u8 = unsafe { ::std::mem::transmute(importAssertions_) };
                    importAssertions_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17ContextOptionsRefEP9JSContext"]
            pub fn ContextOptionsRef(cx: *mut root::JSContext) -> *mut root::JS::ContextOptions;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ValueType {
            Double = 0,
            Int32 = 1,
            Boolean = 2,
            Undefined = 3,
            Null = 4,
            Magic = 5,
            String = 6,
            Symbol = 7,
            PrivateGCThing = 8,
            BigInt = 9,
            Object = 12,
        }
        #[doc = " [SMDOC] JS::Value type\n\n JS::Value is the interface for a single JavaScript Engine value.  A few\n general notes on JS::Value:\n\n - JS::Value has setX() and isX() members for X in\n\n     { Int32, Double, String, Symbol, BigInt, Boolean, Undefined, Null,\n       Object, Magic }\n\n   JS::Value also contains toX() for each of the non-singleton types.\n\n - Magic is a singleton type whose payload contains either a JSWhyMagic\n   \"reason\" for the magic value or a uint32_t value. By providing JSWhyMagic\n   values when creating and checking for magic values, it is possible to\n   assert, at runtime, that only magic values with the expected reason flow\n   through a particular value. For example, if cx->exception has a magic\n   value, the reason must be JS_GENERATOR_CLOSING.\n\n - The JS::Value operations are preferred.  The JSVAL_* operations remain for\n   compatibility; they may be removed at some point.  These operations mostly\n   provide similar functionality.  But there are a few key differences.  One\n   is that JS::Value gives null a separate type.\n   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,\n   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a\n   JSObject&.)  A convenience member Value::setObjectOrNull is provided.\n\n - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on\n   32-bit user code should avoid copying jsval/JS::Value as much as possible,\n   preferring to pass by const Value&.\n\n Spectre mitigations\n ===================\n To mitigate Spectre attacks, we do the following:\n\n - On 64-bit platforms, when unboxing a Value, we XOR the bits with the\n   expected type tag (instead of masking the payload bits). This guarantees\n   that toString, toObject, toSymbol will return an invalid pointer (because\n   some high bits will be set) when called on a Value with a different type\n   tag.\n\n - On 32-bit platforms,when unboxing an object/string/symbol Value, we use a\n   conditional move (not speculated) to zero the payload register if the type\n   doesn't match."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Value {
            pub asBits_: u64,
        }
        pub type Value_PayloadType = u64;
        #[test]
        fn bindgen_test_layout_Value() {
            const UNINIT: ::std::mem::MaybeUninit<Value> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Value>(),
                8usize,
                concat!("Size of: ", stringify!(Value))
            );
            assert_eq!(
                ::std::mem::align_of::<Value>(),
                8usize,
                concat!("Alignment of ", stringify!(Value))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).asBits_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Value),
                    "::",
                    stringify!(asBits_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25HeapValuePostWriteBarrierEPNS_5ValueERKS0_S3_"]
            pub fn HeapValuePostWriteBarrier(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22HeapValueWriteBarriersEPNS_5ValueERKS0_S3_"]
            pub fn HeapValueWriteBarriers(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_Value_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15NullHandleValueE"]
            pub static NullHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UndefinedHandleValueE"]
            pub static UndefinedHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15TrueHandleValueE"]
            pub static TrueHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[doc = " ES6 draft 20141224, 7.1.1, second algorithm.\n\n Most users shouldn't call this -- use JS::ToBoolean, ToNumber, or ToString\n instead.  This will typically only be called from custom convert hooks that\n wish to fall back to the ES6 default conversion behavior shared by most\n objects in JS, codified as OrdinaryToPrimitive."]
            #[link_name = "\u{1}_ZN2JS19OrdinaryToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn OrdinaryToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                type_: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store in |out| the null-terminated, base-10 result of |ToString| applied to\n |d| per <https://tc39.es/ecma262/#sec-tostring-applied-to-the-number-type>.\n (This will produce \"NaN\", \"-Infinity\", or \"Infinity\" for non-finite |d|.)"]
            #[link_name = "\u{1}_ZN2JS14NumberToStringEdRA32_c"]
            pub fn NumberToString(d: f64, out: *mut [::std::os::raw::c_char; 32usize]);
        }
        extern "C" {
            #[doc = " Re-query the system to determine the current time zone adjustment from UTC,\n including any component due to DST.  If the time zone has changed, this will\n cause all Date object non-UTC methods and formatting functions to produce\n appropriately adjusted results.\n\n Left to its own devices, SpiderMonkey itself may occasionally try to detect\n system time changes.  However, no particular frequency of checking is\n guaranteed.  Embedders unable to accept occasional inaccuracies should call\n this method in response to system time changes, or immediately before\n operations requiring instantaneous correctness, to guarantee correct\n behavior."]
            #[link_name = "\u{1}_ZN2JS13ResetTimeZoneEv"]
            pub fn ResetTimeZone();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClippedTime {
            pub t: f64,
        }
        #[test]
        fn bindgen_test_layout_ClippedTime() {
            const UNINIT: ::std::mem::MaybeUninit<ClippedTime> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClippedTime>(),
                8usize,
                concat!("Size of: ", stringify!(ClippedTime))
            );
            assert_eq!(
                ::std::mem::align_of::<ClippedTime>(),
                8usize,
                concat!("Alignment of ", stringify!(ClippedTime))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClippedTime),
                    "::",
                    stringify!(t)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextNS_11ClippedTimeE"]
            pub fn NewDateObject(
                cx: *mut root::JSContext,
                time: root::JS::ClippedTime,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new Date object for a year/month/day-of-month/hour/minute/second.\n\n The created date is initialized with the time value\n\n   TimeClip(UTC(MakeDate(MakeDay(year, mon, mday),\n                MakeTime(hour, min, sec, 0.0))))\n\n where each function/operation is as specified in ECMAScript."]
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextiiiiii"]
            pub fn NewDateObject1(
                cx: *mut root::JSContext,
                year: ::std::os::raw::c_int,
                mon: ::std::os::raw::c_int,
                mday: ::std::os::raw::c_int,
                hour: ::std::os::raw::c_int,
                min: ::std::os::raw::c_int,
                sec: ::std::os::raw::c_int,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isDate| to true if |obj| is a Date\n object or a wrapper around one, or to false if not.  Returns false on\n failure.\n\n This method returns true with |*isDate == false| when passed an ES6 proxy\n whose target is a Date, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS12ObjectIsDateEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsDate(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isDate: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjj"]
            pub fn MakeDate(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjjd"]
            pub fn MakeDate1(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
                time: f64,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12YearFromTimeEd"]
            pub fn YearFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13MonthFromTimeEd"]
            pub fn MonthFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11DayFromTimeEd"]
            pub fn DayFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11DayFromYearEd"]
            pub fn DayFromYear(year: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13DayWithinYearEdd"]
            pub fn DayWithinYear(time: f64, year: f64) -> f64;
        }
        pub type ReduceMicrosecondTimePrecisionCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: f64, arg2: *mut root::JSContext) -> f64,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS41SetReduceMicrosecondTimePrecisionCallbackEPFddP9JSContextE"]
            pub fn SetReduceMicrosecondTimePrecisionCallback(
                callback: root::JS::ReduceMicrosecondTimePrecisionCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21SetTimeResolutionUsecEjb"]
            pub fn SetTimeResolutionUsec(resolution: u32, jitter: bool);
        }
        extern "C" {
            #[doc = " Store |v1 === v2| to |*equal| -- strict equality, which performs no\n conversions on |v1| or |v2| before comparing.\n\n This operation can fail only if an internal error occurs (e.g. OOM while\n linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS13StrictlyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn StrictlyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store |v1 == v2| to |*equal| -- loose equality, which may perform\n user-modifiable conversions on |v1| or |v2|.\n\n This operation can fail if a user-modifiable conversion fails *or* if an\n internal error occurs. (e.g. OOM while linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS12LooselyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn LooselyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Stores |SameValue(v1, v2)| to |*equal| -- using the SameValue operation\n defined in ECMAScript, initially exposed to script as |Object.is|.  SameValue\n behaves identically to strict equality, except that it equates two NaN values\n and does not equate differently-signed zeroes.  It performs no conversions on\n |v1| or |v2| before comparing.\n\n This operation can fail only if an internal error occurs (e.g. OOM while\n linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS9SameValueEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn SameValue(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                same: *mut bool,
            ) -> bool;
        }
        #[doc = " A convenience class for imitating a JS for-of loop. Typical usage:\n\n     JS::ForOfIterator it(cx);\n     if (!it.init(iterable)) {\n       return false;\n     }\n     JS::Rooted<JS::Value> val(cx);\n     while (true) {\n       bool done;\n       if (!it.next(&val, &done)) {\n         return false;\n       }\n       if (done) {\n         break;\n       }\n       if (!DoStuff(cx, val)) {\n         return false;\n       }\n     }"]
        #[repr(C)]
        pub struct ForOfIterator {
            pub cx_: *mut root::JSContext,
            pub iterator: root::JS::Rooted<*mut root::JSObject>,
            pub nextMethod: root::JS::Rooted<root::JS::Value>,
            pub index: u32,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ForOfIterator_NonIterableBehavior {
            ThrowOnNonIterable = 0,
            AllowNonIterable = 1,
        }
        pub const ForOfIterator_NOT_ARRAY: u32 = 4294967295;
        #[test]
        fn bindgen_test_layout_ForOfIterator() {
            const UNINIT: ::std::mem::MaybeUninit<ForOfIterator> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ForOfIterator>(),
                64usize,
                concat!("Size of: ", stringify!(ForOfIterator))
            );
            assert_eq!(
                ::std::mem::align_of::<ForOfIterator>(),
                8usize,
                concat!("Alignment of ", stringify!(ForOfIterator))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).cx_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(cx_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).iterator) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(iterator)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).nextMethod) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(nextMethod)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(index)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyKey {
            pub asBits_: usize,
        }
        pub const PropertyKey_IntTagBit: usize = 1;
        pub const PropertyKey_StringTypeTag: usize = 0;
        pub const PropertyKey_VoidTypeTag: usize = 2;
        pub const PropertyKey_SymbolTypeTag: usize = 4;
        pub const PropertyKey_TypeMask: usize = 7;
        pub const PropertyKey_IntMin: u32 = 0;
        pub const PropertyKey_IntMax: u32 = 2147483647;
        #[test]
        fn bindgen_test_layout_PropertyKey() {
            const UNINIT: ::std::mem::MaybeUninit<PropertyKey> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PropertyKey>(),
                8usize,
                concat!("Size of: ", stringify!(PropertyKey))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyKey>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyKey))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).asBits_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyKey),
                    "::",
                    stringify!(asBits_)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_PropertyKey_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        extern "C" {
            #[doc = " Get one of the well-known symbols defined by ES6 as PropertyKey. This is\n equivalent to calling JS::GetWellKnownSymbol and then creating a PropertyKey.\n\n `which` must be in the range [0, WellKnownSymbolLimit)."]
            #[link_name = "\u{1}_ZN2JS21GetWellKnownSymbolKeyEP9JSContextNS_10SymbolCodeE"]
            pub fn GetWellKnownSymbolKey(
                cx: *mut root::JSContext,
                which: root::JS::SymbolCode,
            ) -> root::JS::PropertyKey;
        }
        #[doc = " Span - slices for C++\n\n Span implements Rust's slice concept for C++. It's called \"Span\" instead of\n \"Slice\" to follow the naming used in C++ Core Guidelines.\n\n A Span wraps a pointer and a length that identify a non-owning view to a\n contiguous block of memory of objects of the same type. Various types,\n including (pre-decay) C arrays, XPCOM strings, nsTArray, mozilla::Array,\n mozilla::Range and contiguous standard-library containers, auto-convert\n into Spans when attempting to pass them as arguments to methods that take\n Spans. (Span itself autoconverts into mozilla::Range.)\n\n Like Rust's slices, Span provides safety against out-of-bounds access by\n performing run-time bound checks. However, unlike Rust's slices, Span\n cannot provide safety against use-after-free.\n\n (Note: Span is like Rust's slice only conceptually. Due to the lack of\n ABI guarantees, you should still decompose spans/slices to raw pointer\n and length parts when crossing the FFI. The Elements() and data() methods\n are guaranteed to return a non-null pointer even for zero-length spans,\n so the pointer can be used as a raw part of a Rust slice without further\n checks.)\n\n In addition to having constructors (with the support of deduction guides)\n that take various well-known types, a Span for an arbitrary type can be\n constructed from a pointer and a length or a pointer and another pointer\n pointing just past the last element.\n\n A Span<const char> or Span<const char16_t> can be obtained for const char*\n or const char16_t pointing to a zero-terminated string using the\n MakeStringSpan() function (which treats a nullptr argument equivalently\n to the empty string). Corresponding implicit constructor does not exist\n in order to avoid accidental construction in cases where const char* or\n const char16_t* do not point to a zero-terminated string.\n\n Span has methods that follow the Mozilla naming style and methods that\n don't. The methods that follow the Mozilla naming style are meant to be\n used directly from Mozilla code. The methods that don't are meant for\n integration with C++11 range-based loops and with meta-programming that\n expects the same methods that are found on the standard-library\n containers. For example, to decompose a Span into its parts in Mozilla\n code, use Elements() and Length() (as with nsTArray) instead of data()\n and size() (as with std::vector).\n\n The pointer and length wrapped by a Span cannot be changed after a Span has\n been created. When new values are required, simply create a new Span. Span\n has a method called Subspan() that works analogously to the Substring()\n method of XPCOM strings taking a start index and an optional length. As a\n Mozilla extension (relative to Microsoft's gsl::span that mozilla::Span is\n based on), Span has methods From(start), To(end) and FromTo(start, end)\n that correspond to Rust's &slice[start..], &slice[..end] and\n &slice[start..end], respectively. (That is, the end index is the index of\n the first element not to be included in the new subspan.)\n\n When indicating a Span that's only read from, const goes inside the type\n parameter. Don't put const in front of Span. That is:\n size_t ReadsFromOneSpanAndWritesToAnother(Span<const uint8_t> aReadFrom,\n                                           Span<uint8_t> aWrittenTo);\n\n Any Span<const T> can be viewed as Span<const uint8_t> using the function\n AsBytes(). Any Span<T> can be viewed as Span<uint8_t> using the function\n AsWritableBytes().\n\n Note that iterators from different Span instances are uncomparable, even if\n they refer to the same memory. This also applies to any spans derived via\n Subspan etc."]
        pub type SelfHostedCache = [u32; 2usize];
        pub type SelfHostedWriter = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::SelfHostedCache,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18InitSelfHostedCodeEP9JSContextN7mozilla4SpanIKhLm4294967295EEEPFbS1_S5_E"]
            pub fn InitSelfHostedCode(
                cx: *mut root::JSContext,
                cache: root::JS::SelfHostedCache,
                writer: root::JS::SelfHostedWriter,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17DisableJitBackendEv"]
            pub fn DisableJitBackend();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13SetAVXEnabledEb"]
            pub fn SetAVXEnabled(enabled: bool);
        }
        extern "C" {
            #[doc = " An API akin to JS_Stringify but with the goal of not having observable\n side-effects when the stringification is performed.  This means it does not\n allow a replacer or a custom space and has the following constraints on its\n input:\n\n 1) The input must be a plain object or array, not an abitrary value.\n 2) Every value in the graph reached by the algorithm starting with this\n    object must be one of the following: null, undefined, a string (NOT a\n    string object!), a boolean, a finite number (i.e. no NaN or Infinity or\n    -Infinity), a plain object with no accessor properties, or an Array with\n    no holes.\n\n The actual behavior differs from JS_Stringify only in asserting the above and\n NOT attempting to get the \"toJSON\" property from things, since that could\n clearly have side-effects."]
            #[link_name = "\u{1}_ZN2JS17ToJSONMaybeSafelyEP9JSContextNS_6HandleIP8JSObjectEEPFbPKDsjPvES8_"]
            pub fn ToJSONMaybeSafely(
                cx: *mut root::JSContext,
                input: root::JS::Handle<*mut root::JSObject>,
                callback: root::JSONWriteCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TabSizes {
            pub objects_: usize,
            pub strings_: usize,
            pub private_: usize,
            pub other_: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TabSizes_Kind {
            Objects = 0,
            Strings = 1,
            Private = 2,
            Other = 3,
        }
        #[test]
        fn bindgen_test_layout_TabSizes() {
            const UNINIT: ::std::mem::MaybeUninit<TabSizes> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TabSizes>(),
                32usize,
                concat!("Size of: ", stringify!(TabSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<TabSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(TabSizes))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).objects_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(objects_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).strings_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(strings_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).private_) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(private_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).other_) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(other_)
                )
            );
        }
        #[doc = " These are the measurements used by Servo."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoSizes {
            pub gcHeapUsed: usize,
            pub gcHeapUnused: usize,
            pub gcHeapAdmin: usize,
            pub gcHeapDecommitted: usize,
            pub mallocHeap: usize,
            pub nonHeap: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ServoSizes_Kind {
            GCHeapUsed = 0,
            GCHeapUnused = 1,
            GCHeapAdmin = 2,
            GCHeapDecommitted = 3,
            MallocHeap = 4,
            NonHeap = 5,
            Ignore = 6,
        }
        #[test]
        fn bindgen_test_layout_ServoSizes() {
            const UNINIT: ::std::mem::MaybeUninit<ServoSizes> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ServoSizes>(),
                48usize,
                concat!("Size of: ", stringify!(ServoSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<ServoSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(ServoSizes))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapUsed) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapUsed)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapUnused) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapUnused)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapAdmin) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapAdmin)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapDecommitted) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapDecommitted)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mallocHeap) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(mallocHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).nonHeap) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(nonHeap)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClassInfo {
            pub objectsGCHeap: usize,
            pub objectsMallocHeapSlots: usize,
            pub objectsMallocHeapElementsNormal: usize,
            pub objectsMallocHeapElementsAsmJS: usize,
            pub objectsMallocHeapGlobalData: usize,
            pub objectsMallocHeapGlobalVarNamesSet: usize,
            pub objectsMallocHeapMisc: usize,
            pub objectsNonHeapElementsNormal: usize,
            pub objectsNonHeapElementsShared: usize,
            pub objectsNonHeapElementsWasm: usize,
            pub objectsNonHeapElementsWasmShared: usize,
            pub objectsNonHeapCodeWasm: usize,
        }
        #[test]
        fn bindgen_test_layout_ClassInfo() {
            const UNINIT: ::std::mem::MaybeUninit<ClassInfo> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClassInfo>(),
                96usize,
                concat!("Size of: ", stringify!(ClassInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ClassInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ClassInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).objectsGCHeap) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsMallocHeapSlots) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapSlots)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsMallocHeapElementsNormal) as usize
                        - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapElementsNormal)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsMallocHeapElementsAsmJS) as usize
                        - ptr as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapElementsAsmJS)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsMallocHeapGlobalData) as usize - ptr as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapGlobalData)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsMallocHeapGlobalVarNamesSet) as usize
                        - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapGlobalVarNamesSet)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsMallocHeapMisc) as usize - ptr as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapMisc)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsNonHeapElementsNormal) as usize
                        - ptr as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapElementsNormal)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsNonHeapElementsShared) as usize
                        - ptr as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapElementsShared)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsNonHeapElementsWasm) as usize - ptr as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapElementsWasm)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsNonHeapElementsWasmShared) as usize
                        - ptr as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapElementsWasmShared)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).objectsNonHeapCodeWasm) as usize - ptr as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapCodeWasm)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ShapeInfo {
            pub shapesGCHeapShared: usize,
            pub shapesGCHeapDict: usize,
            pub shapesGCHeapBase: usize,
            pub shapesMallocHeapCache: usize,
        }
        #[test]
        fn bindgen_test_layout_ShapeInfo() {
            const UNINIT: ::std::mem::MaybeUninit<ShapeInfo> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ShapeInfo>(),
                32usize,
                concat!("Size of: ", stringify!(ShapeInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ShapeInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ShapeInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).shapesGCHeapShared) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesGCHeapShared)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).shapesGCHeapDict) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesGCHeapDict)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).shapesGCHeapBase) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesGCHeapBase)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).shapesMallocHeapCache) as usize - ptr as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesMallocHeapCache)
                )
            );
        }
        #[doc = " Holds data about a notable class (one whose combined object and shape\n instances use more than a certain amount of memory) so we can report it\n individually.\n\n The only difference between this class and ClassInfo is that this class\n holds a copy of the filename."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotableClassInfo {
            pub _base: root::JS::ClassInfo,
            pub className_: root::JS::UniqueChars,
        }
        #[test]
        fn bindgen_test_layout_NotableClassInfo() {
            const UNINIT: ::std::mem::MaybeUninit<NotableClassInfo> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<NotableClassInfo>(),
                104usize,
                concat!("Size of: ", stringify!(NotableClassInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<NotableClassInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(NotableClassInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).className_) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableClassInfo),
                    "::",
                    stringify!(className_)
                )
            );
        }
        #[doc = " Data for tracking JIT-code memory usage."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CodeSizes {
            pub ion: usize,
            pub baseline: usize,
            pub regexp: usize,
            pub other: usize,
            pub unused: usize,
        }
        #[test]
        fn bindgen_test_layout_CodeSizes() {
            const UNINIT: ::std::mem::MaybeUninit<CodeSizes> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CodeSizes>(),
                40usize,
                concat!("Size of: ", stringify!(CodeSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<CodeSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(CodeSizes))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ion) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(ion)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).baseline) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(baseline)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).regexp) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(regexp)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).other) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(other)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(unused)
                )
            );
        }
        #[doc = " Data for tracking GC memory usage."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCSizes {
            pub marker: usize,
            pub nurseryCommitted: usize,
            pub nurseryMallocedBuffers: usize,
            pub storeBufferVals: usize,
            pub storeBufferCells: usize,
            pub storeBufferSlots: usize,
            pub storeBufferWholeCells: usize,
            pub storeBufferGenerics: usize,
        }
        #[test]
        fn bindgen_test_layout_GCSizes() {
            const UNINIT: ::std::mem::MaybeUninit<GCSizes> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GCSizes>(),
                64usize,
                concat!("Size of: ", stringify!(GCSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<GCSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(GCSizes))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(marker)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).nurseryCommitted) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(nurseryCommitted)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).nurseryMallocedBuffers) as usize - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(nurseryMallocedBuffers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).storeBufferVals) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferVals)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).storeBufferCells) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferCells)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).storeBufferSlots) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferSlots)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).storeBufferWholeCells) as usize - ptr as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferWholeCells)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).storeBufferGenerics) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferGenerics)
                )
            );
        }
        #[doc = " This class holds information about the memory taken up by identical copies of\n a particular string.  Multiple JSStrings may have their sizes aggregated\n together into one StringInfo object.  Note that two strings with identical\n chars will not be aggregated together if one is a short string and the other\n is not."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringInfo {
            pub gcHeapLatin1: usize,
            pub gcHeapTwoByte: usize,
            pub mallocHeapLatin1: usize,
            pub mallocHeapTwoByte: usize,
            pub numCopies: u32,
        }
        #[test]
        fn bindgen_test_layout_StringInfo() {
            const UNINIT: ::std::mem::MaybeUninit<StringInfo> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<StringInfo>(),
                40usize,
                concat!("Size of: ", stringify!(StringInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<StringInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(StringInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapLatin1) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(gcHeapLatin1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapTwoByte) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(gcHeapTwoByte)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mallocHeapLatin1) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(mallocHeapLatin1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mallocHeapTwoByte) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(mallocHeapTwoByte)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).numCopies) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(numCopies)
                )
            );
        }
        #[doc = " Holds data about a notable string (one which, counting all duplicates, uses\n more than a certain amount of memory) so we can report it individually.\n\n The only difference between this class and StringInfo is that\n NotableStringInfo holds a copy of some or all of the string's chars."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotableStringInfo {
            pub _base: root::JS::StringInfo,
            pub buffer: root::JS::UniqueChars,
            pub length: usize,
        }
        pub const NotableStringInfo_MAX_SAVED_CHARS: usize = 1024;
        #[test]
        fn bindgen_test_layout_NotableStringInfo() {
            const UNINIT: ::std::mem::MaybeUninit<NotableStringInfo> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<NotableStringInfo>(),
                56usize,
                concat!("Size of: ", stringify!(NotableStringInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<NotableStringInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(NotableStringInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableStringInfo),
                    "::",
                    stringify!(buffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableStringInfo),
                    "::",
                    stringify!(length)
                )
            );
        }
        #[doc = " This class holds information about the memory taken up by script sources\n from a particular file."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptSourceInfo {
            pub misc: usize,
            pub numScripts: u32,
        }
        #[test]
        fn bindgen_test_layout_ScriptSourceInfo() {
            const UNINIT: ::std::mem::MaybeUninit<ScriptSourceInfo> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ScriptSourceInfo>(),
                16usize,
                concat!("Size of: ", stringify!(ScriptSourceInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptSourceInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptSourceInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).misc) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptSourceInfo),
                    "::",
                    stringify!(misc)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).numScripts) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptSourceInfo),
                    "::",
                    stringify!(numScripts)
                )
            );
        }
        #[doc = " Holds data about a notable script source file (one whose combined\n script sources use more than a certain amount of memory) so we can report it\n individually.\n\n The only difference between this class and ScriptSourceInfo is that this\n class holds a copy of the filename."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotableScriptSourceInfo {
            pub _base: root::JS::ScriptSourceInfo,
            pub filename_: root::JS::UniqueChars,
        }
        #[test]
        fn bindgen_test_layout_NotableScriptSourceInfo() {
            const UNINIT: ::std::mem::MaybeUninit<NotableScriptSourceInfo> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<NotableScriptSourceInfo>(),
                24usize,
                concat!("Size of: ", stringify!(NotableScriptSourceInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<NotableScriptSourceInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(NotableScriptSourceInfo))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).filename_) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableScriptSourceInfo),
                    "::",
                    stringify!(filename_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HelperThreadStats {
            pub stateData: usize,
            pub parseTask: usize,
            pub ionCompileTask: usize,
            pub wasmCompile: usize,
            pub contexts: usize,
            pub idleThreadCount: ::std::os::raw::c_uint,
            pub activeThreadCount: ::std::os::raw::c_uint,
        }
        #[test]
        fn bindgen_test_layout_HelperThreadStats() {
            const UNINIT: ::std::mem::MaybeUninit<HelperThreadStats> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<HelperThreadStats>(),
                48usize,
                concat!("Size of: ", stringify!(HelperThreadStats))
            );
            assert_eq!(
                ::std::mem::align_of::<HelperThreadStats>(),
                8usize,
                concat!("Alignment of ", stringify!(HelperThreadStats))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).stateData) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(stateData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).parseTask) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(parseTask)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ionCompileTask) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(ionCompileTask)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).wasmCompile) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(wasmCompile)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).contexts) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(contexts)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).idleThreadCount) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(idleThreadCount)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).activeThreadCount) as usize - ptr as usize },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(activeThreadCount)
                )
            );
        }
        #[doc = " Measurements that not associated with any individual runtime."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GlobalStats {
            pub helperThread: root::JS::HelperThreadStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        #[test]
        fn bindgen_test_layout_GlobalStats() {
            const UNINIT: ::std::mem::MaybeUninit<GlobalStats> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GlobalStats>(),
                56usize,
                concat!("Size of: ", stringify!(GlobalStats))
            );
            assert_eq!(
                ::std::mem::align_of::<GlobalStats>(),
                8usize,
                concat!("Alignment of ", stringify!(GlobalStats))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).helperThread) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GlobalStats),
                    "::",
                    stringify!(helperThread)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mallocSizeOf_) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GlobalStats),
                    "::",
                    stringify!(mallocSizeOf_)
                )
            );
        }
        #[doc = " These measurements relate directly to the JSRuntime, and not to zones,\n compartments, and realms within it."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct RuntimeSizes {
            pub object: usize,
            pub atomsTable: usize,
            pub atomsMarkBitmaps: usize,
            pub selfHostStencil: usize,
            pub contexts: usize,
            pub temporary: usize,
            pub interpreterStack: usize,
            pub sharedImmutableStringsCache: usize,
            pub sharedIntlData: usize,
            pub uncompressedSourceCache: usize,
            pub scriptData: usize,
            pub wasmRuntime: usize,
            pub wasmGuardPages: usize,
            pub jitLazyLink: usize,
            pub scriptSourceInfo: root::JS::ScriptSourceInfo,
            pub gc: root::JS::GCSizes,
            pub allScriptSources: [u64; 4usize],
            pub notableScriptSources: [u64; 3usize],
        }
        pub type RuntimeSizes_ScriptSourcesHashMap = [u64; 3usize];
        #[test]
        fn bindgen_test_layout_RuntimeSizes() {
            const UNINIT: ::std::mem::MaybeUninit<RuntimeSizes> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RuntimeSizes>(),
                248usize,
                concat!("Size of: ", stringify!(RuntimeSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<RuntimeSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(RuntimeSizes))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(object)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).atomsTable) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(atomsTable)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).atomsMarkBitmaps) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(atomsMarkBitmaps)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).selfHostStencil) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(selfHostStencil)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).contexts) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(contexts)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).temporary) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(temporary)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).interpreterStack) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(interpreterStack)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).sharedImmutableStringsCache) as usize - ptr as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(sharedImmutableStringsCache)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sharedIntlData) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(sharedIntlData)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).uncompressedSourceCache) as usize - ptr as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(uncompressedSourceCache)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scriptData) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(scriptData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).wasmRuntime) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(wasmRuntime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).wasmGuardPages) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(wasmGuardPages)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).jitLazyLink) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(jitLazyLink)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scriptSourceInfo) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(scriptSourceInfo)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(gc)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).allScriptSources) as usize - ptr as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(allScriptSources)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).notableScriptSources) as usize - ptr as usize
                },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(notableScriptSources)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UnusedGCThingSizes {
            pub object: usize,
            pub script: usize,
            pub shape: usize,
            pub baseShape: usize,
            pub getterSetter: usize,
            pub propMap: usize,
            pub string: usize,
            pub symbol: usize,
            pub bigInt: usize,
            pub jitcode: usize,
            pub scope: usize,
            pub regExpShared: usize,
        }
        #[test]
        fn bindgen_test_layout_UnusedGCThingSizes() {
            const UNINIT: ::std::mem::MaybeUninit<UnusedGCThingSizes> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<UnusedGCThingSizes>(),
                96usize,
                concat!("Size of: ", stringify!(UnusedGCThingSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<UnusedGCThingSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(UnusedGCThingSizes))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(object)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).script) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(script)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(shape)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).baseShape) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(baseShape)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).getterSetter) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(getterSetter)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).propMap) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(propMap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(string)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).symbol) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(symbol)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).bigInt) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(bigInt)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).jitcode) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(jitcode)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scope) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(scope)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).regExpShared) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(regExpShared)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ZoneStats {
            pub symbolsGCHeap: usize,
            pub bigIntsGCHeap: usize,
            pub bigIntsMallocHeap: usize,
            pub gcHeapArenaAdmin: usize,
            pub jitCodesGCHeap: usize,
            pub getterSettersGCHeap: usize,
            pub compactPropMapsGCHeap: usize,
            pub normalPropMapsGCHeap: usize,
            pub dictPropMapsGCHeap: usize,
            pub propMapChildren: usize,
            pub propMapTables: usize,
            pub scopesGCHeap: usize,
            pub scopesMallocHeap: usize,
            pub regExpSharedsGCHeap: usize,
            pub regExpSharedsMallocHeap: usize,
            pub regexpZone: usize,
            pub jitZone: usize,
            pub baselineStubsOptimized: usize,
            pub uniqueIdMap: usize,
            pub initialPropMapTable: usize,
            pub shapeTables: usize,
            pub compartmentObjects: usize,
            pub crossCompartmentWrappersTables: usize,
            pub compartmentsPrivateData: usize,
            pub scriptCountsMap: usize,
            pub unusedGCThings: root::JS::UnusedGCThingSizes,
            pub stringInfo: root::JS::StringInfo,
            pub shapeInfo: root::JS::ShapeInfo,
            pub code: root::JS::CodeSizes,
            pub extra: *mut ::std::os::raw::c_void,
            pub allStrings: [u64; 4usize],
            pub notableStrings: [u64; 3usize],
            pub isTotals: bool,
        }
        pub type ZoneStats_StringsHashMap = [u64; 3usize];
        #[test]
        fn bindgen_test_layout_ZoneStats() {
            const UNINIT: ::std::mem::MaybeUninit<ZoneStats> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ZoneStats>(),
                480usize,
                concat!("Size of: ", stringify!(ZoneStats))
            );
            assert_eq!(
                ::std::mem::align_of::<ZoneStats>(),
                8usize,
                concat!("Alignment of ", stringify!(ZoneStats))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).symbolsGCHeap) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(symbolsGCHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).bigIntsGCHeap) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(bigIntsGCHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).bigIntsMallocHeap) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(bigIntsMallocHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapArenaAdmin) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(gcHeapArenaAdmin)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).jitCodesGCHeap) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(jitCodesGCHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).getterSettersGCHeap) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(getterSettersGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).compactPropMapsGCHeap) as usize - ptr as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(compactPropMapsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).normalPropMapsGCHeap) as usize - ptr as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(normalPropMapsGCHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).dictPropMapsGCHeap) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(dictPropMapsGCHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).propMapChildren) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(propMapChildren)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).propMapTables) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(propMapTables)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scopesGCHeap) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(scopesGCHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scopesMallocHeap) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(scopesMallocHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).regExpSharedsGCHeap) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(regExpSharedsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).regExpSharedsMallocHeap) as usize - ptr as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(regExpSharedsMallocHeap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).regexpZone) as usize - ptr as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(regexpZone)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).jitZone) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(jitZone)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).baselineStubsOptimized) as usize - ptr as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(baselineStubsOptimized)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).uniqueIdMap) as usize - ptr as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(uniqueIdMap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).initialPropMapTable) as usize - ptr as usize },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(initialPropMapTable)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).shapeTables) as usize - ptr as usize },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(shapeTables)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).compartmentObjects) as usize - ptr as usize },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(compartmentObjects)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).crossCompartmentWrappersTables) as usize
                        - ptr as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(crossCompartmentWrappersTables)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).compartmentsPrivateData) as usize - ptr as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(compartmentsPrivateData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scriptCountsMap) as usize - ptr as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(scriptCountsMap)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).unusedGCThings) as usize - ptr as usize },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(unusedGCThings)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).stringInfo) as usize - ptr as usize },
                296usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(stringInfo)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).shapeInfo) as usize - ptr as usize },
                336usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(shapeInfo)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
                368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(code)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
                408usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(extra)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).allStrings) as usize - ptr as usize },
                416usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(allStrings)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).notableStrings) as usize - ptr as usize },
                448usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(notableStrings)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isTotals) as usize - ptr as usize },
                472usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(isTotals)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RealmStats {
            pub objectsPrivate: usize,
            pub scriptsGCHeap: usize,
            pub scriptsMallocHeapData: usize,
            pub baselineData: usize,
            pub baselineStubsFallback: usize,
            pub ionData: usize,
            pub jitScripts: usize,
            pub realmObject: usize,
            pub realmTables: usize,
            pub innerViewsTable: usize,
            pub objectMetadataTable: usize,
            pub savedStacksSet: usize,
            pub nonSyntacticLexicalScopesTable: usize,
            pub jitRealm: usize,
            pub classInfo: root::JS::ClassInfo,
            pub extra: *mut ::std::os::raw::c_void,
            pub allClasses: [u64; 4usize],
            pub notableClasses: [u64; 3usize],
            pub isTotals: bool,
        }
        pub type RealmStats_ClassesHashMap = [u64; 3usize];
        #[test]
        fn bindgen_test_layout_RealmStats() {
            const UNINIT: ::std::mem::MaybeUninit<RealmStats> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RealmStats>(),
                280usize,
                concat!("Size of: ", stringify!(RealmStats))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmStats>(),
                8usize,
                concat!("Alignment of ", stringify!(RealmStats))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).objectsPrivate) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(objectsPrivate)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scriptsGCHeap) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(scriptsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).scriptsMallocHeapData) as usize - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(scriptsMallocHeapData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).baselineData) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(baselineData)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).baselineStubsFallback) as usize - ptr as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(baselineStubsFallback)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ionData) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(ionData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).jitScripts) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(jitScripts)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).realmObject) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(realmObject)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).realmTables) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(realmTables)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).innerViewsTable) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(innerViewsTable)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).objectMetadataTable) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(objectMetadataTable)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).savedStacksSet) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(savedStacksSet)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).nonSyntacticLexicalScopesTable) as usize
                        - ptr as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(nonSyntacticLexicalScopesTable)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).jitRealm) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(jitRealm)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).classInfo) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(classInfo)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(extra)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).allClasses) as usize - ptr as usize },
                216usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(allClasses)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).notableClasses) as usize - ptr as usize },
                248usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(notableClasses)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isTotals) as usize - ptr as usize },
                272usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(isTotals)
                )
            );
        }
        pub type RealmStatsVector = [u64; 3usize];
        pub type ZoneStatsVector = [u64; 3usize];
        #[repr(C)]
        pub struct RuntimeStats__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct RuntimeStats {
            pub vtable_: *const RuntimeStats__bindgen_vtable,
            pub gcHeapChunkTotal: usize,
            pub gcHeapDecommittedPages: usize,
            pub gcHeapUnusedChunks: usize,
            pub gcHeapUnusedArenas: usize,
            pub gcHeapChunkAdmin: usize,
            pub gcHeapGCThings: usize,
            pub runtime: root::JS::RuntimeSizes,
            pub realmTotals: root::JS::RealmStats,
            pub zTotals: root::JS::ZoneStats,
            pub realmStatsVector: root::JS::RealmStatsVector,
            pub zoneStatsVector: root::JS::ZoneStatsVector,
            pub currZoneStats: *mut root::JS::ZoneStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        #[test]
        fn bindgen_test_layout_RuntimeStats() {
            const UNINIT: ::std::mem::MaybeUninit<RuntimeStats> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RuntimeStats>(),
                1128usize,
                concat!("Size of: ", stringify!(RuntimeStats))
            );
            assert_eq!(
                ::std::mem::align_of::<RuntimeStats>(),
                8usize,
                concat!("Alignment of ", stringify!(RuntimeStats))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapChunkTotal) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapChunkTotal)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).gcHeapDecommittedPages) as usize - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapDecommittedPages)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapUnusedChunks) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapUnusedChunks)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapUnusedArenas) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapUnusedArenas)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapChunkAdmin) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapChunkAdmin)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcHeapGCThings) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapGCThings)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).runtime) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(runtime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).realmTotals) as usize - ptr as usize },
                304usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(realmTotals)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).zTotals) as usize - ptr as usize },
                584usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(zTotals)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).realmStatsVector) as usize - ptr as usize },
                1064usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(realmStatsVector)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).zoneStatsVector) as usize - ptr as usize },
                1088usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(zoneStatsVector)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).currZoneStats) as usize - ptr as usize },
                1112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(currZoneStats)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mallocSizeOf_) as usize - ptr as usize },
                1120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(mallocSizeOf_)
                )
            );
        }
        #[repr(C)]
        pub struct ObjectPrivateVisitor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectPrivateVisitor {
            pub vtable_: *const ObjectPrivateVisitor__bindgen_vtable,
            pub getISupports_: root::JS::ObjectPrivateVisitor_GetISupportsFun,
        }
        pub type ObjectPrivateVisitor_GetISupportsFun = ::std::option::Option<
            unsafe extern "C" fn(
                obj: *mut root::JSObject,
                iface: *mut *mut root::nsISupports,
            ) -> bool,
        >;
        #[test]
        fn bindgen_test_layout_ObjectPrivateVisitor() {
            const UNINIT: ::std::mem::MaybeUninit<ObjectPrivateVisitor> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ObjectPrivateVisitor>(),
                16usize,
                concat!("Size of: ", stringify!(ObjectPrivateVisitor))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectPrivateVisitor>(),
                8usize,
                concat!("Alignment of ", stringify!(ObjectPrivateVisitor))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).getISupports_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectPrivateVisitor),
                    "::",
                    stringify!(getISupports_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18CollectGlobalStatsEPNS_11GlobalStatsE"]
            pub fn CollectGlobalStats(gStats: *mut root::JS::GlobalStats) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19CollectRuntimeStatsEP9JSContextPNS_12RuntimeStatsEPNS_20ObjectPrivateVisitorEb"]
            pub fn CollectRuntimeStats(
                cx: *mut root::JSContext,
                rtStats: *mut root::JS::RuntimeStats,
                opv: *mut root::JS::ObjectPrivateVisitor,
                anonymize: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SystemCompartmentCountEP9JSContext"]
            pub fn SystemCompartmentCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UserCompartmentCountEP9JSContext"]
            pub fn UserCompartmentCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16SystemRealmCountEP9JSContext"]
            pub fn SystemRealmCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14UserRealmCountEP9JSContext"]
            pub fn UserRealmCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19PeakSizeOfTemporaryEPK9JSContext"]
            pub fn PeakSizeOfTemporary(cx: *const root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12AddSizeOfTabEP9JSContextNS_6HandleIP8JSObjectEEPFmPKvEPNS_20ObjectPrivateVisitorEPNS_8TabSizesE"]
            pub fn AddSizeOfTab(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::TabSizes,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14AddServoSizeOfEP9JSContextPFmPKvEPNS_20ObjectPrivateVisitorEPNS_10ServoSizesE"]
            pub fn AddServoSizeOf(
                cx: *mut root::JSContext,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::ServoSizes,
            ) -> bool;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AsmJSOption {
            Enabled = 0,
            DisabledByAsmJSPref = 1,
            DisabledByLinker = 2,
            DisabledByNoWasmCompiler = 3,
            DisabledByDebugger = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DelazificationOption {
            OnDemandOnly = 0,
            CheckConcurrentWithOnDemand = 1,
            ConcurrentDepthFirst = 2,
            ConcurrentLargeFirst = 3,
            ParseEverythingEagerly = 4,
        }
        #[doc = " The common base class for the CompileOptions hierarchy.\n\n Use this in code that needs to propagate compile options from one\n compilation unit to another."]
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct TransitiveCompileOptions {
            pub filename_: *const ::std::os::raw::c_char,
            pub introducerFilename_: *const ::std::os::raw::c_char,
            pub sourceMapURL_: *const u16,
            #[doc = " The Web Platform allows scripts to be loaded from arbitrary cross-origin\n sources. This allows an attack by which a malicious website loads a\n sensitive file (say, a bank statement) cross-origin (using the user's\n cookies), and sniffs the generated syntax errors (via a window.onerror\n handler) for juicy morsels of its contents.\n\n To counter this attack, HTML5 specifies that script errors should be\n sanitized (\"muted\") when the script is not same-origin with the global\n for which it is loaded. Callers should set this flag for cross-origin\n scripts, and it will be propagated appropriately to child scripts and\n passed back in JSErrorReports."]
            pub mutedErrors_: bool,
            pub forceStrictMode_: bool,
            pub sourcePragmas_: bool,
            pub skipFilenameValidation_: bool,
            pub hideScriptFromDebugger_: bool,
            pub deferDebugMetadata_: bool,
            pub eagerDelazificationStrategy_: root::JS::DelazificationOption,
            pub selfHostingMode: bool,
            pub asmJSOption: root::JS::AsmJSOption,
            pub throwOnAsmJSValidationFailureOption: bool,
            pub forceAsync: bool,
            pub discardSource: bool,
            pub sourceIsLazy: bool,
            pub allowHTMLComments: bool,
            pub nonSyntacticScope: bool,
            pub topLevelAwait: bool,
            pub useFdlibmForSinCosTan: bool,
            pub importAssertions: bool,
            pub borrowBuffer: bool,
            pub usePinnedBytecode: bool,
            pub allocateInstantiationStorage: bool,
            pub deoptimizeModuleGlobalVars: bool,
            #[doc = " |introductionType| is a statically allocated C string: one of \"eval\",\n \"Function\", or \"GeneratorFunction\"."]
            pub introductionType: *const ::std::os::raw::c_char,
            pub introductionLineno: ::std::os::raw::c_uint,
            pub introductionOffset: u32,
            pub hasIntroductionInfo: bool,
        }
        #[test]
        fn bindgen_test_layout_TransitiveCompileOptions() {
            const UNINIT: ::std::mem::MaybeUninit<TransitiveCompileOptions> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TransitiveCompileOptions>(),
                63usize,
                concat!("Size of: ", stringify!(TransitiveCompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<TransitiveCompileOptions>(),
                1usize,
                concat!("Alignment of ", stringify!(TransitiveCompileOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).filename_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(filename_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introducerFilename_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introducerFilename_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sourceMapURL_) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(sourceMapURL_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mutedErrors_) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(mutedErrors_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).forceStrictMode_) as usize - ptr as usize },
                25usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(forceStrictMode_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sourcePragmas_) as usize - ptr as usize },
                26usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(sourcePragmas_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).skipFilenameValidation_) as usize - ptr as usize
                },
                27usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(skipFilenameValidation_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).hideScriptFromDebugger_) as usize - ptr as usize
                },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(hideScriptFromDebugger_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).deferDebugMetadata_) as usize - ptr as usize },
                29usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(deferDebugMetadata_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).eagerDelazificationStrategy_) as usize
                        - ptr as usize
                },
                30usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(eagerDelazificationStrategy_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).selfHostingMode) as usize - ptr as usize },
                31usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(selfHostingMode)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).asmJSOption) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(asmJSOption)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).throwOnAsmJSValidationFailureOption) as usize
                        - ptr as usize
                },
                33usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(throwOnAsmJSValidationFailureOption)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).forceAsync) as usize - ptr as usize },
                34usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(forceAsync)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).discardSource) as usize - ptr as usize },
                35usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(discardSource)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sourceIsLazy) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(sourceIsLazy)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).allowHTMLComments) as usize - ptr as usize },
                37usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(allowHTMLComments)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).nonSyntacticScope) as usize - ptr as usize },
                38usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(nonSyntacticScope)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).topLevelAwait) as usize - ptr as usize },
                39usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(topLevelAwait)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).useFdlibmForSinCosTan) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(useFdlibmForSinCosTan)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).importAssertions) as usize - ptr as usize },
                41usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(importAssertions)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).borrowBuffer) as usize - ptr as usize },
                42usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(borrowBuffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).usePinnedBytecode) as usize - ptr as usize },
                43usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(usePinnedBytecode)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).allocateInstantiationStorage) as usize
                        - ptr as usize
                },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(allocateInstantiationStorage)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).deoptimizeModuleGlobalVars) as usize - ptr as usize
                },
                45usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(deoptimizeModuleGlobalVars)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introductionType) as usize - ptr as usize },
                46usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introductionType)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introductionLineno) as usize - ptr as usize },
                54usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introductionLineno)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introductionOffset) as usize - ptr as usize },
                58usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introductionOffset)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).hasIntroductionInfo) as usize - ptr as usize },
                62usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(hasIntroductionInfo)
                )
            );
        }
        #[doc = " The class representing a full set of compile options.\n\n Use this in code that only needs to access compilation options created\n elsewhere, like the compiler.  Don't instantiate this class (the constructor\n is protected anyway); instead, create instances only of the derived classes:\n CompileOptions and OwningCompileOptions."]
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct ReadOnlyCompileOptions {
            pub _base: root::JS::TransitiveCompileOptions,
            pub lineno: ::std::os::raw::c_uint,
            pub column: ::std::os::raw::c_uint,
            pub scriptSourceOffset: ::std::os::raw::c_uint,
            pub isRunOnce: bool,
            pub noScriptRval: bool,
        }
        #[test]
        fn bindgen_test_layout_ReadOnlyCompileOptions() {
            const UNINIT: ::std::mem::MaybeUninit<ReadOnlyCompileOptions> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ReadOnlyCompileOptions>(),
                77usize,
                concat!("Size of: ", stringify!(ReadOnlyCompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<ReadOnlyCompileOptions>(),
                1usize,
                concat!("Alignment of ", stringify!(ReadOnlyCompileOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize },
                63usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(lineno)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize },
                67usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(column)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scriptSourceOffset) as usize - ptr as usize },
                71usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(scriptSourceOffset)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isRunOnce) as usize - ptr as usize },
                75usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(isRunOnce)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).noScriptRval) as usize - ptr as usize },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(noScriptRval)
                )
            );
        }
        #[doc = " Compilation options, with dynamic lifetime. An instance of this type\n makes a copy of / holds / roots all dynamically allocated resources\n (principals; elements; strings) that it refers to. Its destructor frees\n / drops / unroots them. This is heavier than CompileOptions, below, but\n unlike CompileOptions, it can outlive any given stack frame.\n\n Note that this *roots* any JS values it refers to - they're live\n unconditionally. Thus, instances of this type can't be owned, directly\n or indirectly, by a JavaScript object: if any value that this roots ever\n comes to refer to the object that owns this, then the whole cycle, and\n anything else it entrains, will never be freed."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct OwningCompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
        }
        #[test]
        fn bindgen_test_layout_OwningCompileOptions() {
            assert_eq!(
                ::std::mem::size_of::<OwningCompileOptions>(),
                77usize,
                concat!("Size of: ", stringify!(OwningCompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<OwningCompileOptions>(),
                1usize,
                concat!("Alignment of ", stringify!(OwningCompileOptions))
            );
        }
        #[doc = " Compilation options stored on the stack. An instance of this type\n simply holds references to dynamically allocated resources (element;\n filename; source map URL) that are owned by something else. If you\n create an instance of this type, it's up to you to guarantee that\n everything you store in it will outlive it."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
        }
        #[test]
        fn bindgen_test_layout_CompileOptions() {
            assert_eq!(
                ::std::mem::size_of::<CompileOptions>(),
                77usize,
                concat!("Size of: ", stringify!(CompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<CompileOptions>(),
                1usize,
                concat!("Alignment of ", stringify!(CompileOptions))
            );
        }
        #[doc = " Subset of CompileOptions fields used while instantiating Stencils."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InstantiateOptions {
            pub skipFilenameValidation: bool,
            pub hideScriptFromDebugger: bool,
            pub deferDebugMetadata: bool,
        }
        #[test]
        fn bindgen_test_layout_InstantiateOptions() {
            const UNINIT: ::std::mem::MaybeUninit<InstantiateOptions> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<InstantiateOptions>(),
                3usize,
                concat!("Size of: ", stringify!(InstantiateOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<InstantiateOptions>(),
                1usize,
                concat!("Alignment of ", stringify!(InstantiateOptions))
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).skipFilenameValidation) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InstantiateOptions),
                    "::",
                    stringify!(skipFilenameValidation)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).hideScriptFromDebugger) as usize - ptr as usize
                },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InstantiateOptions),
                    "::",
                    stringify!(hideScriptFromDebugger)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).deferDebugMetadata) as usize - ptr as usize },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InstantiateOptions),
                    "::",
                    stringify!(deferDebugMetadata)
                )
            );
        }
        #[doc = " Subset of CompileOptions fields used while decoding Stencils."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DecodeOptions {
            pub borrowBuffer: bool,
            pub usePinnedBytecode: bool,
            pub allocateInstantiationStorage: bool,
            pub forceAsync: bool,
            pub introducerFilename: *const ::std::os::raw::c_char,
            pub introductionType: *const ::std::os::raw::c_char,
            pub introductionLineno: ::std::os::raw::c_uint,
            pub introductionOffset: u32,
        }
        #[test]
        fn bindgen_test_layout_DecodeOptions() {
            const UNINIT: ::std::mem::MaybeUninit<DecodeOptions> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<DecodeOptions>(),
                32usize,
                concat!("Size of: ", stringify!(DecodeOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<DecodeOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(DecodeOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).borrowBuffer) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(borrowBuffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).usePinnedBytecode) as usize - ptr as usize },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(usePinnedBytecode)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).allocateInstantiationStorage) as usize
                        - ptr as usize
                },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(allocateInstantiationStorage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).forceAsync) as usize - ptr as usize },
                3usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(forceAsync)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introducerFilename) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(introducerFilename)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introductionType) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(introductionType)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introductionLineno) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(introductionLineno)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).introductionOffset) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DecodeOptions),
                    "::",
                    stringify!(introductionOffset)
                )
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ImportAssertion {
            Type = 0,
        }
        pub type ImportAssertionVector = u8;
        #[doc = " The HostGetSupportedImportAssertions hook.\n\n See:\n https://tc39.es/proposal-import-assertions/#sec-hostgetsupportedimportassertions\n\n Get the list of supported import assertions."]
        pub type SupportedAssertionsHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                values: *mut root::JS::ImportAssertionVector,
            ) -> bool,
        >;
        extern "C" {
            #[doc = " Get the HostGetSupportedImportAssertions hook for the runtime."]
            #[link_name = "\u{1}_ZN2JS26GetSupportedAssertionsHookEP9JSRuntime"]
            pub fn GetSupportedAssertionsHook(
                rt: *mut root::JSRuntime,
            ) -> root::JS::SupportedAssertionsHook;
        }
        extern "C" {
            #[doc = " Set the HostGetSupportedImportAssertions hook for the runtime to the given\n function."]
            #[link_name = "\u{1}_ZN2JS26SetSupportedAssertionsHookEP9JSRuntimePFbP9JSContextRN7mozilla6VectorINS_15ImportAssertionELm1EN2js17SystemAllocPolicyEEEE"]
            pub fn SetSupportedAssertionsHook(
                rt: *mut root::JSRuntime,
                func: root::JS::SupportedAssertionsHook,
            );
        }
        #[doc = " The HostResolveImportedModule hook.\n\n See: https://tc39.es/ecma262/#sec-hostresolveimportedmodule\n\n This embedding-defined hook is used to implement module loading. It is called\n to get or create a module object corresponding to |moduleRequest| occurring\n in the context of the script or module with private value\n |referencingPrivate|.\n\n The module specifier string for the request can be obtained by calling\n JS::GetModuleRequestSpecifier.\n\n The private value for a script or module is set with JS::SetScriptPrivate or\n JS::SetModulePrivate. It's assumed that the embedding can handle receiving\n either here.\n\n This hook must obey the restrictions defined in the spec:\n  - Each time the hook is called with the same arguemnts, the same module must\n    be returned.\n  - If a module cannot be created for the given arguments, an exception must\n    be thrown.\n\n This is a synchronous operation."]
        pub type ModuleResolveHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject,
        >;
        extern "C" {
            #[doc = " Get the HostResolveImportedModule hook for the runtime."]
            #[link_name = "\u{1}_ZN2JS20GetModuleResolveHookEP9JSRuntime"]
            pub fn GetModuleResolveHook(rt: *mut root::JSRuntime) -> root::JS::ModuleResolveHook;
        }
        extern "C" {
            #[doc = " Set the HostResolveImportedModule hook for the runtime to the given function."]
            #[link_name = "\u{1}_ZN2JS20SetModuleResolveHookEP9JSRuntimePFP8JSObjectP9JSContextNS_6HandleINS_5ValueEEENS6_IS3_EEE"]
            pub fn SetModuleResolveHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleResolveHook,
            );
        }
        #[doc = " The module metadata hook.\n\n See: https://tc39.es/ecma262/#sec-hostgetimportmetaproperties\n\n Populate the |metaObject| object returned when import.meta is evaluated in\n the context of the script or module with private value |privateValue|.\n\n This is based on the spec's HostGetImportMetaProperties hook but defines\n properties on the meta object directly rather than returning a list."]
        pub type ModuleMetadataHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                privateValue: root::JS::Handle<root::JS::Value>,
                metaObject: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        extern "C" {
            #[doc = " Get the hook for populating the import.meta metadata object."]
            #[link_name = "\u{1}_ZN2JS21GetModuleMetadataHookEP9JSRuntime"]
            pub fn GetModuleMetadataHook(rt: *mut root::JSRuntime) -> root::JS::ModuleMetadataHook;
        }
        extern "C" {
            #[doc = " Set the hook for populating the import.meta metadata object to the given\n function."]
            #[link_name = "\u{1}_ZN2JS21SetModuleMetadataHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSObjectEEE"]
            pub fn SetModuleMetadataHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleMetadataHook,
            );
        }
        #[doc = " The HostImportModuleDynamically hook.\n\n See https://tc39.es/ecma262/#sec-hostimportmoduledynamically\n\n Used to implement dynamic module import. Called when evaluating import()\n expressions.\n\n This starts an asynchronous operation. Some time after this hook is called\n the embedding must call JS::FinishDynamicModuleImport() passing the\n |referencingPrivate|, |moduleRequest| and |promise| arguments from the\n call. This must happen for both success and failure cases.\n\n In the meantime the embedding can take whatever steps it needs to make the\n module available. If successful, after calling FinishDynamicModuleImport()\n the module should be returned by the resolve hook when passed\n |referencingPrivate| and |moduleRequest|."]
        pub type ModuleDynamicImportHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        extern "C" {
            #[doc = " Get the HostImportModuleDynamically hook for the runtime."]
            #[link_name = "\u{1}_ZN2JS26GetModuleDynamicImportHookEP9JSRuntime"]
            pub fn GetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
            ) -> root::JS::ModuleDynamicImportHook;
        }
        extern "C" {
            #[doc = " Set the HostImportModuleDynamically hook for the runtime to the given\n function.\n\n If this hook is not set (or set to nullptr) then the JS engine will throw an\n exception if dynamic module import is attempted."]
            #[link_name = "\u{1}_ZN2JS26SetModuleDynamicImportHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSObjectEES9_E"]
            pub fn SetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleDynamicImportHook,
            );
        }
        extern "C" {
            #[doc = " This must be called after a dynamic import operation is complete.\n\n If |evaluationPromise| is rejected, the rejection reason will be used to\n complete the user's promise."]
            #[link_name = "\u{1}_ZN2JS25FinishDynamicModuleImportEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES5_S5_"]
            pub fn FinishDynamicModuleImport(
                cx: *mut root::JSContext,
                evaluationPromise: root::JS::Handle<*mut root::JSObject>,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a module in the scope of the current global\n of cx and return a source text module record."]
            #[link_name = "\u{1}_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileModule(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a module in the scope of the current global\n of cx and return a source text module record.  An error is reported if a\n UTF-8 encoding error is encountered."]
            #[link_name = "\u{1}_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileModule1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Set a private value associated with a source text module record."]
            #[link_name = "\u{1}_ZN2JS16SetModulePrivateEP8JSObjectRKNS_5ValueE"]
            pub fn SetModulePrivate(module: *mut root::JSObject, value: *const root::JS::Value);
        }
        extern "C" {
            #[doc = " Get the private value associated with a source text module record."]
            #[link_name = "\u{1}_ZN2JS16GetModulePrivateEP8JSObject"]
            pub fn GetModulePrivate(module: *mut root::JSObject) -> root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10ModuleLinkEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ModuleLink(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14ModuleEvaluateEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn ModuleEvaluate(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ModuleErrorBehaviour {
            ReportModuleErrorsAsync = 0,
            ThrowModuleErrorsSync = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30ThrowOnModuleEvaluationFailureEP9JSContextNS_6HandleIP8JSObjectEENS_20ModuleErrorBehaviourE"]
            pub fn ThrowOnModuleEvaluationFailure(
                cx: *mut root::JSContext,
                evaluationPromise: root::JS::Handle<*mut root::JSObject>,
                errorBehaviour: root::JS::ModuleErrorBehaviour,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19GetRequestedModulesEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRequestedModules(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSpecifierEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn GetRequestedModuleSpecifier(
                cx: *mut root::JSContext,
                requestedModuleObject: root::JS::Handle<root::JS::Value>,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSourcePosEP9JSContextNS_6HandleINS_5ValueEEEPjS5_"]
            pub fn GetRequestedModuleSourcePos(
                cx: *mut root::JSContext,
                requestedModuleObject: root::JS::Handle<root::JS::Value>,
                lineNumber: *mut u32,
                columnNumber: *mut u32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetModuleScriptENS_6HandleIP8JSObjectEE"]
            pub fn GetModuleScript(
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19CreateModuleRequestEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn CreateModuleRequest(
                cx: *mut root::JSContext,
                specifierArg: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetModuleRequestSpecifierEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleRequestSpecifier(
                cx: *mut root::JSContext,
                moduleRequestArg: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetModuleObjectENS_6HandleIP8JSScriptEE"]
            pub fn GetModuleObject(
                moduleScript: root::JS::Handle<*mut root::JSScript>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetModuleNamespaceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleNamespace(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetModuleForNamespaceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleForNamespace(
                cx: *mut root::JSContext,
                moduleNamespace: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetModuleEnvironmentEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleEnvironment(
                cx: *mut root::JSContext,
                moduleObj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22ClearModuleEnvironmentEP8JSObject"]
            pub fn ClearModuleEnvironment(moduleObj: *mut root::JSObject);
        }
        #[doc = " Per ES6, the [[DefineOwnProperty]] internal method has three different\n possible outcomes:\n\n -   It can throw an exception (which we indicate by returning false).\n\n -   It can return true, indicating unvarnished success.\n\n -   It can return false, indicating \"strict failure\". The property could\n     not be defined. It's an error, but no exception was thrown.\n\n It's not just [[DefineOwnProperty]]: all the mutating internal methods have\n the same three outcomes. (The other affected internal methods are [[Set]],\n [[Delete]], [[SetPrototypeOf]], and [[PreventExtensions]].)\n\n If you think this design is awful, you're not alone.  But as it's the\n standard, we must represent these boolean \"success\" values somehow.\n ObjectOpSuccess is the class for this. It's like a bool, but when it's false\n it also stores an error code.\n\n Typical usage:\n\n     ObjectOpResult result;\n     if (!DefineProperty(cx, obj, id, ..., result)) {\n         return false;\n     }\n     if (!result) {\n         return result.reportError(cx, obj, id);\n     }\n\n Users don't have to call `result.report()`; another possible ending is:\n\n     argv.rval().setBoolean(result.ok());\n     return true;"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectOpResult {
            #[doc = " code_ is either one of the special codes OkCode or Uninitialized, or an\n error code. For now the error codes are JS friend API and are defined in\n js/public/friend/ErrorNumbers.msg.\n\n code_ is uintptr_t (rather than uint32_t) for the convenience of the\n JITs, which would otherwise have to deal with either padding or stack\n alignment on 64-bit platforms."]
            pub code_: usize,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ObjectOpResult_SpecialCodes {
            OkCode = 0,
            Uninitialized = 18446744073709551615,
        }
        #[test]
        fn bindgen_test_layout_ObjectOpResult() {
            const UNINIT: ::std::mem::MaybeUninit<ObjectOpResult> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ObjectOpResult>(),
                8usize,
                concat!("Size of: ", stringify!(ObjectOpResult))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectOpResult>(),
                8usize,
                concat!("Alignment of ", stringify!(ObjectOpResult))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).code_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOpResult),
                    "::",
                    stringify!(code_)
                )
            );
        }
        extern "C" {
            #[doc = " Determine the ECMAScript \"class\" -- Date, String, RegExp, and all the other\n builtin object types (described in ECMAScript in terms of an objecting having\n \"an [[ArrayBufferData]] internal slot\" or similar language for other kinds of\n object -- of the provided object.\n\n If this function is passed a wrapper that can be unwrapped, the determination\n is performed on that object.  If the wrapper can't be unwrapped, and it's not\n a wrapper that prefers to treat this operation as a failure, this function\n will indicate that the object is |js::ESClass::Other|."]
            #[link_name = "\u{1}_ZN2JS15GetBuiltinClassEP9JSContextNS_6HandleIP8JSObjectEEPN2js7ESClassE"]
            pub fn GetBuiltinClass(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                cls: *mut root::js::ESClass,
            ) -> bool;
        }
        #[repr(C)]
        pub struct JobQueue__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Abstract base class for an ECMAScript Job Queue:\n https://www.ecma-international.org/ecma-262/9.0/index.html#sec-jobs-and-job-queues\n\n SpiderMonkey doesn't schedule Promise resolution jobs itself; instead, the\n embedding can provide an instance of this class SpiderMonkey can use to do\n that scheduling.\n\n The JavaScript shell includes a simple implementation adequate for running\n tests. Browsers need to augment job handling to meet their own additional\n requirements, so they can provide their own implementation."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct JobQueue {
            pub vtable_: *const JobQueue__bindgen_vtable,
        }
        #[repr(C)]
        pub struct JobQueue_SavedJobQueue__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " A saved job queue, represented however the JobQueue implementation pleases.\n Use AutoDebuggerJobQueueInterruption rather than trying to construct one of\n these directly; see documentation there.\n\n Destructing an instance of this class should assert that the current queue\n is empty, and then restore the queue the instance captured."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct JobQueue_SavedJobQueue {
            pub vtable_: *const JobQueue_SavedJobQueue__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_JobQueue_SavedJobQueue() {
            assert_eq!(
                ::std::mem::size_of::<JobQueue_SavedJobQueue>(),
                8usize,
                concat!("Size of: ", stringify!(JobQueue_SavedJobQueue))
            );
            assert_eq!(
                ::std::mem::align_of::<JobQueue_SavedJobQueue>(),
                8usize,
                concat!("Alignment of ", stringify!(JobQueue_SavedJobQueue))
            );
        }
        #[test]
        fn bindgen_test_layout_JobQueue() {
            assert_eq!(
                ::std::mem::size_of::<JobQueue>(),
                8usize,
                concat!("Size of: ", stringify!(JobQueue))
            );
            assert_eq!(
                ::std::mem::align_of::<JobQueue>(),
                8usize,
                concat!("Alignment of ", stringify!(JobQueue))
            );
        }
        extern "C" {
            #[doc = " Tell SpiderMonkey to use `queue` to schedule promise reactions.\n\n SpiderMonkey does not take ownership of the queue; it is the embedding's\n responsibility to clean it up after the runtime is destroyed."]
            #[link_name = "\u{1}_ZN2JS11SetJobQueueEP9JSContextPNS_8JobQueueE"]
            pub fn SetJobQueue(cx: *mut root::JSContext, queue: *mut root::JS::JobQueue);
        }
        #[doc = " [SMDOC] Protecting the debuggee's job/microtask queue from debugger activity.\n\n When the JavaScript debugger interrupts the execution of some debuggee code\n (for a breakpoint, for example), the debuggee's execution must be paused\n while the developer takes time to look at it. During this interruption, other\n tabs should remain active and usable. If the debuggee shares a main thread\n with non-debuggee tabs, that means that the thread will have to process\n non-debuggee HTML tasks and microtasks as usual, even as the debuggee's are\n on hold until the debugger lets it continue execution. (Letting debuggee\n microtasks run during the interruption would mean that, from the debuggee's\n point of view, their side effects would take place wherever the breakpoint\n was set - in general, not a place other code should ever run, and a violation\n of the run-to-completion rule.)\n\n This means that, even though the timing and ordering of microtasks is\n carefully specified by the standard - and important to preserve for\n compatibility and predictability - debugger use may, correctly, have the\n effect of reordering microtasks. During the interruption, microtasks enqueued\n by non-debuggee tabs must run immediately alongside their HTML tasks as\n usual, whereas any debuggee microtasks that were in the queue when the\n interruption began must wait for the debuggee to be continued - and thus run\n after microtasks enqueued after they were.\n\n Fortunately, this reordering is visible only at the global level: when\n implemented correctly, it is not detectable by an individual debuggee. Note\n that a debuggee should generally be a complete unit of similar-origin related\n browsing contexts. Since non-debuggee activity falls outside that unit, it\n should never be visible to the debuggee (except via mechanisms that are\n already asynchronous, like events), so the debuggee should be unable to\n detect non-debuggee microtasks running when they normally would not. As long\n as behavior *visible to the debuggee* is unaffected by the interruption, we\n have respected the spirit of the rule.\n\n Of course, even as we accept the general principle that interrupting the\n debuggee should have as little detectable effect as possible, we still permit\n the developer to do things like evaluate expressions at the console that have\n arbitrary effects on the debuggee's state—effects that could never occur\n naturally at that point in the program. But since these are explicitly\n requested by the developer, who presumably knows what they're doing, we\n support this as best we can. If the developer evaluates an expression in the\n console that resolves a promise, it seems most natural for the promise's\n reaction microtasks to run immediately, within the interruption. This is an\n 'unnatural' time for the microtasks to run, but no more unnatural than the\n evaluation that triggered them.\n\n So the overall behavior we need is as follows:\n\n - When the debugger interrupts a debuggee, the debuggee's microtask queue\n   must be saved.\n\n - When debuggee execution resumes, the debuggee's microtask queue must be\n   restored exactly as it was when the interruption occurred.\n\n - Non-debuggee task and microtask execution must take place normally during\n   the interruption.\n\n Since each HTML task begins with an empty microtask queue, and it should not\n be possible for a task to mix debuggee and non-debuggee code, interrupting a\n debuggee should always find a microtask queue containing exclusively debuggee\n microtasks, if any. So saving and restoring the microtask queue should affect\n only the debuggee, not any non-debuggee content.\n\n AutoDebuggerJobQueueInterruption\n --------------------------------\n\n AutoDebuggerJobQueueInterruption is an RAII class, meant for use by the\n Debugger API implementation, that takes care of saving and restoring the\n queue.\n\n Constructing and initializing an instance of AutoDebuggerJobQueueInterruption\n sets aside the given JSContext's job queue, leaving the JSContext's queue\n empty. When the AutoDebuggerJobQueueInterruption instance is destroyed, it\n asserts that the JSContext's current job queue (holding jobs enqueued while\n the AutoDebuggerJobQueueInterruption was alive) is empty, and restores the\n saved queue to the JSContext.\n\n Since the Debugger API's behavior is up to us, we can specify that Debugger\n hooks begin execution with an empty job queue, and that we drain the queue\n after each hook function has run. This drain will be visible to debugger\n hooks, and makes hook calls resemble HTML tasks, with their own automatic\n microtask checkpoint. But, the drain will be invisible to the debuggee, as\n its queue is preserved across the hook invocation.\n\n To protect the debuggee's job queue, Debugger takes care to invoke callback\n functions only within the scope of an AutoDebuggerJobQueueInterruption\n instance.\n\n Why not let the hook functions themselves take care of this?\n ------------------------------------------------------------\n\n Certainly, we could leave responsibility for saving and restoring the job\n queue to the Debugger hook functions themselves.\n\n In fact, early versions of this change tried making the devtools server save\n and restore the queue explicitly, but because hooks are set and changed in\n numerous places, it was hard to be confident that every case had been\n covered, and it seemed that future changes could easily introduce new holes.\n\n Later versions of this change modified the accessor properties on the\n Debugger objects' prototypes to automatically protect the job queue when\n calling hooks, but the effect was essentially a monkeypatch applied to an API\n we defined and control, which doesn't make sense.\n\n In the end, since promises have become such a pervasive part of JavaScript\n programming, almost any imaginable use of Debugger would need to provide some\n kind of protection for the debuggee's job queue, so it makes sense to simply\n handle it once, carefully, in the implementation of Debugger itself."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoDebuggerJobQueueInterruption {
            pub cx: *mut root::JSContext,
            pub saved: u64,
        }
        #[test]
        fn bindgen_test_layout_AutoDebuggerJobQueueInterruption() {
            const UNINIT: ::std::mem::MaybeUninit<AutoDebuggerJobQueueInterruption> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoDebuggerJobQueueInterruption>(),
                16usize,
                concat!("Size of: ", stringify!(AutoDebuggerJobQueueInterruption))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoDebuggerJobQueueInterruption>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(AutoDebuggerJobQueueInterruption)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoDebuggerJobQueueInterruption),
                    "::",
                    stringify!(cx)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).saved) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoDebuggerJobQueueInterruption),
                    "::",
                    stringify!(saved)
                )
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseRejectionHandlingState {
            Unhandled = 0,
            Handled = 1,
        }
        pub type PromiseRejectionTrackerCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                mutedErrors: bool,
                promise: root::JS::HandleObject,
                state: root::JS::PromiseRejectionHandlingState,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[doc = " Sets the callback that's invoked whenever a Promise is rejected without\n a rejection handler, and when a Promise that was previously rejected\n without a handler gets a handler attached."]
            #[link_name = "\u{1}_ZN2JS34SetPromiseRejectionTrackerCallbackEP9JSContextPFvS1_bNS_6HandleIP8JSObjectEENS_29PromiseRejectionHandlingStateEPvES7_"]
            pub fn SetPromiseRejectionTrackerCallback(
                cx: *mut root::JSContext,
                callback: root::JS::PromiseRejectionTrackerCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Inform the runtime that the job queue is empty and the embedding is going to\n execute its last promise job. The runtime may now choose to skip creating\n promise jobs for asynchronous execution and instead continue execution\n synchronously. More specifically, this optimization is used to skip the\n standard job queuing behavior for `await` operations in async functions.\n\n This function may be called before executing the last job in the job queue.\n When it was called, JobQueueMayNotBeEmpty must be called in order to restore\n the default job queuing behavior before the embedding enqueues its next job\n into the job queue."]
            #[link_name = "\u{1}_ZN2JS15JobQueueIsEmptyEP9JSContext"]
            pub fn JobQueueIsEmpty(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Inform the runtime that job queue is no longer empty. The runtime can now no\n longer skip creating promise jobs for asynchronous execution, because\n pending jobs in the job queue must be executed first to preserve the FIFO\n (first in - first out) property of the queue. This effectively undoes\n JobQueueIsEmpty and re-enables the standard job queuing behavior.\n\n This function must be called whenever enqueuing a job to the job queue when\n JobQueueIsEmpty was called previously."]
            #[link_name = "\u{1}_ZN2JS21JobQueueMayNotBeEmptyEP9JSContext"]
            pub fn JobQueueMayNotBeEmpty(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns a new instance of the Promise builtin class in the current\n compartment, with the right slot layout.\n\n The `executor` can be a `nullptr`. In that case, the only way to resolve or\n reject the returned promise is via the `JS::ResolvePromise` and\n `JS::RejectPromise` JSAPI functions."]
            #[link_name = "\u{1}_ZN2JS16NewPromiseObjectEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn NewPromiseObject(
                cx: *mut root::JSContext,
                executor: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns true if the given object is an unwrapped PromiseObject, false\n otherwise."]
            #[link_name = "\u{1}_ZN2JS15IsPromiseObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsPromiseObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns the current compartment's original Promise constructor."]
            #[link_name = "\u{1}_ZN2JS21GetPromiseConstructorEP9JSContext"]
            pub fn GetPromiseConstructor(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns the current compartment's original Promise.prototype."]
            #[link_name = "\u{1}_ZN2JS19GetPromisePrototypeEP9JSContext"]
            pub fn GetPromisePrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseState {
            Pending = 0,
            Fulfilled = 1,
            Rejected = 2,
        }
        extern "C" {
            #[doc = " Returns the given Promise's state as a JS::PromiseState enum value.\n\n Returns JS::PromiseState::Pending if the given object is a wrapper that\n can't safely be unwrapped."]
            #[link_name = "\u{1}_ZN2JS15GetPromiseStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseState(promise: root::JS::HandleObject) -> root::JS::PromiseState;
        }
        extern "C" {
            #[doc = " Returns the given Promise's process-unique ID."]
            #[link_name = "\u{1}_ZN2JS12GetPromiseIDENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseID(promise: root::JS::HandleObject) -> u64;
        }
        extern "C" {
            #[doc = " Returns the given Promise's result: either the resolution value for\n fulfilled promises, or the rejection reason for rejected ones."]
            #[link_name = "\u{1}_ZN2JS16GetPromiseResultENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseResult(promise: root::JS::HandleObject) -> root::JS::Value;
        }
        extern "C" {
            #[doc = " Returns whether the given promise's rejection is already handled or not.\n\n The caller must check the given promise is rejected before checking it's\n handled or not."]
            #[link_name = "\u{1}_ZN2JS19GetPromiseIsHandledENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseIsHandled(promise: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26SetSettledPromiseIsHandledEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetSettledPromiseIsHandled(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SetAnyPromiseIsHandledEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetAnyPromiseIsHandled(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns a js::SavedFrame linked list of the stack that lead to the given\n Promise's allocation."]
            #[link_name = "\u{1}_ZN2JS24GetPromiseAllocationSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseAllocationSite(promise: root::JS::HandleObject)
                -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetPromiseResolutionSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseResolutionSite(promise: root::JS::HandleObject)
                -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Calls the current compartment's original Promise.resolve on the original\n Promise constructor, with `resolutionValue` passed as an argument."]
            #[link_name = "\u{1}_ZN2JS26CallOriginalPromiseResolveEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseResolve(
                cx: *mut root::JSContext,
                resolutionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Calls the current compartment's original Promise.reject on the original\n Promise constructor, with `resolutionValue` passed as an argument."]
            #[link_name = "\u{1}_ZN2JS25CallOriginalPromiseRejectEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseReject(
                cx: *mut root::JSContext,
                rejectionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Resolves the given Promise with the given `resolutionValue`.\n\n Calls the `resolve` function that was passed to the executor function when\n the Promise was created."]
            #[link_name = "\u{1}_ZN2JS14ResolvePromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ResolvePromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                resolutionValue: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Rejects the given `promise` with the given `rejectionValue`.\n\n Calls the `reject` function that was passed to the executor function when\n the Promise was created."]
            #[link_name = "\u{1}_ZN2JS13RejectPromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn RejectPromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                rejectionValue: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a Promise with the given fulfill/reject handlers, that will be\n fulfilled/rejected with the value/reason that the promise `promise` is\n fulfilled/rejected with.\n\n This function basically acts like `promise.then(onFulfilled, onRejected)`,\n except that its behavior is unaffected by changes to `Promise`,\n `Promise[Symbol.species]`, `Promise.prototype.then`, `promise.constructor`,\n `promise.then`, and so on.\n\n This function throws if `promise` is not a Promise from this or another\n realm.\n\n This function will assert if `onFulfilled` or `onRejected` is non-null and\n also not IsCallable."]
            #[link_name = "\u{1}_ZN2JS23CallOriginalPromiseThenEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn CallOriginalPromiseThen(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Unforgeable, optimized version of the JS builtin Promise.prototype.then.\n\n Takes a Promise instance and nullable `onFulfilled`/`onRejected` callables to\n enqueue as reactions for that promise. In contrast to Promise.prototype.then,\n this doesn't create and return a new Promise instance.\n\n Throws a TypeError if `promise` isn't a Promise (or possibly a different\n error if it's a security wrapper or dead object proxy)."]
            #[link_name = "\u{1}_ZN2JS19AddPromiseReactionsEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn AddPromiseReactions(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Unforgeable, optimized version of the JS builtin Promise.prototype.then.\n\n Takes a Promise instance and nullable `onFulfilled`/`onRejected` callables to\n enqueue as reactions for that promise. In contrast to Promise.prototype.then,\n this doesn't create and return a new Promise instance.\n\n Throws a TypeError if `promise` isn't a Promise (or possibly a different\n error if it's a security wrapper or dead object proxy).\n\n If `onRejected` is null and `promise` is rejected, this function -- unlike\n the function above -- will not report an unhandled rejection."]
            #[link_name = "\u{1}_ZN2JS45AddPromiseReactionsIgnoringUnhandledRejectionEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn AddPromiseReactionsIgnoringUnhandledRejection(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseUserInputEventHandlingState {
            DontCare = 0,
            HadUserInteractionAtCreation = 1,
            DidntHaveUserInteractionAtCreation = 2,
        }
        extern "C" {
            #[doc = " Returns the given Promise's activation behavior state flag per above as a\n JS::PromiseUserInputEventHandlingState value.  All promises are created with\n the DontCare state by default.\n\n Returns JS::PromiseUserInputEventHandlingState::DontCare if the given object\n is a wrapper that can't safely be unwrapped."]
            #[link_name = "\u{1}_ZN2JS37GetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
            ) -> root::JS::PromiseUserInputEventHandlingState;
        }
        extern "C" {
            #[doc = " Sets the given Promise's activation behavior state flag per above as a\n JS::PromiseUserInputEventHandlingState value.\n\n Returns false if the given object is a wrapper that can't safely be\n unwrapped."]
            #[link_name = "\u{1}_ZN2JS37SetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEENS_34PromiseUserInputEventHandlingStateE"]
            pub fn SetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
                state: root::JS::PromiseUserInputEventHandlingState,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Unforgeable version of the JS builtin Promise.all.\n\n Takes a HandleObjectVector of Promise objects and returns a promise that's\n resolved with an array of resolution values when all those promises have\n been resolved, or rejected with the rejection value of the first rejected\n promise.\n\n Asserts that all objects in the `promises` vector are, maybe wrapped,\n instances of `Promise` or a subclass of `Promise`."]
            #[link_name = "\u{1}_ZN2JS20GetWaitForAllPromiseEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEE"]
            pub fn GetWaitForAllPromise(
                cx: *mut root::JSContext,
                promises: root::JS::HandleObjectVector,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        pub struct Dispatchable__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The Dispatchable interface allows the embedding to call SpiderMonkey\n on a JSContext thread when requested via DispatchToEventLoopCallback."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct Dispatchable {
            pub vtable_: *const Dispatchable__bindgen_vtable,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Dispatchable_MaybeShuttingDown {
            NotShuttingDown = 0,
            ShuttingDown = 1,
        }
        #[test]
        fn bindgen_test_layout_Dispatchable() {
            assert_eq!(
                ::std::mem::size_of::<Dispatchable>(),
                8usize,
                concat!("Size of: ", stringify!(Dispatchable))
            );
            assert_eq!(
                ::std::mem::align_of::<Dispatchable>(),
                8usize,
                concat!("Alignment of ", stringify!(Dispatchable))
            );
        }
        #[doc = " Callback to dispatch a JS::Dispatchable to a JSContext's thread's event loop.\n\n The DispatchToEventLoopCallback set on a particular JSContext must accept\n JS::Dispatchable instances and arrange for their `run` methods to be called\n eventually on the JSContext's thread. This is used for cross-thread dispatch,\n so the callback itself must be safe to call from any thread.\n\n If the callback returns `true`, it must eventually run the given\n Dispatchable; otherwise, SpiderMonkey may leak memory or hang.\n\n The callback may return `false` to indicate that the JSContext's thread is\n shutting down and is no longer accepting runnables. Shutting down is a\n one-way transition: once the callback has rejected a runnable, it must reject\n all subsequently submitted runnables as well.\n\n To establish a DispatchToEventLoopCallback, the embedding may either call\n InitDispatchToEventLoop to provide its own, or call js::UseInternalJobQueues\n to select a default implementation built into SpiderMonkey. This latter\n depends on the embedding to call js::RunJobs on the JavaScript thread to\n process queued Dispatchables at appropriate times."]
        pub type DispatchToEventLoopCallback = ::std::option::Option<
            unsafe extern "C" fn(
                closure: *mut ::std::os::raw::c_void,
                dispatchable: *mut root::JS::Dispatchable,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23InitDispatchToEventLoopEP9JSContextPFbPvPNS_12DispatchableEES2_"]
            pub fn InitDispatchToEventLoop(
                cx: *mut root::JSContext,
                callback: root::JS::DispatchToEventLoopCallback,
                closure: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " When a JSRuntime is destroyed it implicitly cancels all async tasks in\n progress, releasing any roots held by the task. However, this is not soon\n enough for cycle collection, which needs to have roots dropped earlier so\n that the cycle collector can transitively remove roots for a future GC. For\n these and other cases, the set of pending async tasks can be canceled\n with this call earlier than JSRuntime destruction."]
            #[link_name = "\u{1}_ZN2JS18ShutdownAsyncTasksEP9JSContext"]
            pub fn ShutdownAsyncTasks(cx: *mut root::JSContext);
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PropertyAttribute {
            Configurable = 0,
            Enumerable = 1,
            Writable = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyAttributes {
            pub _base: root::mozilla::EnumSet<::std::os::raw::c_uchar>,
        }
        #[test]
        fn bindgen_test_layout_PropertyAttributes() {
            assert_eq!(
                ::std::mem::size_of::<PropertyAttributes>(),
                1usize,
                concat!("Size of: ", stringify!(PropertyAttributes))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyAttributes>(),
                1usize,
                concat!("Alignment of ", stringify!(PropertyAttributes))
            );
        }
        #[doc = " A structure that represents a property on an object, or the absence of a\n property.  Use {,Mutable}Handle<PropertyDescriptor> to interact with\n instances of this structure rather than interacting directly with member\n fields."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyDescriptor {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize]>,
            pub getter_: *mut root::JSObject,
            pub setter_: *mut root::JSObject,
            pub value_: root::JS::Value,
        }
        #[test]
        fn bindgen_test_layout_PropertyDescriptor() {
            const UNINIT: ::std::mem::MaybeUninit<PropertyDescriptor> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PropertyDescriptor>(),
                32usize,
                concat!("Size of: ", stringify!(PropertyDescriptor))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyDescriptor>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyDescriptor))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).getter_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(getter_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).setter_) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(setter_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).value_) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(value_)
                )
            );
        }
        impl PropertyDescriptor {
            #[inline]
            pub fn hasConfigurable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasConfigurable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn configurable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_configurable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasEnumerable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasEnumerable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn enumerable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_enumerable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasWritable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasWritable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn writable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_writable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasValue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasValue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasGetter_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasGetter_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasSetter_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasSetter_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn resolving_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_resolving_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                hasConfigurable_: bool,
                configurable_: bool,
                hasEnumerable_: bool,
                enumerable_: bool,
                hasWritable_: bool,
                writable_: bool,
                hasValue_: bool,
                hasGetter_: bool,
                hasSetter_: bool,
                resolving_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 2usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let hasConfigurable_: u8 = unsafe { ::std::mem::transmute(hasConfigurable_) };
                    hasConfigurable_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let configurable_: u8 = unsafe { ::std::mem::transmute(configurable_) };
                    configurable_ as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let hasEnumerable_: u8 = unsafe { ::std::mem::transmute(hasEnumerable_) };
                    hasEnumerable_ as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let enumerable_: u8 = unsafe { ::std::mem::transmute(enumerable_) };
                    enumerable_ as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let hasWritable_: u8 = unsafe { ::std::mem::transmute(hasWritable_) };
                    hasWritable_ as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let writable_: u8 = unsafe { ::std::mem::transmute(writable_) };
                    writable_ as u64
                });
                __bindgen_bitfield_unit.set(6usize, 1u8, {
                    let hasValue_: u8 = unsafe { ::std::mem::transmute(hasValue_) };
                    hasValue_ as u64
                });
                __bindgen_bitfield_unit.set(7usize, 1u8, {
                    let hasGetter_: u8 = unsafe { ::std::mem::transmute(hasGetter_) };
                    hasGetter_ as u64
                });
                __bindgen_bitfield_unit.set(8usize, 1u8, {
                    let hasSetter_: u8 = unsafe { ::std::mem::transmute(hasSetter_) };
                    hasSetter_ as u64
                });
                __bindgen_bitfield_unit.set(9usize, 1u8, {
                    let resolving_: u8 = unsafe { ::std::mem::transmute(resolving_) };
                    resolving_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34ObjectToCompletePropertyDescriptorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleINS_18PropertyDescriptorEEE"]
            pub fn ObjectToCompletePropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                descriptor: root::JS::Handle<root::JS::Value>,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a new Symbol with the given description. This function never returns\n a Symbol that is in the Runtime-wide symbol registry.\n\n If description is null, the new Symbol's [[Description]] attribute is\n undefined."]
            #[link_name = "\u{1}_ZN2JS9NewSymbolEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn NewSymbol(
                cx: *mut root::JSContext,
                description: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
        }
        extern "C" {
            #[doc = " Symbol.for as specified in ES6.\n\n Get a Symbol with the description 'key' from the Runtime-wide symbol\n registry. If there is not already a Symbol with that description in the\n registry, a new Symbol is created and registered. 'key' must not be null."]
            #[link_name = "\u{1}_ZN2JS12GetSymbolForEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn GetSymbolFor(
                cx: *mut root::JSContext,
                key: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
        }
        extern "C" {
            #[doc = " Get the [[Description]] attribute of the given symbol.\n\n This function is infallible. If it returns null, that means the symbol's\n [[Description]] is undefined."]
            #[link_name = "\u{1}_ZN2JS20GetSymbolDescriptionENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolDescription(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> *mut root::JSString;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SymbolCode {
            isConcatSpreadable = 0,
            iterator = 1,
            match_ = 2,
            replace = 3,
            search = 4,
            species = 5,
            hasInstance = 6,
            split = 7,
            toPrimitive = 8,
            toStringTag = 9,
            unscopables = 10,
            asyncIterator = 11,
            matchAll = 12,
            Limit = 13,
            WellKnownAPILimit = 2147483648,
            PrivateNameSymbol = 4294967293,
            InSymbolRegistry = 4294967294,
            UniqueSymbol = 4294967295,
        }
        extern "C" {
            #[doc = " Return the SymbolCode telling what sort of symbol `symbol` is.\n\n A symbol's SymbolCode never changes once it is created."]
            #[link_name = "\u{1}_ZN2JS13GetSymbolCodeENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolCode(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> root::JS::SymbolCode;
        }
        extern "C" {
            #[doc = " Get one of the well-known symbols defined by ES6. A single set of well-known\n symbols is shared by all compartments in a JSRuntime.\n\n `which` must be in the range [0, WellKnownSymbolLimit)."]
            #[link_name = "\u{1}_ZN2JS18GetWellKnownSymbolEP9JSContextNS_10SymbolCodeE"]
            pub fn GetWellKnownSymbol(
                cx: *mut root::JSContext,
                which: root::JS::SymbolCode,
            ) -> *mut root::JS::Symbol;
        }
        extern "C" {
            #[doc = " Create an Array from the current realm with the given contents."]
            #[link_name = "\u{1}_ZN2JS14NewArrayObjectEP9JSContextRKNS_16HandleValueArrayE"]
            pub fn NewArrayObject(
                cx: *mut root::JSContext,
                contents: *const root::JS::HandleValueArray,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create an Array from the current realm with the given length and allocate\n memory for all its elements.  (The elements nonetheless will not exist as\n properties on the returned array until values have been assigned to them.)"]
            #[link_name = "\u{1}_ZN2JS14NewArrayObjectEP9JSContextm"]
            pub fn NewArrayObject1(cx: *mut root::JSContext, length: usize) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Determine whether |value| is an Array object or a wrapper around one.  (An\n ES6 proxy whose target is an Array object, e.g.\n |var target = [], handler = {}; Proxy.revocable(target, handler).proxy|, is\n not considered to be an Array.)\n\n On success set |*isArray| accordingly and return true; on failure return\n false."]
            #[link_name = "\u{1}_ZN2JS13IsArrayObjectEP9JSContextNS_6HandleINS_5ValueEEEPb"]
            pub fn IsArrayObject(
                cx: *mut root::JSContext,
                value: root::JS::Handle<root::JS::Value>,
                isArray: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Determine whether |obj| is an Array object or a wrapper around one.  (An\n ES6 proxy whose target is an Array object, e.g.\n |var target = [], handler = {}; Proxy.revocable(target, handler).proxy|, is\n not considered to be an Array.)\n\n On success set |*isArray| accordingly and return true; on failure return\n false."]
            #[link_name = "\u{1}_ZN2JS13IsArrayObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsArrayObject1(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isArray: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store |*lengthp = ToLength(obj.length)| and return true on success, else\n return false.\n\n If the length does not fit in |uint32_t|, an exception is reported and false\n is returned.\n\n |ToLength| converts its input to an integer usable to index an\n array-like object.\n\n If |obj| is an Array, this overall operation is the same as getting\n |obj.length|."]
            #[link_name = "\u{1}_ZN2JS14GetArrayLengthEP9JSContextNS_6HandleIP8JSObjectEEPj"]
            pub fn GetArrayLength(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                lengthp: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Perform |obj.length = length| as if in strict mode code, with a fast path for\n the case where |obj| is an Array.\n\n This operation is exactly and only assigning to a \"length\" property.  In\n general, it can invoke an existing \"length\" setter, throw if the property is\n non-writable, or do anything else a property-set operation might do."]
            #[link_name = "\u{1}_ZN2JS14SetArrayLengthEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn SetArrayLength(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                length: u32,
            ) -> bool;
        }
        #[repr(i32)]
        #[doc = " The answer to a successful query as to whether an object is an Array per\n ES6's internal |IsArray| operation (as exposed by |Array.isArray|)."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum IsArrayAnswer {
            Array = 0,
            NotArray = 1,
            RevokedProxy = 2,
        }
        extern "C" {
            #[doc = " ES6 7.2.2.\n\n Returns false on failure, otherwise returns true and sets |*isArray|\n indicating whether the object passes ECMAScript's IsArray test.  This is the\n same test performed by |Array.isArray|.\n\n This is NOT the same as asking whether |obj| is an Array or a wrapper around\n one.  If |obj| is a proxy created by |Proxy.revocable()| and has been\n revoked, or if |obj| is a proxy whose target (at any number of hops) is a\n revoked proxy, this method throws a TypeError and returns false."]
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsArray(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isArray: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Identical to IsArray above, but the nature of the object (if successfully\n determined) is communicated via |*answer|.  In particular this method\n returns true and sets |*answer = IsArrayAnswer::RevokedProxy| when called on\n a revoked proxy.\n\n Most users will want the overload above, not this one."]
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPNS_13IsArrayAnswerE"]
            pub fn IsArray1(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                answer: *mut root::JS::IsArrayAnswer,
            ) -> bool;
        }
        pub type IsAcceptableThis =
            ::std::option::Option<unsafe extern "C" fn(v: root::JS::HandleValue) -> bool>;
        pub type NativeImpl = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, args: *const root::JS::CallArgs) -> bool,
        >;
        #[doc = " Regular expression flag values, suitable for initializing a collection of\n regular expression flags as defined below in |RegExpFlags|.  Flags are listed\n in alphabetical order by syntax -- /d, /g, /i, /m, /s, /u, /y."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpFlag {
            pub _address: u8,
        }
        #[doc = " Add .indices property to the match result, i.e. /d"]
        pub const RegExpFlag_HasIndices: u8 = 64;
        #[doc = " Act globally and find *all* matches (rather than stopping after just the\n first one), i.e. /g."]
        pub const RegExpFlag_Global: u8 = 2;
        #[doc = " Interpret regular expression source text case-insensitively by folding\n uppercase letters to lowercase, i.e. /i."]
        pub const RegExpFlag_IgnoreCase: u8 = 1;
        #[doc = " Treat ^ and $ as begin and end of line, i.e. /m."]
        pub const RegExpFlag_Multiline: u8 = 4;
        pub const RegExpFlag_DotAll: u8 = 32;
        #[doc = " Use Unicode semantics, i.e. /u."]
        pub const RegExpFlag_Unicode: u8 = 16;
        #[doc = " Only match starting from <regular expression>.lastIndex, i.e. /y."]
        pub const RegExpFlag_Sticky: u8 = 8;
        #[doc = " No regular expression flags."]
        pub const RegExpFlag_NoFlags: u8 = 0;
        #[doc = " All regular expression flags."]
        pub const RegExpFlag_AllFlags: u8 = 127;
        #[test]
        fn bindgen_test_layout_RegExpFlag() {
            assert_eq!(
                ::std::mem::size_of::<RegExpFlag>(),
                1usize,
                concat!("Size of: ", stringify!(RegExpFlag))
            );
            assert_eq!(
                ::std::mem::align_of::<RegExpFlag>(),
                1usize,
                concat!("Alignment of ", stringify!(RegExpFlag))
            );
        }
        #[doc = " A collection of regular expression flags.  Individual flag values may be\n combined into a collection using bitwise operators."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpFlags {
            pub flags_: root::JS::RegExpFlags_Flag,
        }
        pub type RegExpFlags_Flag = u8;
        #[test]
        fn bindgen_test_layout_RegExpFlags() {
            const UNINIT: ::std::mem::MaybeUninit<RegExpFlags> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RegExpFlags>(),
                1usize,
                concat!("Size of: ", stringify!(RegExpFlags))
            );
            assert_eq!(
                ::std::mem::align_of::<RegExpFlags>(),
                1usize,
                concat!("Alignment of ", stringify!(RegExpFlags))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).flags_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RegExpFlags),
                    "::",
                    stringify!(flags_)
                )
            );
        }
        extern "C" {
            #[doc = " Create a new RegExp for the given Latin-1-encoded bytes and flags."]
            #[link_name = "\u{1}_ZN2JS15NewRegExpObjectEP9JSContextPKcmNS_11RegExpFlagsE"]
            pub fn NewRegExpObject(
                cx: *mut root::JSContext,
                bytes: *const ::std::os::raw::c_char,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new RegExp for the given source and flags."]
            #[link_name = "\u{1}_ZN2JS17NewUCRegExpObjectEP9JSContextPKDsmNS_11RegExpFlagsE"]
            pub fn NewUCRegExpObject(
                cx: *mut root::JSContext,
                chars: *const u16,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14SetRegExpInputEP9JSContextNS_6HandleIP8JSObjectEENS2_IP8JSStringEE"]
            pub fn SetRegExpInput(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                input: root::JS::Handle<*mut root::JSString>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18ClearRegExpStaticsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ClearRegExpStatics(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a regexp on a given input, starting from |indexp|.\n Returns false on OOM or over-recursion.\n\n On no match, |rval| is set to Null.\n On a match, |indexp| and the RegExp statics are updated.\n Then, if |test| is true, |rval| is set to true.\n Otherwise, |rval| is set to a match result object."]
            #[link_name = "\u{1}_ZN2JS13ExecuteRegExpEP9JSContextNS_6HandleIP8JSObjectEES5_PKDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *const u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a regexp on a given input, starting from |indexp|.\n This is the same as ExecuteRegExp, except it does not update the RegExp\n statics and can be called without a global object."]
            #[link_name = "\u{1}_ZN2JS22ExecuteRegExpNoStaticsEP9JSContextNS_6HandleIP8JSObjectEEPKDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExpNoStatics(
                cx: *mut root::JSContext,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *const u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isRegExp| to true if |obj| is a RegExp\n object or a wrapper around one, or to false if not.  Returns false on\n failure.\n\n This method returns true with |*isRegExp == false| when passed an ES6 proxy\n whose target is a RegExp, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS14ObjectIsRegExpEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isRegExp: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Given a RegExp object (or a wrapper around one), return the set of all\n JS::RegExpFlag::* for it."]
            #[link_name = "\u{1}_ZN2JS14GetRegExpFlagsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRegExpFlags(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> root::JS::RegExpFlags;
        }
        extern "C" {
            #[doc = " Return the source text for a RegExp object (or a wrapper around one), or null\n on failure."]
            #[link_name = "\u{1}_ZN2JS15GetRegExpSourceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRegExpSource(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Check whether the given source is a valid regexp. If the regexp parses\n successfully, returns true and sets |error| to undefined. If the regexp\n has a syntax error, returns true, sets |error| to that error object, and\n clears the exception. Returns false on OOM or over-recursion."]
            #[link_name = "\u{1}_ZN2JS17CheckRegExpSyntaxEP9JSContextPKDsmNS_11RegExpFlagsENS_13MutableHandleINS_5ValueEEE"]
            pub fn CheckRegExpSyntax(
                cx: *mut root::JSContext,
                chars: *const u16,
                length: usize,
                flags: root::JS::RegExpFlags,
                error: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SavedFrameResult {
            Ok = 0,
            AccessDenied = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SavedFrameSelfHosted {
            Include = 0,
            Exclude = 1,
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its source property. Defaults to the empty\n string."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameSourceEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSource(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourcep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get an ID identifying its ScriptSource.\n Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS21GetSavedFrameSourceIdEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSourceId(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourceIdp: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its line property. Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS17GetSavedFrameLineEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameLine(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                linep: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its column property. Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameColumnEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameColumn(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                columnp: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its functionDisplayName string, or nullptr\n if SpiderMonkey was unable to infer a name for the captured frame's\n function. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS32GetSavedFrameFunctionDisplayNameEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameFunctionDisplayName(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                namep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its asyncCause string. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS23GetSavedFrameAsyncCauseEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncCause(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncCausep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its asyncParent SavedFrame object or nullptr\n if there is no asyncParent. The `asyncParentp` out parameter is _NOT_\n guaranteed to be in the cx's compartment. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS24GetSavedFrameAsyncParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncParentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its parent SavedFrame object or nullptr if\n it is the oldest frame in the stack. The `parentp` out parameter is _NOT_\n guaranteed to be in the cx's compartment. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                parentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame object, convert it and its transitive parents to plain\n objects. Because SavedFrame objects store their properties on the prototype,\n they cannot be usefully stringified to JSON. Assigning their properties to\n plain objects allow those objects to be stringified and the saved frame stack\n can be encoded as a string."]
            #[link_name = "\u{1}_ZN2JS30ConvertSavedFrameToPlainObjectEP9JSContextNS_6HandleIP8JSObjectEENS_20SavedFrameSelfHostedE"]
            pub fn ConvertSavedFrameToPlainObject(
                cx: *mut root::JSContext,
                savedFrame: root::JS::HandleObject,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
        }
        pub mod Scalar {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Type {
                Int8 = 0,
                Uint8 = 1,
                Int16 = 2,
                Uint16 = 3,
                Int32 = 4,
                Uint32 = 5,
                Float32 = 6,
                Float64 = 7,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256).\n Treat the raw data type as a uint8_t."]
                Uint8Clamped = 8,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256).\n Treat the raw data type as a uint8_t."]
                BigInt64 = 9,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256).\n Treat the raw data type as a uint8_t."]
                BigUint64 = 10,
                #[doc = " Types that don't have their own TypedArray equivalent, for now.\n E.g. DataView"]
                MaxTypedArrayViewType = 11,
                #[doc = " Types that don't have their own TypedArray equivalent, for now.\n E.g. DataView"]
                Int64 = 12,
                #[doc = " Types that don't have their own TypedArray equivalent, for now.\n E.g. DataView"]
                Simd128 = 13,
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SourceOwnership {
            Borrowed = 0,
            TakeOwnership = 1,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SourceText<Unit> {
            #[doc = " |char16_t| or |Utf8Unit| source units of uncertain validity."]
            pub units_: *const Unit,
            #[doc = " The length in code units of |units_|."]
            pub length_: u32,
            #[doc = " Whether this owns |units_| or merely observes source units owned by some\n other object."]
            pub ownsUnits_: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Unit>>,
        }
        pub type SourceText_CharT = root::std::conditional_t;
        #[repr(C)]
        pub struct ReadableStreamUnderlyingSource__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Abstract base class for external underlying sources.\n\n The term \"underlying source\" is defined in the Streams spec:\n   https://streams.spec.whatwg.org/#underlying-source\n\n A `ReadableStreamUnderlyingSource` is an underlying source that is\n implemented in C++ rather than JS. It can be passed to\n `JS::NewReadableExternalSourceStreamObject` to create a custom,\n embedding-defined ReadableStream.\n\n There are several API difference between this class and the standard API for\n underlying sources implemented in JS:\n\n -   JS underlying sources can be either byte sources or non-byte sources.\n     External underlying source are always byte sources.\n\n -   The C++ API does not bother with controller objects. Instead of using\n     controller methods, the underlying source directly calls API functions\n     like JS::ReadableStream{UpdateDataAvailableFromSource,Close,Error}.\n\n -   External readable streams are optimized to allow the embedding to\n     interact with them with a minimum of overhead: chunks aren't enqueued as\n     individual typed arrays; instead, the embedding only updates the amount\n     of data available using\n     JS::ReadableStreamUpdateDataAvailableFromSource. When JS requests data\n     from a reader, writeIntoReadRequestBuffer is invoked, asking the\n     embedding to write data directly into the buffer we're about to hand to\n     JS.\n\n -   The C++ API provides extra callbacks onClosed() and onErrored().\n\n -   This class has a `finalize()` method, because C++ cares about lifetimes.\n\n Additionally, ReadableStreamGetExternalUnderlyingSource can be used to get\n the pointer to the underlying source. This locks the stream until it is\n released again using JS::ReadableStreamReleaseExternalUnderlyingSource.\n\n Embeddings can use this to optimize away the JS `ReadableStream` overhead\n when an embedding-defined C++ stream is passed to an embedding-defined C++\n consumer. For example, consider a ServiceWorker piping a `fetch` Response\n body to a TextDecoder. Instead of copying chunks of data into JS typed array\n buffers and creating a Promise per chunk, only to immediately resolve the\n Promises and read the data out again, the embedding can directly feed the\n incoming data to the TextDecoder.\n\n Compartment safety: All methods (except `finalize`) receive `cx` and\n `stream` arguments. SpiderMonkey enters the realm of the stream object\n before invoking these methods, so `stream` is never a wrapper. Other\n arguments may be wrappers."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ReadableStreamUnderlyingSource {
            pub vtable_: *const ReadableStreamUnderlyingSource__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ReadableStreamUnderlyingSource() {
            assert_eq!(
                ::std::mem::size_of::<ReadableStreamUnderlyingSource>(),
                8usize,
                concat!("Size of: ", stringify!(ReadableStreamUnderlyingSource))
            );
            assert_eq!(
                ::std::mem::align_of::<ReadableStreamUnderlyingSource>(),
                8usize,
                concat!("Alignment of ", stringify!(ReadableStreamUnderlyingSource))
            );
        }
        extern "C" {
            #[doc = " Returns a new instance of the ReadableStream builtin class in the current\n compartment, configured as a default stream.\n If a |proto| is passed, that gets set as the instance's [[Prototype]]\n instead of the original value of |ReadableStream.prototype|."]
            #[link_name = "\u{1}_ZN2JS30NewReadableDefaultStreamObjectEP9JSContextNS_6HandleIP8JSObjectEENS2_IP10JSFunctionEEdS5_"]
            pub fn NewReadableDefaultStreamObject(
                cx: *mut root::JSContext,
                underlyingSource: root::JS::HandleObject,
                size: root::JS::HandleFunction,
                highWaterMark: f64,
                proto: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns a new instance of the ReadableStream builtin class in the current\n compartment.\n\n The instance is a byte stream backed by an embedding-provided underlying\n source, using the virtual methods of `underlyingSource` as callbacks. The\n embedding must ensure that `*underlyingSource` lives as long as the new\n stream object. The JS engine will call the finalize() method when the stream\n object is destroyed.\n\n `nsISupportsObject_alreadyAddreffed` is an optional pointer that can be used\n to make the new stream participate in Gecko's cycle collection. Here are the\n rules for using this parameter properly:\n\n -   `*underlyingSource` must not be a cycle-collected object. (It would lead\n     to memory leaks as the cycle collector would not be able to collect\n     cycles containing that object.)\n\n -   `*underlyingSource` must not contain nsCOMPtrs that point to cycle-\n     collected objects. (Same reason.)\n\n -   `*underlyingSource` may contain a pointer to a single cycle-collected\n     object.\n\n -   The pointer may be stored in `*underlyingSource` as a raw pointer.\n\n -   The pointer to the nsISupports interface of the same object must be\n     passed as the `nsISupportsObject_alreadyAddreffed` parameter to this\n     function. (This is how the cycle collector knows about it, so omitting\n     this would again cause leaks.)\n\n If `proto` is non-null, it is used as the instance's [[Prototype]] instead\n of the original value of `ReadableStream.prototype`."]
            #[link_name = "\u{1}_ZN2JS37NewReadableExternalSourceStreamObjectEP9JSContextPNS_30ReadableStreamUnderlyingSourceEPvNS_6HandleIP8JSObjectEE"]
            pub fn NewReadableExternalSourceStreamObject(
                cx: *mut root::JSContext,
                underlyingSource: *mut root::JS::ReadableStreamUnderlyingSource,
                nsISupportsObject_alreadyAddreffed: *mut ::std::os::raw::c_void,
                proto: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns the embedding-provided underlying source of the given |stream|.\n\n Can be used to optimize operations if both the underlying source and the\n intended sink are embedding-provided. In that case it might be\n preferrable to pipe data directly from source to sink without interacting\n with the stream at all.\n\n Locks the stream until ReadableStreamReleaseExternalUnderlyingSource is\n called.\n\n Throws an exception if the stream is locked, i.e. if a reader has been\n acquired for the stream, or if ReadableStreamGetExternalUnderlyingSource\n has been used previously without releasing the external source again.\n\n Throws an exception if the stream isn't readable, i.e if it is errored or\n closed. This is different from ReadableStreamGetReader because we don't\n have a Promise to resolve/reject, which a reader provides.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one.\n\n Asserts that the stream has an embedding-provided underlying source."]
            #[link_name = "\u{1}_ZN2JS41ReadableStreamGetExternalUnderlyingSourceEP9JSContextNS_6HandleIP8JSObjectEEPPNS_30ReadableStreamUnderlyingSourceE"]
            pub fn ReadableStreamGetExternalUnderlyingSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                source: *mut *mut root::JS::ReadableStreamUnderlyingSource,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Releases the embedding-provided underlying source of the given |stream|,\n returning the stream into an unlocked state.\n\n Asserts that the stream was locked through\n ReadableStreamGetExternalUnderlyingSource.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one.\n\n Asserts that the stream has an embedding-provided underlying source."]
            #[link_name = "\u{1}_ZN2JS45ReadableStreamReleaseExternalUnderlyingSourceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamReleaseExternalUnderlyingSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Update the amount of data available at the underlying source of the given\n |stream|.\n\n Can only be used for streams with an embedding-provided underlying source.\n The JS engine will use the given value to satisfy read requests for the\n stream by invoking the writeIntoReadRequestBuffer method.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS43ReadableStreamUpdateDataAvailableFromSourceEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn ReadableStreamUpdateDataAvailableFromSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                availableData: u32,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Break the cycle between this object and the\n nsISupportsObject_alreadyAddreffed passed in\n NewReadableExternalSourceStreamObject()."]
            #[link_name = "\u{1}_ZN2JS29ReadableStreamReleaseCCObjectEP8JSObject"]
            pub fn ReadableStreamReleaseCCObject(stream: *mut root::JSObject);
        }
        extern "C" {
            #[doc = " Returns true if the given object is a ReadableStream object or an\n unwrappable wrapper for one, false otherwise."]
            #[link_name = "\u{1}_ZN2JS16IsReadableStreamEP8JSObject"]
            pub fn IsReadableStream(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given object is a ReadableStreamDefaultReader or\n ReadableStreamBYOBReader object or an unwrappable wrapper for one, false\n otherwise."]
            #[link_name = "\u{1}_ZN2JS22IsReadableStreamReaderEP8JSObject"]
            pub fn IsReadableStreamReader(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given object is a ReadableStreamDefaultReader object\n or an unwrappable wrapper for one, false otherwise."]
            #[link_name = "\u{1}_ZN2JS29IsReadableStreamDefaultReaderEP8JSObject"]
            pub fn IsReadableStreamDefaultReader(obj: *mut root::JSObject) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ReadableStreamMode {
            Default = 0,
            Byte = 1,
            ExternalSource = 2,
        }
        extern "C" {
            #[doc = " Returns the stream's ReadableStreamMode. If the mode is |Byte| or\n |ExternalSource|, it's possible to acquire a BYOB reader for more optimized\n operations.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS21ReadableStreamGetModeEP9JSContextNS_6HandleIP8JSObjectEEPNS_18ReadableStreamModeE"]
            pub fn ReadableStreamGetMode(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                mode: *mut root::JS::ReadableStreamMode,
            ) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ReadableStreamReaderMode {
            Default = 0,
            Byob = 1,
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream is readable, false if not.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS24ReadableStreamIsReadableEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsReadable(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream is locked, false if not.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS22ReadableStreamIsLockedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsLocked(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream is disturbed, false if not.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS25ReadableStreamIsDisturbedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsDisturbed(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Cancels the given ReadableStream with the given reason and returns a\n Promise resolved according to the result.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS20ReadableStreamCancelEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamCancel(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                reason: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Creates a reader of the type specified by the mode option and locks the\n stream to the new reader.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one. The returned object will always be created in the\n current cx compartment."]
            #[link_name = "\u{1}_ZN2JS23ReadableStreamGetReaderEP9JSContextNS_6HandleIP8JSObjectEENS_24ReadableStreamReaderModeE"]
            pub fn ReadableStreamGetReader(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                mode: root::JS::ReadableStreamReaderMode,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Tees the given ReadableStream and stores the two resulting streams in\n outparams. Returns false if the operation fails, e.g. because the stream is\n locked.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS17ReadableStreamTeeEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIS4_EES7_"]
            pub fn ReadableStreamTee(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                branch1Stream: root::JS::MutableHandleObject,
                branch2Stream: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Retrieves the desired combined size of additional chunks to fill the given\n ReadableStream's queue. Stores the result in |value| and sets |hasValue| to\n true on success, returns false on failure.\n\n If the stream is errored, the call will succeed but no value will be stored\n in |value| and |hasValue| will be set to false.\n\n Note: This is semantically equivalent to the |desiredSize| getter on\n the stream controller's prototype in JS. We expose it with the stream\n itself as a target for simplicity.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS28ReadableStreamGetDesiredSizeEP9JSContextP8JSObjectPbPd"]
            pub fn ReadableStreamGetDesiredSize(
                cx: *mut root::JSContext,
                stream: *mut root::JSObject,
                hasValue: *mut bool,
                value: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Close the given ReadableStream. This is equivalent to `controller.close()`\n in JS.\n\n This can fail with or without an exception pending under a variety of\n circumstances. On failure, the stream may or may not be closed, and\n downstream consumers may or may not have been notified.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS19ReadableStreamCloseEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamClose(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream reader is locked, false otherwise.\n\n Asserts that |reader| is a ReadableStreamDefaultReader or\n ReadableStreamBYOBReader object or an unwrappable wrapper for one."]
            #[link_name = "\u{1}_ZN2JS28ReadableStreamReaderIsClosedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamReaderIsClosed(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Enqueues the given chunk in the given ReadableStream.\n\n Throws a TypeError and returns false if the enqueing operation fails.\n\n Note: This is semantically equivalent to the |enqueue| method on\n the stream controller's prototype in JS. We expose it with the stream\n itself as a target for simplicity.\n\n If the ReadableStream has an underlying byte source, the given chunk must\n be a typed array or a DataView. Consider using\n ReadableByteStreamEnqueueBuffer.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS21ReadableStreamEnqueueEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamEnqueue(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                chunk: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Errors the given ReadableStream, causing all future interactions to fail\n with the given error value.\n\n Throws a TypeError and returns false if the erroring operation fails.\n\n Note: This is semantically equivalent to the |error| method on\n the stream controller's prototype in JS. We expose it with the stream\n itself as a target for simplicity.\n\n Asserts that |stream| is a ReadableStream object or an unwrappable wrapper\n for one."]
            #[link_name = "\u{1}_ZN2JS19ReadableStreamErrorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamError(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                error: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " C++ equivalent of `reader.cancel(reason)`\n (both <https://streams.spec.whatwg.org/#default-reader-cancel> and\n <https://streams.spec.whatwg.org/#byob-reader-cancel>).\n\n `reader` must be a stream reader created using `JS::ReadableStreamGetReader`\n or an unwrappable wrapper for one. (This function is meant to support using\n C++ to read from streams. It's not meant to allow C++ code to operate on\n readers created by scripts.)"]
            #[link_name = "\u{1}_ZN2JS26ReadableStreamReaderCancelEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamReaderCancel(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
                reason: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " C++ equivalent of `reader.releaseLock()`\n (both <https://streams.spec.whatwg.org/#default-reader-release-lock> and\n <https://streams.spec.whatwg.org/#byob-reader-release-lock>).\n\n `reader` must be a stream reader created using `JS::ReadableStreamGetReader`\n or an unwrappable wrapper for one."]
            #[link_name = "\u{1}_ZN2JS31ReadableStreamReaderReleaseLockEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamReaderReleaseLock(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " C++ equivalent of the `reader.read()` method on default readers\n (<https://streams.spec.whatwg.org/#default-reader-read>).\n\n The result is a new Promise object, or null on OOM.\n\n `reader` must be the result of calling `JS::ReadableStreamGetReader` with\n `ReadableStreamReaderMode::Default` mode, or an unwrappable wrapper for such\n a reader."]
            #[link_name = "\u{1}_ZN2JS31ReadableStreamDefaultReaderReadEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamDefaultReaderRead(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Latin1Chars {
            pub _base: root::mozilla::Range<root::JS::Latin1Char>,
        }
        pub type Latin1Chars_Base = root::mozilla::Range<root::JS::Latin1Char>;
        pub type Latin1Chars_CharT = root::JS::Latin1Char;
        #[test]
        fn bindgen_test_layout_Latin1Chars() {
            assert_eq!(
                ::std::mem::size_of::<Latin1Chars>(),
                16usize,
                concat!("Size of: ", stringify!(Latin1Chars))
            );
            assert_eq!(
                ::std::mem::align_of::<Latin1Chars>(),
                8usize,
                concat!("Alignment of ", stringify!(Latin1Chars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ConstLatin1Chars {
            pub _base: root::mozilla::Range<root::JS::Latin1Char>,
        }
        pub type ConstLatin1Chars_Base = root::mozilla::Range<root::JS::Latin1Char>;
        pub type ConstLatin1Chars_CharT = root::JS::Latin1Char;
        #[test]
        fn bindgen_test_layout_ConstLatin1Chars() {
            assert_eq!(
                ::std::mem::size_of::<ConstLatin1Chars>(),
                16usize,
                concat!("Size of: ", stringify!(ConstLatin1Chars))
            );
            assert_eq!(
                ::std::mem::align_of::<ConstLatin1Chars>(),
                8usize,
                concat!("Alignment of ", stringify!(ConstLatin1Chars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Latin1CharsZ {
            pub _base: root::mozilla::RangedPtr<root::JS::Latin1Char>,
        }
        pub type Latin1CharsZ_Base = root::mozilla::RangedPtr<root::JS::Latin1Char>;
        pub type Latin1CharsZ_CharT = root::JS::Latin1Char;
        #[test]
        fn bindgen_test_layout_Latin1CharsZ() {
            assert_eq!(
                ::std::mem::size_of::<Latin1CharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(Latin1CharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<Latin1CharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(Latin1CharsZ))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UTF8Chars {
            pub _base: root::mozilla::Range<::std::os::raw::c_uchar>,
        }
        pub type UTF8Chars_Base = root::mozilla::Range<::std::os::raw::c_uchar>;
        pub type UTF8Chars_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_UTF8Chars() {
            assert_eq!(
                ::std::mem::size_of::<UTF8Chars>(),
                16usize,
                concat!("Size of: ", stringify!(UTF8Chars))
            );
            assert_eq!(
                ::std::mem::align_of::<UTF8Chars>(),
                8usize,
                concat!("Alignment of ", stringify!(UTF8Chars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UTF8CharsZ {
            pub _base: root::mozilla::RangedPtr<::std::os::raw::c_uchar>,
        }
        pub type UTF8CharsZ_Base = root::mozilla::RangedPtr<::std::os::raw::c_uchar>;
        pub type UTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_UTF8CharsZ() {
            assert_eq!(
                ::std::mem::size_of::<UTF8CharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(UTF8CharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<UTF8CharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(UTF8CharsZ))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ConstUTF8CharsZ {
            pub data_: *const ::std::os::raw::c_char,
        }
        pub type ConstUTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_ConstUTF8CharsZ() {
            const UNINIT: ::std::mem::MaybeUninit<ConstUTF8CharsZ> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ConstUTF8CharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(ConstUTF8CharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<ConstUTF8CharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(ConstUTF8CharsZ))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).data_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ConstUTF8CharsZ),
                    "::",
                    stringify!(data_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type TwoByteChars_Base = root::mozilla::Range<u16>;
        pub type TwoByteChars_CharT = u16;
        #[test]
        fn bindgen_test_layout_TwoByteChars() {
            assert_eq!(
                ::std::mem::size_of::<TwoByteChars>(),
                16usize,
                concat!("Size of: ", stringify!(TwoByteChars))
            );
            assert_eq!(
                ::std::mem::align_of::<TwoByteChars>(),
                8usize,
                concat!("Alignment of ", stringify!(TwoByteChars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TwoByteCharsZ {
            pub _base: root::mozilla::RangedPtr<u16>,
        }
        pub type TwoByteCharsZ_Base = root::mozilla::RangedPtr<u16>;
        pub type TwoByteCharsZ_CharT = u16;
        #[test]
        fn bindgen_test_layout_TwoByteCharsZ() {
            assert_eq!(
                ::std::mem::size_of::<TwoByteCharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(TwoByteCharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<TwoByteCharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(TwoByteCharsZ))
            );
        }
        pub type ConstCharPtr = root::mozilla::RangedPtr<u16>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ConstTwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type ConstTwoByteChars_Base = root::mozilla::Range<u16>;
        pub type ConstTwoByteChars_CharT = u16;
        #[test]
        fn bindgen_test_layout_ConstTwoByteChars() {
            assert_eq!(
                ::std::mem::size_of::<ConstTwoByteChars>(),
                16usize,
                concat!("Size of: ", stringify!(ConstTwoByteChars))
            );
            assert_eq!(
                ::std::mem::align_of::<ConstTwoByteChars>(),
                8usize,
                concat!("Alignment of ", stringify!(ConstTwoByteChars))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34LossyTwoByteCharsToNewLatin1CharsZEP9JSContextN7mozilla5RangeIKDsEE"]
            pub fn LossyTwoByteCharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                tbchars: root::mozilla::Range<u16>,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17Utf8ToOneUcs4CharEPKhi"]
            pub fn Utf8ToOneUcs4Char(
                utf8Buffer: *const u8,
                utf8Length: ::std::os::raw::c_int,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27UTF8CharsToNewTwoByteCharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27UTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_15ConstUTF8CharsZEPmm"]
            pub fn UTF8CharsToNewTwoByteCharsZ1(
                cx: *mut root::JSContext,
                utf8: *const root::JS::ConstUTF8CharsZ,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS32LossyUTF8CharsToNewTwoByteCharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn LossyUTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS32LossyUTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_15ConstUTF8CharsZEPmm"]
            pub fn LossyUTF8CharsToNewTwoByteCharsZ1(
                cx: *mut root::JSContext,
                utf8: *const root::JS::ConstUTF8CharsZ,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetDeflatedUTF8StringLengthEP14JSLinearString"]
            pub fn GetDeflatedUTF8StringLength(s: *mut root::JSLinearString) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25DeflateStringToUTF8BufferEP14JSLinearStringN7mozilla4SpanIcLm18446744073709551615EEE"]
            pub fn DeflateStringToUTF8Buffer(
                src: *mut root::JSLinearString,
                dst: [u32; 2usize],
            ) -> usize;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SmallestEncoding {
            ASCII = 0,
            Latin1 = 1,
            UTF16 = 2,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20FindSmallestEncodingENS_9UTF8CharsE"]
            pub fn FindSmallestEncoding(utf8: root::JS::UTF8Chars) -> root::JS::SmallestEncoding;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26UTF8CharsToNewLatin1CharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31LossyUTF8CharsToNewLatin1CharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn LossyUTF8CharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEPKc"]
            pub fn StringIsASCII(s: *const ::std::os::raw::c_char) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEN7mozilla4SpanIKcLm18446744073709551615EEE"]
            pub fn StringIsASCII1(s: [u32; 2usize]) -> bool;
        }
        #[repr(u32)]
        #[doc = " Indicates the \"scope of validity\" of serialized data.\n\n Writing plain JS data produces an array of bytes that can be copied and\n read in another process or whatever. The serialized data is Plain Old Data.\n However, HTML also supports `Transferable` objects, which, when cloned, can\n be moved from the source object into the clone, like when you take a\n photograph of someone and it steals their soul.\n See <https://developer.mozilla.org/en-US/docs/Web/API/Transferable>.\n We support cloning and transferring objects of many types.\n\n For example, when we transfer an ArrayBuffer (within a process), we \"detach\"\n the ArrayBuffer, embed the raw buffer pointer in the serialized data, and\n later install it in a new ArrayBuffer in the destination realm. Ownership\n of that buffer memory is transferred from the original ArrayBuffer to the\n serialized data and then to the clone.\n\n This only makes sense within a single address space. When we transfer an\n ArrayBuffer to another process, the contents of the buffer must be copied\n into the serialized data. (The original ArrayBuffer is still detached,\n though, for consistency; in some cases the caller shouldn't know or care if\n the recipient is in the same process.)\n\n ArrayBuffers are actually a lucky case; some objects (like MessagePorts)\n can't reasonably be stored by value in serialized data -- it's pointers or\n nothing.\n\n So there is a tradeoff between scope of validity -- how far away the\n serialized data may be sent and still make sense -- and efficiency or\n features. The read and write algorithms therefore take an argument of this\n type, allowing the user to control those trade-offs."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StructuredCloneScope {
            #[doc = " The most restrictive scope, with greatest efficiency and features.\n\n When writing, this means: The caller promises that the serialized data\n will **not** be shipped off to a different process or stored in a\n database. However, it may be shipped to another thread. It's OK to\n produce serialized data that contains pointers to data that is safe to\n send across threads, such as array buffers. In Rust terms, the\n serialized data will be treated as `Send` but not `Copy`.\n\n When reading, this means: Accept transferred objects and buffers\n (pointers). The caller promises that the serialized data was written\n using this API (otherwise, the serialized data may contain bogus\n pointers, leading to undefined behavior).\n\n Starts from 1 because there used to be a SameProcessSameThread enum value\n of 0 and these values are encoded into the structured serialization format\n as part of the SCTAG_HEADER, and IndexedDB persists the representation to\n disk."]
            SameProcess = 1,
            #[doc = " When writing, this means we're writing for an audience in a different\n process. Produce serialized data that can be sent to other processes,\n bitwise copied, or even stored as bytes in a database and read by later\n versions of Firefox years from now. The HTML5 spec refers to this as\n \"ForStorage\" as in StructuredSerializeForStorage, though we use\n DifferentProcess for IPC as well as storage.\n\n Transferable objects are limited to ArrayBuffers, whose contents are\n copied into the serialized data (rather than just writing a pointer).\n\n When reading, this means: Do not accept pointers."]
            DifferentProcess = 2,
            #[doc = " Handle a backwards-compatibility case with IndexedDB (bug 1434308): when\n reading, this means to treat legacy SameProcess data as if it were\n DifferentProcess.\n\n Do not use this for writing; use DifferentProcess instead."]
            DifferentProcessForIndexedDB = 3,
            #[doc = " Existing code wants to be able to create an uninitialized\n JSStructuredCloneData without knowing the scope, then populate it with\n data (at which point the scope *is* known.)"]
            Unassigned = 4,
            #[doc = " This scope is used when the deserialization context is unknown. When\n writing, DifferentProcess or SameProcess scope is chosen based on the\n nature of the object."]
            UnknownDestination = 5,
        }
        impl root::JS::TransferableOwnership {
            pub const SCTAG_TMO_ALLOC_DATA: root::JS::TransferableOwnership =
                TransferableOwnership::SCTAG_TMO_FIRST_OWNED;
        }
        #[repr(u32)]
        #[doc = " Values used to describe the ownership individual Transferables.\n\n Note that these *can* show up in DifferentProcess clones, since\n DifferentProcess ArrayBuffers can be Transferred. In that case, this will\n distinguish the specific ownership mechanism: is it a malloc pointer or a\n memory mapping?"]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TransferableOwnership {
            #[doc = " Transferable data has not been filled in yet."]
            SCTAG_TMO_UNFILLED = 0,
            #[doc = " Structured clone buffer does not yet own the data."]
            SCTAG_TMO_UNOWNED = 1,
            #[doc = " All enum values at least this large are owned by the clone buffer."]
            SCTAG_TMO_FIRST_OWNED = 2,
            #[doc = " Data is a memory mapped pointer."]
            SCTAG_TMO_MAPPED_DATA = 3,
            #[doc = " Data is embedding-specific. The engine can free it by calling the\n freeTransfer op."]
            SCTAG_TMO_CUSTOM = 4,
            #[doc = " Same as SCTAG_TMO_CUSTOM, but the embedding can also use\n SCTAG_TMO_USER_MIN and greater, up to 2^32-1, to distinguish specific\n ownership variants."]
            SCTAG_TMO_USER_MIN = 5,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CloneDataPolicy {
            pub allowIntraClusterClonableSharedObjects_: bool,
            pub allowSharedMemoryObjects_: bool,
            pub allowErrorStackFrames_: bool,
        }
        #[test]
        fn bindgen_test_layout_CloneDataPolicy() {
            const UNINIT: ::std::mem::MaybeUninit<CloneDataPolicy> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CloneDataPolicy>(),
                3usize,
                concat!("Size of: ", stringify!(CloneDataPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<CloneDataPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(CloneDataPolicy))
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).allowIntraClusterClonableSharedObjects_) as usize
                        - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CloneDataPolicy),
                    "::",
                    stringify!(allowIntraClusterClonableSharedObjects_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).allowSharedMemoryObjects_) as usize - ptr as usize
                },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CloneDataPolicy),
                    "::",
                    stringify!(allowSharedMemoryObjects_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).allowErrorStackFrames_) as usize - ptr as usize
                },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CloneDataPolicy),
                    "::",
                    stringify!(allowErrorStackFrames_)
                )
            );
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of ASCII format\n filled from trailing ASCII arguments.\n\n Return true iff the warning was successfully reported without reporting an\n error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS9WarnASCIIEP9JSContextPKcz"]
            pub fn WarnASCII(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of Latin-1 format\n filled from trailing Latin-1 arguments.\n\n Return true iff the warning was successfully reported without reporting an\n error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS10WarnLatin1EP9JSContextPKcz"]
            pub fn WarnLatin1(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of UTF-8 format\n filled from trailing UTF-8 arguments.\n\n Return true iff the warning was successfully reported without reporting an\n error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS8WarnUTF8EP9JSContextPKcz"]
            pub fn WarnUTF8(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        pub type WarningReporter = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, report: *mut root::JSErrorReport),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetWarningReporterEP9JSContext"]
            pub fn GetWarningReporter(cx: *mut root::JSContext) -> root::JS::WarningReporter;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18SetWarningReporterEP9JSContextPFvS1_P13JSErrorReportE"]
            pub fn SetWarningReporter(
                cx: *mut root::JSContext,
                reporter: root::JS::WarningReporter,
            ) -> root::JS::WarningReporter;
        }
        #[doc = " A simple RAII class that clears the registered warning reporter on\n construction and restores it on destruction.\n\n A fresh warning reporter *may* be set while an instance of this class is\n live, but it must be unset in LIFO fashion by the time that instance is\n destroyed."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoSuppressWarningReporter {
            pub context_: *mut root::JSContext,
            pub prevReporter_: root::JS::WarningReporter,
        }
        #[test]
        fn bindgen_test_layout_AutoSuppressWarningReporter() {
            const UNINIT: ::std::mem::MaybeUninit<AutoSuppressWarningReporter> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoSuppressWarningReporter>(),
                16usize,
                concat!("Size of: ", stringify!(AutoSuppressWarningReporter))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSuppressWarningReporter>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoSuppressWarningReporter))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).context_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSuppressWarningReporter),
                    "::",
                    stringify!(context_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).prevReporter_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSuppressWarningReporter),
                    "::",
                    stringify!(prevReporter_)
                )
            );
        }
        #[repr(C)]
        pub struct WasmModule__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The WasmModule interface allows the embedding to hold a reference to the\n underying C++ implementation of a JS WebAssembly.Module object for purposes\n of efficient postMessage() and (de)serialization from a random thread.\n\n In particular, this allows postMessage() of a WebAssembly.Module:\n GetWasmModule() is called when making a structured clone of a payload\n containing a WebAssembly.Module object. The structured clone buffer holds a\n refcount of the JS::WasmModule until createObject() is called in the target\n agent's JSContext. The new WebAssembly.Module object continues to hold the\n JS::WasmModule and thus the final reference of a JS::WasmModule may be\n dropped from any thread and so the virtual destructor (and all internal\n methods of the C++ module) must be thread-safe."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct WasmModule {
            pub vtable_: *const WasmModule__bindgen_vtable,
            pub _base: root::js::AtomicRefCounted,
        }
        #[test]
        fn bindgen_test_layout_WasmModule() {
            assert_eq!(
                ::std::mem::size_of::<WasmModule>(),
                16usize,
                concat!("Size of: ", stringify!(WasmModule))
            );
            assert_eq!(
                ::std::mem::align_of::<WasmModule>(),
                8usize,
                concat!("Alignment of ", stringify!(WasmModule))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18IsWasmModuleObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsWasmModuleObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13GetWasmModuleENS_6HandleIP8JSObjectEE"]
            pub fn GetWasmModule(obj: root::JS::HandleObject)
                -> root::RefPtr<root::JS::WasmModule>;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OffThreadToken {
            _unused: [u8; 0],
        }
        pub type OffThreadCompileCallback = ::std::option::Option<
            unsafe extern "C" fn(
                token: *mut root::JS::OffThreadToken,
                callbackData: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19CanCompileOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsEm"]
            pub fn CanCompileOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                length: usize,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18CanDecodeOffThreadEP9JSContextRKNS_13DecodeOptionsEm"]
            pub fn CanDecodeOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::DecodeOptions,
                length: usize,
            ) -> bool;
        }
        pub type TranscodeBuffer = u8;
        pub type TranscodeRange = root::mozilla::Range<u8>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TranscodeSource {
            pub range: root::JS::TranscodeRange,
            pub filename: *const ::std::os::raw::c_char,
            pub lineno: u32,
        }
        #[test]
        fn bindgen_test_layout_TranscodeSource() {
            const UNINIT: ::std::mem::MaybeUninit<TranscodeSource> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TranscodeSource>(),
                32usize,
                concat!("Size of: ", stringify!(TranscodeSource))
            );
            assert_eq!(
                ::std::mem::align_of::<TranscodeSource>(),
                8usize,
                concat!("Alignment of ", stringify!(TranscodeSource))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TranscodeSource),
                    "::",
                    stringify!(range)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TranscodeSource),
                    "::",
                    stringify!(filename)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TranscodeSource),
                    "::",
                    stringify!(lineno)
                )
            );
        }
        pub type TranscodeSources = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TranscodeResult {
            Ok = 0,
            Failure = 16,
            Failure_BadBuildId = 17,
            Failure_AsmJSNotSupported = 18,
            Failure_BadDecode = 19,
            Throw = 32,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24CheckCompileOptionsMatchERKNS_22ReadOnlyCompileOptionsEP8JSScript"]
            pub fn CheckCompileOptionsMatch(
                options: *const root::JS::ReadOnlyCompileOptions,
                script: *mut root::JSScript,
            ) -> bool;
        }
        pub type Stencil = root::js::frontend::CompilationStencil;
        #[repr(C)]
        #[derive(Debug)]
        pub struct InstantiationStorage {
            pub gcOutput_: *mut root::js::frontend::CompilationGCOutput,
        }
        #[test]
        fn bindgen_test_layout_InstantiationStorage() {
            const UNINIT: ::std::mem::MaybeUninit<InstantiationStorage> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<InstantiationStorage>(),
                8usize,
                concat!("Size of: ", stringify!(InstantiationStorage))
            );
            assert_eq!(
                ::std::mem::align_of::<InstantiationStorage>(),
                8usize,
                concat!("Alignment of ", stringify!(InstantiationStorage))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcOutput_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InstantiationStorage),
                    "::",
                    stringify!(gcOutput_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StencilAddRefEPN2js8frontend18CompilationStencilE"]
            pub fn StencilAddRef(stencil: *mut root::JS::Stencil);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14StencilReleaseEPN2js8frontend18CompilationStencilE"]
            pub fn StencilRelease(stencil: *mut root::JS::Stencil);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17StencilIsBorrowedEPN2js8frontend18CompilationStencilE"]
            pub fn StencilIsBorrowed(stencil: *mut root::JS::Stencil) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13SizeOfStencilEPN2js8frontend18CompilationStencilEPFmPKvE"]
            pub fn SizeOfStencil(
                stencil: *mut root::JS::Stencil,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileGlobalScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileGlobalScriptToStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileGlobalScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileGlobalScriptToStencil1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileModuleScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileModuleScriptToStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileModuleScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileModuleScriptToStencil1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InstantiateGlobalStencilEP9JSContextRKNS_18InstantiateOptionsEPN2js8frontend18CompilationStencilEPNS_20InstantiationStorageE"]
            pub fn InstantiateGlobalStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::InstantiateOptions,
                stencil: *mut root::JS::Stencil,
                storage: *mut root::JS::InstantiationStorage,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InstantiateModuleStencilEP9JSContextRKNS_18InstantiateOptionsEPN2js8frontend18CompilationStencilEPNS_20InstantiationStorageE"]
            pub fn InstantiateModuleStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::InstantiateOptions,
                stencil: *mut root::JS::Stencil,
                storage: *mut root::JS::InstantiationStorage,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13DecodeStencilEP9JSContextRKNS_13DecodeOptionsERKN7mozilla5RangeIKhEEPPN2js8frontend18CompilationStencilE"]
            pub fn DecodeStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::DecodeOptions,
                range: *const root::JS::TranscodeRange,
                stencilOut: *mut *mut root::JS::Stencil,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24StartIncrementalEncodingEP9JSContextO6RefPtrIN2js8frontend18CompilationStencilEE"]
            pub fn StartIncrementalEncoding(
                cx: *mut root::JSContext,
                stencil: *mut root::RefPtr<root::JS::Stencil>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25CompileToStencilOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEEPFvPNS_14OffThreadTokenEPvESA_"]
            pub fn CompileToStencilOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JS::OffThreadToken;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25CompileToStencilOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEEPFvPNS_14OffThreadTokenEPvESC_"]
            pub fn CompileToStencilOffThread1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JS::OffThreadToken;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31CompileModuleToStencilOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEEPFvPNS_14OffThreadTokenEPvESA_"]
            pub fn CompileModuleToStencilOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JS::OffThreadToken;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31CompileModuleToStencilOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEEPFvPNS_14OffThreadTokenEPvESC_"]
            pub fn CompileModuleToStencilOffThread1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JS::OffThreadToken;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20CancelOffThreadTokenEP9JSContextPNS_14OffThreadTokenE"]
            pub fn CancelOffThreadToken(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22IsLargeArrayBufferViewEP8JSObject"]
            pub fn IsLargeArrayBufferView(obj: *mut root::JSObject) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ArrayBufferOrView {
            pub obj: *mut root::JSObject,
        }
        pub type ArrayBufferOrView_DataType = u8;
        #[test]
        fn bindgen_test_layout_ArrayBufferOrView() {
            const UNINIT: ::std::mem::MaybeUninit<ArrayBufferOrView> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ArrayBufferOrView>(),
                8usize,
                concat!("Size of: ", stringify!(ArrayBufferOrView))
            );
            assert_eq!(
                ::std::mem::align_of::<ArrayBufferOrView>(),
                8usize,
                concat!("Alignment of ", stringify!(ArrayBufferOrView))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBufferOrView),
                    "::",
                    stringify!(obj)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ArrayBuffer {
            pub _base: root::JS::ArrayBufferOrView,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer13UnsharedClassE"]
            pub static ArrayBuffer_UnsharedClass: *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer11SharedClassE"]
            pub static ArrayBuffer_SharedClass: *const root::JSClass;
        }
        #[test]
        fn bindgen_test_layout_ArrayBuffer() {
            assert_eq!(
                ::std::mem::size_of::<ArrayBuffer>(),
                8usize,
                concat!("Size of: ", stringify!(ArrayBuffer))
            );
            assert_eq!(
                ::std::mem::align_of::<ArrayBuffer>(),
                8usize,
                concat!("Alignment of ", stringify!(ArrayBuffer))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ArrayBufferView {
            pub _base: root::JS::ArrayBufferOrView,
        }
        #[test]
        fn bindgen_test_layout_ArrayBufferView() {
            assert_eq!(
                ::std::mem::size_of::<ArrayBufferView>(),
                8usize,
                concat!("Size of: ", stringify!(ArrayBufferView))
            );
            assert_eq!(
                ::std::mem::align_of::<ArrayBufferView>(),
                8usize,
                concat!("Alignment of ", stringify!(ArrayBufferView))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DataView {
            pub _base: root::JS::ArrayBufferView,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8DataView8ClassPtrE"]
            pub static DataView_ClassPtr: *const root::JSClass;
        }
        #[test]
        fn bindgen_test_layout_DataView() {
            assert_eq!(
                ::std::mem::size_of::<DataView>(),
                8usize,
                concat!("Size of: ", stringify!(DataView))
            );
            assert_eq!(
                ::std::mem::align_of::<DataView>(),
                8usize,
                concat!("Alignment of ", stringify!(DataView))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TypedArray_base {
            pub _base: root::JS::ArrayBufferView,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15TypedArray_base7classesE"]
            pub static TypedArray_base_classes: *const root::JSClass;
        }
        #[test]
        fn bindgen_test_layout_TypedArray_base() {
            assert_eq!(
                ::std::mem::size_of::<TypedArray_base>(),
                8usize,
                concat!("Size of: ", stringify!(TypedArray_base))
            );
            assert_eq!(
                ::std::mem::align_of::<TypedArray_base>(),
                8usize,
                concat!("Alignment of ", stringify!(TypedArray_base))
            );
        }
        pub type TypedArray_DataType = root::JS::detail::ExternalTypeOf_t;
        extern "C" {
            #[link_name = "\u{1}Scalar"]
            pub static TypedArray_Scalar: root::JS::Scalar::Type;
        }
        pub type Int8Array = u64;
        pub type Uint8Array = u64;
        pub type Int16Array = u64;
        pub type Uint16Array = u64;
        pub type Int32Array = u64;
        pub type Uint32Array = u64;
        pub type Float32Array = u64;
        pub type Float64Array = u64;
        pub type Uint8ClampedArray = u64;
        pub type BigInt64Array = u64;
        pub type BigUint64Array = u64;
        #[repr(C)]
        pub struct ExpandoAndGeneration {
            pub expando: root::JS::Heap<root::JS::Value>,
            pub generation: u64,
        }
        #[test]
        fn bindgen_test_layout_ExpandoAndGeneration() {
            const UNINIT: ::std::mem::MaybeUninit<ExpandoAndGeneration> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ExpandoAndGeneration>(),
                16usize,
                concat!("Size of: ", stringify!(ExpandoAndGeneration))
            );
            assert_eq!(
                ::std::mem::align_of::<ExpandoAndGeneration>(),
                8usize,
                concat!("Alignment of ", stringify!(ExpandoAndGeneration))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).expando) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExpandoAndGeneration),
                    "::",
                    stringify!(expando)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).generation) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExpandoAndGeneration),
                    "::",
                    stringify!(generation)
                )
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DOMProxyShadowsResult {
            ShadowCheckFailed = 0,
            Shadows = 1,
            DoesntShadow = 2,
            DoesntShadowUnique = 3,
            ShadowsViaDirectExpando = 4,
            ShadowsViaIndirectExpando = 5,
        }
        pub type DOMProxyShadowsCheck = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::Handle<*mut root::JSObject>,
                arg3: root::JS::Handle<root::JS::PropertyKey>,
            ) -> root::JS::DOMProxyShadowsResult,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SetDOMProxyInformationEPKvPFNS_21DOMProxyShadowsResultEP9JSContextNS_6HandleIP8JSObjectEENS5_INS_11PropertyKeyEEEES1_"]
            pub fn SetDOMProxyInformation(
                domProxyHandlerFamily: *const ::std::os::raw::c_void,
                domProxyShadowsCheck: root::JS::DOMProxyShadowsCheck,
                domRemoteProxyHandlerFamily: *const ::std::os::raw::c_void,
            );
        }
        pub type GCVector_ElementType<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StackGCVector {
            pub _address: u8,
        }
        pub type StackGCVector_Base = u8;
        pub type RootedVector_Vec = u8;
        #[doc = " Local variable of type T whose value is always rooted. This is typically\n used for local variables, or for non-rooted values being passed to a\n function that requires a handle, e.g. Foo(Root<T>(cx, x)).\n\n If you want to add additional methods to Rooted for a specific\n specialization, define a RootedOperations<T> specialization containing them."]
        pub type RootedVector_Base = root::JS::Rooted<root::JS::RootedVector_Vec>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PersistentRootedVector {
            pub _address: u8,
        }
        pub type PersistentRootedVector_Vec = u8;
        #[doc = " A copyable, assignable global GC root type with arbitrary lifetime, an\n infallible constructor, and automatic unrooting on destruction.\n\n These roots can be used in heap-allocated data structures, so they are not\n associated with any particular JSContext or stack. They are registered with\n the JSRuntime itself, without locking. Initialization may take place on\n construction, or in two phases if the no-argument constructor is called\n followed by init().\n\n Note that you must not use an PersistentRooted in an object owned by a JS\n object:\n\n Whenever one object whose lifetime is decided by the GC refers to another\n such object, that edge must be traced only if the owning JS object is traced.\n This applies not only to JS objects (which obviously are managed by the GC)\n but also to C++ objects owned by JS objects.\n\n If you put a PersistentRooted in such a C++ object, that is almost certainly\n a leak. When a GC begins, the referent of the PersistentRooted is treated as\n live, unconditionally (because a PersistentRooted is a *root*), even if the\n JS object that owns it is unreachable. If there is any path from that\n referent back to the JS object, then the C++ object containing the\n PersistentRooted will not be destructed, and the whole blob of objects will\n not be freed, even if there are no references to them from the outside.\n\n In the context of Firefox, this is a severe restriction: almost everything in\n Firefox is owned by some JS object or another, so using PersistentRooted in\n such objects would introduce leaks. For these kinds of edges, Heap<T> or\n TenuredHeap<T> would be better types. It's up to the implementor of the type\n containing Heap<T> or TenuredHeap<T> members to make sure their referents get\n marked when the object itself is marked."]
        pub type PersistentRootedVector_Base = u8;
        #[doc = " A generic handle to an array of rooted values.\n\n The rooted array refernced can take several forms, therfore this is not the\n same as Handle<js::ValueArray>."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleValueArray {
            pub length_: usize,
            pub elements_: *const root::JS::Value,
        }
        #[test]
        fn bindgen_test_layout_HandleValueArray() {
            const UNINIT: ::std::mem::MaybeUninit<HandleValueArray> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<HandleValueArray>(),
                16usize,
                concat!("Size of: ", stringify!(HandleValueArray))
            );
            assert_eq!(
                ::std::mem::align_of::<HandleValueArray>(),
                8usize,
                concat!("Alignment of ", stringify!(HandleValueArray))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).length_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleValueArray),
                    "::",
                    stringify!(length_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).elements_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleValueArray),
                    "::",
                    stringify!(elements_)
                )
            );
        }
        extern "C" {
            #[doc = " Return true if the given object is callable. In ES6 terms, an object is\n callable if it has a [[Call]] internal method.\n\n Implements: ES6 7.2.3 IsCallable(argument).\n\n Functions are callable. A scripted proxy or wrapper is callable if its\n target is callable. Most other objects aren't callable."]
            #[link_name = "\u{1}_ZN2JS10IsCallableEP8JSObject"]
            pub fn IsCallable(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true if the given object is a constructor. In ES6 terms, an object is\n a constructor if it has a [[Construct]] internal method. The expression\n `new obj()` throws a TypeError if obj is not a constructor.\n\n Implements: ES6 7.2.4 IsConstructor(argument).\n\n JS functions and classes are constructors. Arrow functions and most builtin\n functions are not. A scripted proxy or wrapper is a constructor if its\n target is a constructor."]
            #[link_name = "\u{1}_ZN2JS13IsConstructorEP8JSObject"]
            pub fn IsConstructor(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS4CallEP9JSContextNS_6HandleINS_5ValueEEES4_RKNS_16HandleValueArrayENS_13MutableHandleIS3_EE"]
            pub fn Call(
                cx: *mut root::JSContext,
                thisv: root::JS::Handle<root::JS::Value>,
                fun: root::JS::Handle<root::JS::Value>,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Invoke a constructor. This is the C++ equivalent of\n `rval = Reflect.construct(fun, args, newTarget)`.\n\n Construct() takes a `newTarget` argument that most callers don't need.\n Consider using the four-argument Construct signature instead. (But if you're\n implementing a subclass or a proxy handler's construct() method, this is the\n right function to call.)\n\n Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]).\n Use this function to invoke the [[Construct]] internal method."]
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEERKNS_16HandleValueArrayENS_13MutableHandleIS6_EE"]
            pub fn Construct(
                cx: *mut root::JSContext,
                fun: root::JS::Handle<root::JS::Value>,
                newTarget: root::JS::Handle<*mut root::JSObject>,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Invoke a constructor. This is the C++ equivalent of\n `rval = new fun(...args)`.\n\n Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when\n newTarget is omitted."]
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEERKNS_16HandleValueArrayENS_13MutableHandleIP8JSObjectEE"]
            pub fn Construct1(
                cx: *mut root::JSContext,
                fun: root::JS::Handle<root::JS::Value>,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Asserts (in debug and release builds) that `obj` belongs to the current\n thread's context."]
            #[link_name = "\u{1}_ZN2JS34AssertObjectBelongsToCurrentThreadEP8JSObject"]
            pub fn AssertObjectBelongsToCurrentThread(obj: *mut root::JSObject);
        }
        #[doc = " Install a process-wide callback to validate script filenames. The JS engine\n will invoke this callback for each JS script it parses or XDR decodes.\n\n If the callback returns |false|, an exception is thrown and parsing/decoding\n will be aborted.\n\n See also CompileOptions::setSkipFilenameValidation to opt-out of the callback\n for specific parse jobs."]
        pub type FilenameValidationCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                filename: *const ::std::os::raw::c_char,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS29SetFilenameValidationCallbackEPFbP9JSContextPKcE"]
            pub fn SetFilenameValidationCallback(cb: root::JS::FilenameValidationCallback);
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCOptions {
            Normal = 0,
            Shrink = 1,
            Shutdown = 2,
        }
        impl root::JS::GCReason {
            pub const DOM_WINDOW_UTILS: root::JS::GCReason = GCReason::FIRST_FIREFOX_REASON;
        }
        impl root::JS::GCReason {
            pub const RESERVED1: root::JS::GCReason = GCReason::FIRST_RESERVED_REASON;
        }
        impl root::JS::GCReason {
            pub const NUM_TELEMETRY_REASONS: root::JS::GCReason = GCReason::NUM_REASONS;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCReason {
            FIRST_FIREFOX_REASON = 33,
            FIRST_RESERVED_REASON = 90,
            API = 0,
            EAGER_ALLOC_TRIGGER = 1,
            DESTROY_RUNTIME = 2,
            ROOTS_REMOVED = 3,
            LAST_DITCH = 4,
            TOO_MUCH_MALLOC = 5,
            ALLOC_TRIGGER = 6,
            DEBUG_GC = 7,
            COMPARTMENT_REVIVED = 8,
            RESET = 9,
            OUT_OF_NURSERY = 10,
            EVICT_NURSERY = 11,
            SHARED_MEMORY_LIMIT = 13,
            EAGER_NURSERY_COLLECTION = 14,
            BG_TASK_FINISHED = 15,
            ABORT_GC = 16,
            FULL_WHOLE_CELL_BUFFER = 17,
            FULL_GENERIC_BUFFER = 18,
            FULL_VALUE_BUFFER = 19,
            FULL_CELL_PTR_OBJ_BUFFER = 20,
            FULL_SLOT_BUFFER = 21,
            FULL_SHAPE_BUFFER = 22,
            TOO_MUCH_WASM_MEMORY = 23,
            DISABLE_GENERATIONAL_GC = 24,
            FINISH_GC = 25,
            PREPARE_FOR_TRACING = 26,
            UNUSED4 = 27,
            FULL_CELL_PTR_STR_BUFFER = 28,
            TOO_MUCH_JIT_CODE = 29,
            FULL_CELL_PTR_BIGINT_BUFFER = 30,
            UNUSED5 = 31,
            NURSERY_MALLOC_BUFFERS = 32,
            COMPONENT_UTILS = 34,
            MEM_PRESSURE = 35,
            CC_FINISHED = 36,
            CC_FORCED = 37,
            LOAD_END = 38,
            UNUSED3 = 39,
            PAGE_HIDE = 40,
            NSJSCONTEXT_DESTROY = 41,
            WORKER_SHUTDOWN = 42,
            SET_DOC_SHELL = 43,
            DOM_UTILS = 44,
            DOM_IPC = 45,
            DOM_WORKER = 46,
            INTER_SLICE_GC = 47,
            UNUSED1 = 48,
            FULL_GC_TIMER = 49,
            SHUTDOWN_CC = 50,
            UNUSED2 = 51,
            USER_INACTIVE = 52,
            XPCONNECT_SHUTDOWN = 53,
            DOCSHELL = 54,
            HTML_PARSER = 55,
            DOM_TESTUTILS = 56,
            RESERVED2 = 91,
            RESERVED3 = 92,
            RESERVED4 = 93,
            RESERVED5 = 94,
            RESERVED6 = 95,
            RESERVED7 = 96,
            RESERVED8 = 97,
            RESERVED9 = 98,
            NO_REASON = 99,
            NUM_REASONS = 100,
        }
        extern "C" {
            #[doc = " Get a statically allocated C string explaining the given GC reason."]
            #[link_name = "\u{1}_ZN2JS15ExplainGCReasonENS_8GCReasonE"]
            pub fn ExplainGCReason(reason: root::JS::GCReason) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Return true if the GC reason is internal to the JS engine."]
            #[link_name = "\u{1}_ZN2JS16InternalGCReasonENS_8GCReasonE"]
            pub fn InternalGCReason(reason: root::JS::GCReason) -> bool;
        }
        extern "C" {
            #[doc = " Schedule the given zone to be collected as part of the next GC."]
            #[link_name = "\u{1}_ZN2JS16PrepareZoneForGCEP9JSContextPNS_4ZoneE"]
            pub fn PrepareZoneForGC(cx: *mut root::JSContext, zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Schedule all zones to be collected in the next GC."]
            #[link_name = "\u{1}_ZN2JS16PrepareForFullGCEP9JSContext"]
            pub fn PrepareForFullGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " When performing an incremental GC, the zones that were selected for the\n previous incremental slice must be selected in subsequent slices as well.\n This function selects those slices automatically."]
            #[link_name = "\u{1}_ZN2JS23PrepareForIncrementalGCEP9JSContext"]
            pub fn PrepareForIncrementalGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns true if any zone in the system has been scheduled for GC with one of\n the functions above or by the JS engine."]
            #[link_name = "\u{1}_ZN2JS13IsGCScheduledEP9JSContext"]
            pub fn IsGCScheduled(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Undoes the effect of the Prepare methods above. The given zone will not be\n collected in the next GC."]
            #[link_name = "\u{1}_ZN2JS13SkipZoneForGCEP9JSContextPNS_4ZoneE"]
            pub fn SkipZoneForGC(cx: *mut root::JSContext, zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Performs a non-incremental collection of all selected zones."]
            #[link_name = "\u{1}_ZN2JS16NonIncrementalGCEP9JSContextNS_9GCOptionsENS_8GCReasonE"]
            pub fn NonIncrementalGC(
                cx: *mut root::JSContext,
                options: root::JS::GCOptions,
                reason: root::JS::GCReason,
            );
        }
        extern "C" {
            #[doc = " Begin an incremental collection and perform one slice worth of work. When\n this function returns, the collection may not be complete.\n IncrementalGCSlice() must be called repeatedly until\n !IsIncrementalGCInProgress(cx).\n\n Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or\n       shorter than the requested interval."]
            #[link_name = "\u{1}_ZN2JS18StartIncrementalGCEP9JSContextNS_9GCOptionsENS_8GCReasonERKN2js11SliceBudgetE"]
            pub fn StartIncrementalGC(
                cx: *mut root::JSContext,
                options: root::JS::GCOptions,
                reason: root::JS::GCReason,
                budget: *const root::js::SliceBudget,
            );
        }
        extern "C" {
            #[doc = " Perform a slice of an ongoing incremental collection. When this function\n returns, the collection may not be complete. It must be called repeatedly\n until !IsIncrementalGCInProgress(cx).\n\n Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or\n       shorter than the requested interval."]
            #[link_name = "\u{1}_ZN2JS18IncrementalGCSliceEP9JSContextNS_8GCReasonERKN2js11SliceBudgetE"]
            pub fn IncrementalGCSlice(
                cx: *mut root::JSContext,
                reason: root::JS::GCReason,
                budget: *const root::js::SliceBudget,
            );
        }
        extern "C" {
            #[doc = " Return whether an incremental GC has work to do on the foreground thread and\n would make progress if a slice was run now. If this returns false then the GC\n is waiting for background threads to finish their work and a slice started\n now would return immediately."]
            #[link_name = "\u{1}_ZN2JS30IncrementalGCHasForegroundWorkEP9JSContext"]
            pub fn IncrementalGCHasForegroundWork(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " If IsIncrementalGCInProgress(cx), this call finishes the ongoing collection\n by performing an arbitrarily long slice. If !IsIncrementalGCInProgress(cx),\n this is equivalent to NonIncrementalGC. When this function returns,\n IsIncrementalGCInProgress(cx) will always be false."]
            #[link_name = "\u{1}_ZN2JS19FinishIncrementalGCEP9JSContextNS_8GCReasonE"]
            pub fn FinishIncrementalGC(cx: *mut root::JSContext, reason: root::JS::GCReason);
        }
        extern "C" {
            #[doc = " If IsIncrementalGCInProgress(cx), this call aborts the ongoing collection and\n performs whatever work needs to be done to return the collector to its idle\n state. This may take an arbitrarily long time. When this function returns,\n IsIncrementalGCInProgress(cx) will always be false."]
            #[link_name = "\u{1}_ZN2JS18AbortIncrementalGCEP9JSContext"]
            pub fn AbortIncrementalGC(cx: *mut root::JSContext);
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: [u64; 3usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent_Collection() {
                const UNINIT: ::std::mem::MaybeUninit<GarbageCollectionEvent_Collection> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<GarbageCollectionEvent_Collection>(),
                    16usize,
                    concat!("Size of: ", stringify!(GarbageCollectionEvent_Collection))
                );
                assert_eq!(
                    ::std::mem::align_of::<GarbageCollectionEvent_Collection>(),
                    8usize,
                    concat!(
                        "Alignment of ",
                        stringify!(GarbageCollectionEvent_Collection)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).startTimestamp) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent_Collection),
                        "::",
                        stringify!(startTimestamp)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).endTimestamp) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent_Collection),
                        "::",
                        stringify!(endTimestamp)
                    )
                );
            }
            pub type GarbageCollectionEvent_Ptr = u8;
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent() {
                const UNINIT: ::std::mem::MaybeUninit<GarbageCollectionEvent> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<GarbageCollectionEvent>(),
                    48usize,
                    concat!("Size of: ", stringify!(GarbageCollectionEvent))
                );
                assert_eq!(
                    ::std::mem::align_of::<GarbageCollectionEvent>(),
                    8usize,
                    concat!("Alignment of ", stringify!(GarbageCollectionEvent))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).majorGCNumber_) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(majorGCNumber_)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(reason)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).nonincrementalReason) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(nonincrementalReason)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).collections) as usize - ptr as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(collections)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg23SetDebuggerMallocSizeOfEP9JSContextPFmPKvE"]
                pub fn SetDebuggerMallocSizeOf(
                    cx: *mut root::JSContext,
                    mallocSizeOf: root::mozilla::MallocSizeOf,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg23GetDebuggerMallocSizeOfEP9JSContext"]
                pub fn GetDebuggerMallocSizeOf(
                    cx: *mut root::JSContext,
                ) -> root::mozilla::MallocSizeOf;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg35FireOnGarbageCollectionHookRequiredEP9JSContext"]
                pub fn FireOnGarbageCollectionHookRequired(cx: *mut root::JSContext) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg10IsDebuggerER8JSObject"]
                pub fn IsDebugger(obj: *mut root::JSObject) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg18GetDebuggeeGlobalsEP9JSContextR8JSObjectNS_13MutableHandleINS_13StackGCVectorIPS3_N2js15TempAllocPolicyEEEEE"]
                pub fn GetDebuggeeGlobals(
                    cx: *mut root::JSContext,
                    dbgObj: *mut root::JSObject,
                    vector: root::JS::MutableHandleObjectVector,
                ) -> bool;
            }
            #[repr(C)]
            pub struct AutoEntryMonitor__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEntryMonitor {
                pub vtable_: *const AutoEntryMonitor__bindgen_vtable,
                pub cx_: *mut root::JSContext,
                pub savedMonitor_: *mut root::JS::dbg::AutoEntryMonitor,
            }
            #[test]
            fn bindgen_test_layout_AutoEntryMonitor() {
                const UNINIT: ::std::mem::MaybeUninit<AutoEntryMonitor> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<AutoEntryMonitor>(),
                    24usize,
                    concat!("Size of: ", stringify!(AutoEntryMonitor))
                );
                assert_eq!(
                    ::std::mem::align_of::<AutoEntryMonitor>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AutoEntryMonitor))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).cx_) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AutoEntryMonitor),
                        "::",
                        stringify!(cx_)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).savedMonitor_) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AutoEntryMonitor),
                        "::",
                        stringify!(savedMonitor_)
                    )
                );
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCProgress {
            GC_CYCLE_BEGIN = 0,
            GC_SLICE_BEGIN = 1,
            GC_SLICE_END = 2,
            GC_CYCLE_END = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCDescription {
            pub isZone_: bool,
            pub isComplete_: bool,
            pub options_: root::JS::GCOptions,
            pub reason_: root::JS::GCReason,
        }
        #[test]
        fn bindgen_test_layout_GCDescription() {
            const UNINIT: ::std::mem::MaybeUninit<GCDescription> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GCDescription>(),
                12usize,
                concat!("Size of: ", stringify!(GCDescription))
            );
            assert_eq!(
                ::std::mem::align_of::<GCDescription>(),
                4usize,
                concat!("Alignment of ", stringify!(GCDescription))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isZone_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(isZone_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isComplete_) as usize - ptr as usize },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(isComplete_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).options_) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(options_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).reason_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(reason_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13MinorGcToJSONEP9JSContext"]
            pub fn MinorGcToJSON(cx: *mut root::JSContext) -> root::JS::UniqueChars;
        }
        pub type GCSliceCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCProgress,
                desc: *const root::JS::GCDescription,
            ),
        >;
        extern "C" {
            #[doc = " The GC slice callback is called at the beginning and end of each slice. This\n callback may be used for GC notifications as well as to perform additional\n marking."]
            #[link_name = "\u{1}_ZN2JS18SetGCSliceCallbackEP9JSContextPFvS1_NS_10GCProgressERKNS_13GCDescriptionEE"]
            pub fn SetGCSliceCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCSliceCallback,
            ) -> root::JS::GCSliceCallback;
        }
        #[repr(i32)]
        #[doc = " Describes the progress of an observed nursery collection."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCNurseryProgress {
            #[doc = " The nursery collection is starting."]
            GC_NURSERY_COLLECTION_START = 0,
            #[doc = " The nursery collection is ending."]
            GC_NURSERY_COLLECTION_END = 1,
        }
        #[doc = " A nursery collection callback receives the progress of the nursery collection\n and the reason for the collection."]
        pub type GCNurseryCollectionCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCNurseryProgress,
                reason: root::JS::GCReason,
            ),
        >;
        extern "C" {
            #[doc = " Set the nursery collection callback for the given runtime. When set, it will\n be called at the start and end of every nursery collection."]
            #[link_name = "\u{1}_ZN2JS30SetGCNurseryCollectionCallbackEP9JSContextPFvS1_NS_17GCNurseryProgressENS_8GCReasonEE"]
            pub fn SetGCNurseryCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCNurseryCollectionCallback,
            ) -> root::JS::GCNurseryCollectionCallback;
        }
        pub type DoCycleCollectionCallback =
            ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext)>;
        extern "C" {
            #[doc = " The purge gray callback is called after any COMPARTMENT_REVIVED GC in which\n the majority of compartments have been marked gray."]
            #[link_name = "\u{1}_ZN2JS28SetDoCycleCollectionCallbackEP9JSContextPFvS1_E"]
            pub fn SetDoCycleCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DoCycleCollectionCallback,
            ) -> root::JS::DoCycleCollectionCallback;
        }
        pub type CreateSliceBudgetCallback = ::std::option::Option<
            unsafe extern "C" fn(reason: root::JS::GCReason, millis: i64) -> root::js::SliceBudget,
        >;
        extern "C" {
            #[doc = " Called when generating a GC slice budget. It allows the embedding to control\n the duration of slices and potentially check an interrupt flag as well. For\n internally triggered GCs, the given millis parameter is the JS engine's\n internal scheduling decision, which the embedding can choose to ignore.\n (Otherwise, it will be the value that was passed to eg\n JS::IncrementalGCSlice())."]
            #[link_name = "\u{1}_ZN2JS30SetCreateGCSliceBudgetCallbackEP9JSContextPFN2js11SliceBudgetENS_8GCReasonElE"]
            pub fn SetCreateGCSliceBudgetCallback(
                cx: *mut root::JSContext,
                cb: root::JS::CreateSliceBudgetCallback,
            );
        }
        extern "C" {
            #[doc = " Incremental GC defaults to enabled, but may be disabled for testing or in\n embeddings that have not yet implemented barriers on their native classes.\n There is not currently a way to re-enable incremental GC once it has been\n disabled on the runtime."]
            #[link_name = "\u{1}_ZN2JS20DisableIncrementalGCEP9JSContext"]
            pub fn DisableIncrementalGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns true if incremental GC is enabled. Simply having incremental GC\n enabled is not sufficient to ensure incremental collections are happening.\n See the comment \"Incremental GC\" above for reasons why incremental GC may be\n suppressed. Inspection of the \"nonincremental reason\" field of the\n GCDescription returned by GCSliceCallback may help narrow down the cause if\n collections are not happening incrementally when expected."]
            #[link_name = "\u{1}_ZN2JS22IsIncrementalGCEnabledEP9JSContext"]
            pub fn IsIncrementalGCEnabled(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Returns true while an incremental GC is ongoing, both when actively\n collecting and between slices."]
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSContext"]
            pub fn IsIncrementalGCInProgress(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Returns true while an incremental GC is ongoing, both when actively\n collecting and between slices."]
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSRuntime"]
            pub fn IsIncrementalGCInProgress1(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the most recent GC ran incrementally."]
            #[link_name = "\u{1}_ZN2JS16WasIncrementalGCEP9JSRuntime"]
            pub fn WasIncrementalGC(rt: *mut root::JSRuntime) -> bool;
        }
        #[doc = " Ensure that generational GC is disabled within some scope."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoDisableGenerationalGC {
            pub cx: *mut root::JSContext,
        }
        #[test]
        fn bindgen_test_layout_AutoDisableGenerationalGC() {
            const UNINIT: ::std::mem::MaybeUninit<AutoDisableGenerationalGC> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoDisableGenerationalGC>(),
                8usize,
                concat!("Size of: ", stringify!(AutoDisableGenerationalGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoDisableGenerationalGC>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoDisableGenerationalGC))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoDisableGenerationalGC),
                    "::",
                    stringify!(cx)
                )
            );
        }
        extern "C" {
            #[doc = " Returns true if generational allocation and collection is currently enabled\n on the given runtime."]
            #[link_name = "\u{1}_ZN2JS23IsGenerationalGCEnabledEP9JSRuntime"]
            pub fn IsGenerationalGCEnabled(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[doc = " Enable or disable support for pretenuring allocations based on their\n allocation site."]
            #[link_name = "\u{1}_ZN2JS30SetSiteBasedPretenuringEnabledEb"]
            pub fn SetSiteBasedPretenuringEnabled(enable: bool);
        }
        #[doc = " Pass a subclass of this \"abstract\" class to callees to require that they\n never GC. Subclasses can use assertions or the hazard analysis to ensure no\n GC happens."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoRequireNoGC {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoRequireNoGC() {
            assert_eq!(
                ::std::mem::size_of::<AutoRequireNoGC>(),
                1usize,
                concat!("Size of: ", stringify!(AutoRequireNoGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoRequireNoGC>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoRequireNoGC))
            );
        }
        #[doc = " Diagnostic assert (see MOZ_DIAGNOSTIC_ASSERT) that GC cannot occur while this\n class is live. This class does not disable the static rooting hazard\n analysis.\n\n This works by entering a GC unsafe region, which is checked on allocation and\n on GC."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoAssertNoGC {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoAssertNoGC() {
            assert_eq!(
                ::std::mem::size_of::<AutoAssertNoGC>(),
                1usize,
                concat!("Size of: ", stringify!(AutoAssertNoGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoAssertNoGC>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoAssertNoGC))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoSuppressGCAnalysis {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoSuppressGCAnalysis() {
            assert_eq!(
                ::std::mem::size_of::<AutoSuppressGCAnalysis>(),
                1usize,
                concat!("Size of: ", stringify!(AutoSuppressGCAnalysis))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSuppressGCAnalysis>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoSuppressGCAnalysis))
            );
        }
        #[doc = " Assert that code is only ever called from a GC callback, disable the static\n rooting hazard analysis and assert if any allocation that could potentially\n trigger a GC occurs while this guard object is live.\n\n This is useful to make the static analysis ignore code that runs in GC\n callbacks."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoAssertGCCallback {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoAssertGCCallback() {
            assert_eq!(
                ::std::mem::size_of::<AutoAssertGCCallback>(),
                1usize,
                concat!("Size of: ", stringify!(AutoAssertGCCallback))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoAssertGCCallback>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoAssertGCCallback))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoCheckCannotGC {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoCheckCannotGC() {
            assert_eq!(
                ::std::mem::size_of::<AutoCheckCannotGC>(),
                1usize,
                concat!("Size of: ", stringify!(AutoCheckCannotGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoCheckCannotGC>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoCheckCannotGC))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17SetLowMemoryStateEP9JSContextb"]
            pub fn SetLowMemoryState(cx: *mut root::JSContext, newState: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20NotifyGCRootsRemovedEP9JSContext"]
            pub fn NotifyGCRootsRemoved(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16WantEagerMinorGCEP9JSRuntime"]
            pub fn WantEagerMinorGC(rt: *mut root::JSRuntime) -> root::JS::GCReason;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16WantEagerMajorGCEP9JSRuntime"]
            pub fn WantEagerMajorGC(rt: *mut root::JSRuntime) -> root::JS::GCReason;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25MaybeRunNurseryCollectionEP9JSRuntimeNS_8GCReasonE"]
            pub fn MaybeRunNurseryCollection(rt: *mut root::JSRuntime, reason: root::JS::GCReason);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS42SetHostCleanupFinalizationRegistryCallbackEP9JSContextPFvP10JSFunctionP8JSObjectPvES6_"]
            pub fn SetHostCleanupFinalizationRegistryCallback(
                cx: *mut root::JSContext,
                cb: root::JSHostCleanupFinalizationRegistryCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Clear kept alive objects in JS WeakRef.\n https://tc39.es/proposal-weakrefs/#sec-clear-kept-objects"]
            #[link_name = "\u{1}_ZN2JS16ClearKeptObjectsEP9JSContext"]
            pub fn ClearKeptObjects(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21AtomsZoneIsCollectingEP9JSRuntime"]
            pub fn AtomsZoneIsCollecting(runtime: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11IsAtomsZoneEPNS_4ZoneE"]
            pub fn IsAtomsZone(zone: *mut root::JS::Zone) -> bool;
        }
        #[repr(C)]
        pub struct ErrorReportBuilder {
            pub reportp: *mut root::JSErrorReport,
            pub ownedReport: root::JSErrorReport,
            pub exnObject: root::JS::RootedObject,
            pub filename: root::JS::UniqueChars,
            pub toStringResult_: root::JS::ConstUTF8CharsZ,
            pub toStringResultBytesStorage: root::JS::UniqueChars,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ErrorReportBuilder_SniffingBehavior {
            WithSideEffects = 0,
            NoSideEffects = 1,
        }
        #[test]
        fn bindgen_test_layout_ErrorReportBuilder() {
            const UNINIT: ::std::mem::MaybeUninit<ErrorReportBuilder> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ErrorReportBuilder>(),
                144usize,
                concat!("Size of: ", stringify!(ErrorReportBuilder))
            );
            assert_eq!(
                ::std::mem::align_of::<ErrorReportBuilder>(),
                8usize,
                concat!("Alignment of ", stringify!(ErrorReportBuilder))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).reportp) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReportBuilder),
                    "::",
                    stringify!(reportp)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ownedReport) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReportBuilder),
                    "::",
                    stringify!(ownedReport)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).exnObject) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReportBuilder),
                    "::",
                    stringify!(exnObject)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReportBuilder),
                    "::",
                    stringify!(filename)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).toStringResult_) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReportBuilder),
                    "::",
                    stringify!(toStringResult_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).toStringResultBytesStorage) as usize - ptr as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReportBuilder),
                    "::",
                    stringify!(toStringResultBytesStorage)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10PrintErrorEP8_IO_FILEP13JSErrorReportb"]
            pub fn PrintError(
                file: *mut root::FILE,
                report: *mut root::JSErrorReport,
                reportWarnings: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10PrintErrorEP8_IO_FILERKNS_18ErrorReportBuilderEb"]
            pub fn PrintError1(
                file: *mut root::FILE,
                builder: *const root::JS::ErrorReportBuilder,
                reportWarnings: bool,
            );
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ExceptionStackBehavior {
            DoNotCapture = 0,
            Capture = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ExceptionStatus {
            None = 0,
            ForcedReturn = 1,
            Throwing = 2,
            OutOfMemory = 3,
            OverRecursed = 4,
        }
        #[repr(C)]
        pub struct ExceptionStack {
            pub exception_: root::JS::Rooted<root::JS::Value>,
            pub stack_: root::JS::Rooted<*mut root::JSObject>,
        }
        #[test]
        fn bindgen_test_layout_ExceptionStack() {
            const UNINIT: ::std::mem::MaybeUninit<ExceptionStack> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ExceptionStack>(),
                48usize,
                concat!("Size of: ", stringify!(ExceptionStack))
            );
            assert_eq!(
                ::std::mem::align_of::<ExceptionStack>(),
                8usize,
                concat!("Alignment of ", stringify!(ExceptionStack))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).exception_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExceptionStack),
                    "::",
                    stringify!(exception_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).stack_) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExceptionStack),
                    "::",
                    stringify!(stack_)
                )
            );
        }
        #[doc = " Save and later restore the current exception state of a given JSContext.\n This is useful for implementing behavior in C++ that's like try/catch\n or try/finally in JS.\n\n Typical usage:\n\n     bool ok = JS::Evaluate(cx, ...);\n     AutoSaveExceptionState savedExc(cx);\n     ... cleanup that might re-enter JS ...\n     return ok;"]
        #[repr(C)]
        pub struct AutoSaveExceptionState {
            pub context: *mut root::JSContext,
            pub status: root::JS::ExceptionStatus,
            pub exceptionValue: root::JS::RootedValue,
            pub exceptionStack: root::JS::RootedObject,
        }
        #[test]
        fn bindgen_test_layout_AutoSaveExceptionState() {
            const UNINIT: ::std::mem::MaybeUninit<AutoSaveExceptionState> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoSaveExceptionState>(),
                64usize,
                concat!("Size of: ", stringify!(AutoSaveExceptionState))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSaveExceptionState>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoSaveExceptionState))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(status)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).exceptionValue) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(exceptionValue)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).exceptionStack) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(exceptionStack)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetPendingExceptionStackEP9JSContextPNS_14ExceptionStackE"]
            pub fn GetPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *mut root::JS::ExceptionStack,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26StealPendingExceptionStackEP9JSContextPNS_14ExceptionStackE"]
            pub fn StealPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *mut root::JS::ExceptionStack,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24SetPendingExceptionStackEP9JSContextRKNS_14ExceptionStackE"]
            pub fn SetPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *const root::JS::ExceptionStack,
            );
        }
        extern "C" {
            #[doc = " If the given object is an exception object (or an unwrappable\n cross-compartment wrapper for one), return the stack for that exception, if\n any.  Will return null if the given object is not an exception object\n (including if it's null or a security wrapper that can't be unwrapped) or if\n the exception has no stack."]
            #[link_name = "\u{1}_ZN2JS20ExceptionStackOrNullENS_6HandleIP8JSObjectEE"]
            pub fn ExceptionStackOrNull(obj: root::JS::HandleObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the current realm's global. Returns nullptr if no realm has been\n entered."]
            #[link_name = "\u{1}_ZN2JS19CurrentGlobalOrNullEP9JSContext"]
            pub fn CurrentGlobalOrNull(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the global object associated with an object's realm. The object must not\n be a cross-compartment wrapper (because CCWs are shared by all realms in the\n compartment)."]
            #[link_name = "\u{1}_ZN2JS21GetNonCCWObjectGlobalEP8JSObject"]
            pub fn GetNonCCWObjectGlobal(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        #[repr(u32)]
        #[doc = " During global creation, we fire notifications to callbacks registered\n via the Debugger API. These callbacks are arbitrary script, and can touch\n the global in arbitrary ways. When that happens, the global should not be\n in a half-baked state. But this creates a problem for consumers that need\n to set slots on the global to put it in a consistent state.\n\n This API provides a way for consumers to set slots atomically (immediately\n after the global is created), before any debugger hooks are fired. It's\n unfortunately on the clunky side, but that's the way the cookie crumbles.\n\n If callers have no additional state on the global to set up, they may pass\n |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to\n fire the hook as its final act before returning. Otherwise, callers should\n pass |DontFireOnNewGlobalHook|, which means that they are responsible for\n invoking JS_FireOnNewGlobalObject upon successfully creating the global. If\n an error occurs and the operation aborts, callers should skip firing the\n hook. But otherwise, callers must take care to fire the hook exactly once\n before compiling any script in the global's scope (we have assertions in\n place to enforce this). This lets us be sure that debugger clients never miss\n breakpoints."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum OnNewGlobalHookOption {
            FireOnNewGlobalHook = 0,
            DontFireOnNewGlobalHook = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12NewMapObjectEP9JSContext"]
            pub fn NewMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7MapSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapGetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleIS6_EE"]
            pub fn MapGet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapSetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapSet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9MapDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MapClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapClear(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7MapKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9MapValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10MapEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10MapForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12NewSetObjectEP9JSContext"]
            pub fn NewSetObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7SetSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6SetHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9SetDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6SetAddEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn SetAdd(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8SetClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetClear(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7SetKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9SetValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10SetEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10SetForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn SetForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
        }
        #[doc = " If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS\n engine may call the large-allocation-failure callback, if set, to allow the\n embedding to flush caches, possibly perform shrinking GCs, etc. to make some\n room. The allocation will then be retried (and may still fail.) This callback\n can be called on any thread and must be set at most once in a process."]
        pub type LargeAllocationFailureCallback = ::std::option::Option<unsafe extern "C" fn()>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS40SetProcessLargeAllocationFailureCallbackEPFvvE"]
            pub fn SetProcessLargeAllocationFailureCallback(
                afc: root::JS::LargeAllocationFailureCallback,
            );
        }
        #[doc = " Unlike the error reporter, which is only called if the exception for an OOM\n bubbles up and is not caught, the OutOfMemoryCallback is called immediately\n at the OOM site to allow the embedding to capture the current state of heap\n allocation before anything is freed. If the large-allocation-failure callback\n is called at all (not all allocation sites call the large-allocation-failure\n callback on failure), it is called before the out-of-memory callback; the\n out-of-memory callback is only called if the allocation still fails after the\n large-allocation-failure callback has returned."]
        pub type OutOfMemoryCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::JSContext, arg2: *mut ::std::os::raw::c_void),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SetOutOfMemoryCallbackEP9JSContextPFvS1_PvES2_"]
            pub fn SetOutOfMemoryCallback(
                cx: *mut root::JSContext,
                cb: root::JS::OutOfMemoryCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryUse {
            XPCWrappedNative = 0,
            DOMBinding = 1,
            CTypeFFIType = 2,
            CTypeFFITypeElements = 3,
            CTypeFunctionInfo = 4,
            CTypeFieldInfo = 5,
            CDataBufferPtr = 6,
            CDataBuffer = 7,
            CClosureInfo = 8,
            CTypesInt64 = 9,
            Embedding1 = 10,
            Embedding2 = 11,
            Embedding3 = 12,
            Embedding4 = 13,
            Embedding5 = 14,
        }
        extern "C" {
            #[doc = " Advise the GC of external memory owned by a JSObject. This is used to\n determine when to collect zones. Calls must be matched by calls to\n RemoveAssociatedMemory() when the memory is deallocated or no longer owned by\n the object."]
            #[link_name = "\u{1}_ZN2JS19AddAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn AddAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
        }
        extern "C" {
            #[doc = " Advise the GC that external memory reported by JS::AddAssociatedMemory() is\n no longer owned by a JSObject. Calls must match those to\n AddAssociatedMemory()."]
            #[link_name = "\u{1}_ZN2JS22RemoveAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn RemoveAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
        }
        pub type IdVector = u8;
        pub type IterateRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realm: *mut root::JS::Realm,
                nogc: *const root::JS::AutoRequireNoGC,
            ),
        >;
        extern "C" {
            #[doc = " This function calls |realmCallback| on every realm. Beware that there is no\n guarantee that the realm will survive after the callback returns. Also,\n barriers are disabled via the TraceSession."]
            #[link_name = "\u{1}_ZN2JS13IterateRealmsEP9JSContextPvPFvS1_S2_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealms(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        extern "C" {
            #[doc = " Like IterateRealms, but only call the callback for realms using |principals|."]
            #[link_name = "\u{1}_ZN2JS27IterateRealmsWithPrincipalsEP9JSContextP12JSPrincipalsPvPFvS1_S4_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealmsWithPrincipals(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        extern "C" {
            #[doc = " Like IterateRealms, but only iterates realms in |compartment|."]
            #[link_name = "\u{1}_ZN2JS26IterateRealmsInCompartmentEP9JSContextPNS_11CompartmentEPvPFvS1_S4_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealmsInCompartment(
                cx: *mut root::JSContext,
                compartment: *mut root::JS::Compartment,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        #[repr(i32)]
        #[doc = " An enum that JSIterateCompartmentCallback can return to indicate\n whether to keep iterating."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CompartmentIterResult {
            KeepGoing = 0,
            Stop = 1,
        }
        #[repr(i32)]
        #[doc = " Specification for which compartment/zone a newly created realm should use."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CompartmentSpecifier {
            NewCompartmentInSystemZone = 0,
            NewCompartmentInExistingZone = 1,
            NewCompartmentAndZone = 2,
            ExistingCompartment = 3,
        }
        #[repr(i32)]
        #[doc = " Specification for whether weak refs should be enabled and if so whether the\n FinalizationRegistry.cleanupSome method should be present."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WeakRefSpecifier {
            Disabled = 0,
            EnabledWithCleanupSome = 1,
            EnabledWithoutCleanupSome = 2,
        }
        #[doc = " RealmCreationOptions specifies options relevant to creating a new realm, that\n are either immutable characteristics of that realm or that are discarded\n after the realm has been created.\n\n Access to these options on an existing realm is read-only: if you need\n particular selections, you must make them before you create the realm."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct RealmCreationOptions {
            pub traceGlobal_: root::JSTraceOp,
            pub compSpec_: root::JS::CompartmentSpecifier,
            pub __bindgen_anon_1: root::JS::RealmCreationOptions__bindgen_ty_1,
            pub profilerRealmID_: u64,
            pub weakRefs_: root::JS::WeakRefSpecifier,
            pub invisibleToDebugger_: bool,
            pub preserveJitCode_: bool,
            pub sharedMemoryAndAtomics_: bool,
            pub defineSharedArrayBufferConstructor_: bool,
            pub coopAndCoep_: bool,
            pub streams_: bool,
            pub toSource_: bool,
            pub propertyErrorMessageFix_: bool,
            pub iteratorHelpers_: bool,
            pub shadowRealms_: bool,
            pub secureContext_: bool,
            pub freezeBuiltins_: bool,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union RealmCreationOptions__bindgen_ty_1 {
            pub comp_: *mut root::JS::Compartment,
            pub zone_: *mut root::JS::Zone,
        }
        #[test]
        fn bindgen_test_layout_RealmCreationOptions__bindgen_ty_1() {
            const UNINIT: ::std::mem::MaybeUninit<RealmCreationOptions__bindgen_ty_1> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RealmCreationOptions__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(RealmCreationOptions__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmCreationOptions__bindgen_ty_1>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(RealmCreationOptions__bindgen_ty_1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).comp_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions__bindgen_ty_1),
                    "::",
                    stringify!(comp_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).zone_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions__bindgen_ty_1),
                    "::",
                    stringify!(zone_)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_RealmCreationOptions() {
            const UNINIT: ::std::mem::MaybeUninit<RealmCreationOptions> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RealmCreationOptions>(),
                48usize,
                concat!("Size of: ", stringify!(RealmCreationOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmCreationOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(RealmCreationOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).traceGlobal_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(traceGlobal_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).compSpec_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(compSpec_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).profilerRealmID_) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(profilerRealmID_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).weakRefs_) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(weakRefs_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).invisibleToDebugger_) as usize - ptr as usize
                },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(invisibleToDebugger_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).preserveJitCode_) as usize - ptr as usize },
                37usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(preserveJitCode_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).sharedMemoryAndAtomics_) as usize - ptr as usize
                },
                38usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(sharedMemoryAndAtomics_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).defineSharedArrayBufferConstructor_) as usize
                        - ptr as usize
                },
                39usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(defineSharedArrayBufferConstructor_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).coopAndCoep_) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(coopAndCoep_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).streams_) as usize - ptr as usize },
                41usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(streams_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).toSource_) as usize - ptr as usize },
                42usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(toSource_)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).propertyErrorMessageFix_) as usize - ptr as usize
                },
                43usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(propertyErrorMessageFix_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).iteratorHelpers_) as usize - ptr as usize },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(iteratorHelpers_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).shadowRealms_) as usize - ptr as usize },
                45usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(shadowRealms_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).secureContext_) as usize - ptr as usize },
                46usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(secureContext_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).freezeBuiltins_) as usize - ptr as usize },
                47usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(freezeBuiltins_)
                )
            );
        }
        #[doc = " RealmBehaviors specifies behaviors of a realm that can be changed after the\n realm's been created."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RealmBehaviors {
            pub discardSource_: bool,
            pub clampAndJitterTime_: bool,
            pub isNonLive_: bool,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RealmBehaviors_Override {
            pub mode_: root::JS::RealmBehaviors_Override_Mode,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RealmBehaviors_Override_Mode {
            Default = 0,
            ForceTrue = 1,
            ForceFalse = 2,
        }
        #[test]
        fn bindgen_test_layout_RealmBehaviors_Override() {
            const UNINIT: ::std::mem::MaybeUninit<RealmBehaviors_Override> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RealmBehaviors_Override>(),
                4usize,
                concat!("Size of: ", stringify!(RealmBehaviors_Override))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmBehaviors_Override>(),
                4usize,
                concat!("Alignment of ", stringify!(RealmBehaviors_Override))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mode_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors_Override),
                    "::",
                    stringify!(mode_)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_RealmBehaviors() {
            const UNINIT: ::std::mem::MaybeUninit<RealmBehaviors> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RealmBehaviors>(),
                3usize,
                concat!("Size of: ", stringify!(RealmBehaviors))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmBehaviors>(),
                1usize,
                concat!("Alignment of ", stringify!(RealmBehaviors))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).discardSource_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(discardSource_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).clampAndJitterTime_) as usize - ptr as usize },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(clampAndJitterTime_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isNonLive_) as usize - ptr as usize },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(isNonLive_)
                )
            );
        }
        #[doc = " RealmOptions specifies realm characteristics: both those that can't be\n changed on a realm once it's been created (RealmCreationOptions), and those\n that can be changed on an existing realm (RealmBehaviors)."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct RealmOptions {
            pub creationOptions_: root::JS::RealmCreationOptions,
            pub behaviors_: root::JS::RealmBehaviors,
        }
        #[test]
        fn bindgen_test_layout_RealmOptions() {
            const UNINIT: ::std::mem::MaybeUninit<RealmOptions> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<RealmOptions>(),
                56usize,
                concat!("Size of: ", stringify!(RealmOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(RealmOptions))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).creationOptions_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmOptions),
                    "::",
                    stringify!(creationOptions_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).behaviors_) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmOptions),
                    "::",
                    stringify!(behaviors_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEPNS_5RealmE"]
            pub fn RealmCreationOptionsRef(
                realm: *mut root::JS::Realm,
            ) -> *const root::JS::RealmCreationOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEP9JSContext"]
            pub fn RealmCreationOptionsRef1(
                cx: *mut root::JSContext,
            ) -> *const root::JS::RealmCreationOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEPNS_5RealmE"]
            pub fn RealmBehaviorsRef(
                realm: *mut root::JS::Realm,
            ) -> *const root::JS::RealmBehaviors;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEP9JSContext"]
            pub fn RealmBehaviorsRef1(cx: *mut root::JSContext) -> *const root::JS::RealmBehaviors;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetRealmNonLiveEPNS_5RealmE"]
            pub fn SetRealmNonLive(realm: *mut root::JS::Realm);
        }
        extern "C" {
            #[doc = " Set a private value associated with a script. Note that this value is shared\n by all nested scripts compiled from a single source file."]
            #[link_name = "\u{1}_ZN2JS16SetScriptPrivateEP8JSScriptRKNS_5ValueE"]
            pub fn SetScriptPrivate(script: *mut root::JSScript, value: *const root::JS::Value);
        }
        extern "C" {
            #[doc = " Get the private value associated with a script. Note that this value is\n shared by all nested scripts compiled from a single source file."]
            #[link_name = "\u{1}_ZN2JS16GetScriptPrivateEP8JSScript"]
            pub fn GetScriptPrivate(script: *mut root::JSScript) -> root::JS::Value;
        }
        extern "C" {
            #[doc = " Return the private value associated with currently executing script or\n module, or undefined if there is no such script."]
            #[link_name = "\u{1}_ZN2JS24GetScriptedCallerPrivateEP9JSContext"]
            pub fn GetScriptedCallerPrivate(cx: *mut root::JSContext) -> root::JS::Value;
        }
        #[doc = " Hooks called when references to a script private value are created or\n destroyed. This allows use of a reference counted object as the\n script private."]
        pub type ScriptPrivateReferenceHook =
            ::std::option::Option<unsafe extern "C" fn(arg1: *const root::JS::Value)>;
        extern "C" {
            #[doc = " Set the script private finalize hook for the runtime to the given function."]
            #[link_name = "\u{1}_ZN2JS30SetScriptPrivateReferenceHooksEP9JSRuntimePFvRKNS_5ValueEES6_"]
            pub fn SetScriptPrivateReferenceHooks(
                rt: *mut root::JSRuntime,
                addRefHook: root::JS::ScriptPrivateReferenceHook,
                releaseHook: root::JS::ScriptPrivateReferenceHook,
            );
        }
        #[repr(C)]
        pub struct OptimizedEncodingListener__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The ConsumeStreamCallback is called from an active JSContext, passing a\n StreamConsumer that wishes to consume the given host object as a stream of\n bytes with the given MIME type. On failure, the embedding must report the\n appropriate error on 'cx'. On success, the embedding must call\n consumer->consumeChunk() repeatedly on any thread until exactly one of:\n  - consumeChunk() returns false\n  - the embedding calls consumer->streamEnd()\n  - the embedding calls consumer->streamError()\n before JS_DestroyContext(cx) or JS::ShutdownAsyncTasks(cx) is called.\n\n Note: consumeChunk(), streamEnd() and streamError() may be called\n synchronously by ConsumeStreamCallback.\n\n When streamEnd() is called, the embedding may optionally pass an\n OptimizedEncodingListener*, indicating that there is a cache entry associated\n with this stream that can store an optimized encoding of the bytes that were\n just streamed at some point in the future by having SpiderMonkey call\n storeOptimizedEncoding(). Until the optimized encoding is ready, SpiderMonkey\n will hold an outstanding refcount to keep the listener alive.\n\n After storeOptimizedEncoding() is called, on cache hit, the embedding\n may call consumeOptimizedEncoding() instead of consumeChunk()/streamEnd().\n The embedding must ensure that the GetOptimizedEncodingBuildId() (see\n js/BuildId.h) at the time when an optimized encoding is created is the same\n as when it is later consumed."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct OptimizedEncodingListener {
            pub vtable_: *const OptimizedEncodingListener__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_OptimizedEncodingListener() {
            assert_eq!(
                ::std::mem::size_of::<OptimizedEncodingListener>(),
                8usize,
                concat!("Size of: ", stringify!(OptimizedEncodingListener))
            );
            assert_eq!(
                ::std::mem::align_of::<OptimizedEncodingListener>(),
                8usize,
                concat!("Alignment of ", stringify!(OptimizedEncodingListener))
            );
        }
        #[repr(C)]
        pub struct StreamConsumer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct StreamConsumer {
            pub vtable_: *const StreamConsumer__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_StreamConsumer() {
            assert_eq!(
                ::std::mem::size_of::<StreamConsumer>(),
                8usize,
                concat!("Size of: ", stringify!(StreamConsumer))
            );
            assert_eq!(
                ::std::mem::align_of::<StreamConsumer>(),
                8usize,
                concat!("Alignment of ", stringify!(StreamConsumer))
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MimeType {
            Wasm = 0,
        }
        pub type ConsumeStreamCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::HandleObject,
                arg3: root::JS::MimeType,
                arg4: *mut root::JS::StreamConsumer,
            ) -> bool,
        >;
        pub type ReportStreamErrorCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::JSContext, arg2: usize)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25InitConsumeStreamCallbackEP9JSContextPFbS1_NS_6HandleIP8JSObjectEENS_8MimeTypeEPNS_14StreamConsumerEEPFvS1_mE"]
            pub fn InitConsumeStreamCallback(
                cx: *mut root::JSContext,
                consume: root::JS::ConsumeStreamCallback,
                report: root::JS::ReportStreamErrorCallback,
            );
        }
        #[doc = " Timing information for telemetry purposes"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct JSTimers {
            pub executionTime: root::mozilla::TimeDuration,
            pub delazificationTime: root::mozilla::TimeDuration,
            pub xdrEncodingTime: root::mozilla::TimeDuration,
            pub gcTime: root::mozilla::TimeDuration,
            pub protectTime: root::mozilla::TimeDuration,
            pub baselineCompileTime: root::mozilla::TimeDuration,
        }
        #[test]
        fn bindgen_test_layout_JSTimers() {
            const UNINIT: ::std::mem::MaybeUninit<JSTimers> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<JSTimers>(),
                48usize,
                concat!("Size of: ", stringify!(JSTimers))
            );
            assert_eq!(
                ::std::mem::align_of::<JSTimers>(),
                8usize,
                concat!("Alignment of ", stringify!(JSTimers))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).executionTime) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSTimers),
                    "::",
                    stringify!(executionTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).delazificationTime) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSTimers),
                    "::",
                    stringify!(delazificationTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).xdrEncodingTime) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSTimers),
                    "::",
                    stringify!(xdrEncodingTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gcTime) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSTimers),
                    "::",
                    stringify!(gcTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).protectTime) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSTimers),
                    "::",
                    stringify!(protectTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).baselineCompileTime) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSTimers),
                    "::",
                    stringify!(baselineCompileTime)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11GetJSTimersEP9JSContext"]
            pub fn GetJSTimers(cx: *mut root::JSContext) -> root::JS::JSTimers;
        }
        pub type BeforeWaitCallback = ::std::option::Option<
            unsafe extern "C" fn(memory: *mut u8) -> *mut ::std::os::raw::c_void,
        >;
        pub type AfterWaitCallback =
            ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetWaitCallbackEP9JSRuntimePFPvPhEPFvS2_Em"]
            pub fn SetWaitCallback(
                rt: *mut root::JSRuntime,
                beforeWait: root::JS::BeforeWaitCallback,
                afterWait: root::JS::AfterWaitCallback,
                requiredMemory: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16NewWeakMapObjectEP9JSContext"]
            pub fn NewWeakMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15IsWeakMapObjectEP8JSObject"]
            pub fn IsWeakMapObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEES5_NS_13MutableHandleINS_5ValueEEE"]
            pub fn GetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleObject,
                val: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEES5_NS2_INS_5ValueEEE"]
            pub fn SetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleObject,
                val: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Tell JS engine whether to use fdlibm for Math.sin, Math.cos, and Math.tan.\n Using fdlibm ensures that we don't expose a math fingerprint."]
            #[link_name = "\u{1}_ZN2JS24SetUseFdlibmForSinCosTanEb"]
            pub fn SetUseFdlibmForSinCosTan(value: bool);
        }
        pub type ValueVector = u8;
        pub type ScriptVector = u8;
        pub type StringVector = u8;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21InformalValueTypeNameERKNS_5ValueE"]
            pub fn InformalValueTypeName(
                v: *const root::JS::Value,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24IdentifyStandardInstanceEP8JSObject"]
            pub fn IdentifyStandardInstance(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25IdentifyStandardPrototypeEP8JSObject"]
            pub fn IdentifyStandardPrototype(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS35IdentifyStandardInstanceOrPrototypeEP8JSObject"]
            pub fn IdentifyStandardInstanceOrPrototype(
                obj: *mut root::JSObject,
            ) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27IdentifyStandardConstructorEP8JSObject"]
            pub fn IdentifyStandardConstructor(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12ProtoKeyToIdEP9JSContext10JSProtoKeyNS_13MutableHandleINS_11PropertyKeyEEE"]
            pub fn ProtoKeyToId(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                idp: root::JS::MutableHandleId,
            );
        }
        extern "C" {
            #[doc = " Tell JS engine whether Profile Timeline Recording is enabled or not.\n If Profile Timeline Recording is enabled, data shown there like stack won't\n be optimized out.\n This is global state and not associated with specific runtime or context."]
            #[link_name = "\u{1}_ZN2JS34SetProfileTimelineRecordingEnabledEb"]
            pub fn SetProfileTimelineRecordingEnabled(enabled: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS33IsProfileTimelineRecordingEnabledEv"]
            pub fn IsProfileTimelineRecordingEnabled() -> bool;
        }
        extern "C" {
            #[doc = " Convert obj to a primitive value. On success, store the result in vp and\n return true.\n\n The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or\n JSTYPE_UNDEFINED (no hint).\n\n Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType])."]
            #[link_name = "\u{1}_ZN2JS11ToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn ToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                hint: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " If args.get(0) is one of the strings \"string\", \"number\", or \"default\", set\n result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_UNDEFINED accordingly and\n return true. Otherwise, return false with a TypeError pending.\n\n This can be useful in implementing a @@toPrimitive method."]
            #[link_name = "\u{1}_ZN2JS26GetFirstArgumentAsTypeHintEP9JSContextNS_8CallArgsEP6JSType"]
            pub fn GetFirstArgumentAsTypeHint(
                cx: *mut root::JSContext,
                args: root::JS::CallArgs,
                result: *mut root::JSType,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19OrdinaryHasInstanceEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn OrdinaryHasInstance(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
                v: root::JS::HandleValue,
                bp: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isMap| to true if |obj| is a Map object\n or a wrapper around one, or to false if not.  Returns false on failure.\n\n This method returns true with |*isMap == false| when passed an ES6 proxy\n whose target is a Map, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS11IsMapObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsMapObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isMap: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isSet| to true if |obj| is a Set object\n or a wrapper around one, or to false if not.  Returns false on failure.\n\n This method returns true with |*isSet == false| when passed an ES6 proxy\n whose target is a Set, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS11IsSetObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsSetObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isSet: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetSelfHostedFunctionEP9JSContextPKcNS_6HandleINS_11PropertyKeyEEEj"]
            pub fn GetSelfHostedFunction(
                cx: *mut root::JSContext,
                selfHostedName: *const ::std::os::raw::c_char,
                id: root::JS::HandleId,
                nargs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Create a new function based on the given JSFunctionSpec, *fs.\n id is the result of a successful call to\n `PropertySpecNameToId(cx, fs->name, &id)` or\n`PropertySpecNameToPermanentId(cx, fs->name, &id)`.\n\n Unlike JS_DefineFunctions, this does not treat fs as an array.\n *fs must not be JS_FS_END."]
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpecNS_6HandleINS_11PropertyKeyEEE"]
            pub fn NewFunctionFromSpec(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
                id: root::JS::HandleId,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Same as above, but without an id arg, for callers who don't have\n the id already."]
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpec"]
            pub fn NewFunctionFromSpec1(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
            ) -> *mut root::JSFunction;
        }
        #[doc = " Supply an alternative stack to incorporate into captured SavedFrame\n backtraces as the imputed caller of asynchronous JavaScript calls, like async\n function resumptions and DOM callbacks.\n\n When one async function awaits the result of another, it's natural to think\n of that as a sort of function call: just as execution resumes from an\n ordinary call expression when the callee returns, with the return value\n providing the value of the call expression, execution resumes from an 'await'\n expression after the awaited asynchronous function call returns, passing the\n return value along.\n\n Call the two async functions in such a situation the 'awaiter' and the\n 'awaitee'.\n\n As an async function, the awaitee contains 'await' expressions of its own.\n Whenever it executes after its first 'await', there are never any actual\n frames on the JavaScript stack under it; its awaiter is certainly not there.\n An await expression's continuation is invoked as a promise callback, and\n those are always called directly from the event loop in their own microtick.\n (Ignore unusual cases like nested event loops.)\n\n But because await expressions bear such a strong resemblance to calls (and\n deliberately so!), it would be unhelpful for stacks captured within the\n awaitee to be empty; instead, they should present the awaiter as the caller.\n\n The AutoSetAsyncStackForNewCalls RAII class supplies a SavedFrame stack to\n treat as the caller of any JavaScript invocations that occur within its\n lifetime. Any SavedFrame stack captured during such an invocation uses the\n SavedFrame passed to the constructor's 'stack' parameter as the 'asyncParent'\n property of the SavedFrame for the invocation's oldest frame. Its 'parent'\n property will be null, so stack-walking code can distinguish this\n awaiter/awaitee transition from an ordinary caller/callee transition.\n\n The constructor's 'asyncCause' parameter supplies a string explaining what\n sort of asynchronous call caused 'stack' to be spliced into the backtrace;\n for example, async function resumptions use the string \"async\". This appears\n as the 'asyncCause' property of the 'asyncParent' SavedFrame.\n\n Async callers are distinguished in the string form of a SavedFrame chain by\n including the 'asyncCause' string in the frame. It appears before the\n function name, with the two separated by a '*'.\n\n Note that, as each compartment has its own set of SavedFrames, the\n 'asyncParent' may actually point to a copy of 'stack', rather than the exact\n SavedFrame object passed.\n\n The youngest frame of 'stack' is not mutated to take the asyncCause string as\n its 'asyncCause' property; SavedFrame objects are immutable. Rather, a fresh\n clone of the frame is created with the needed 'asyncCause' property.\n\n The 'kind' argument specifies how aggressively 'stack' supplants any\n JavaScript frames older than this AutoSetAsyncStackForNewCalls object. If\n 'kind' is 'EXPLICIT', then all captured SavedFrame chains take on 'stack' as\n their 'asyncParent' where the chain crosses this object's scope. If 'kind' is\n 'IMPLICIT', then 'stack' is only included in captured chains if there are no\n other JavaScript frames on the stack --- that is, only if the stack would\n otherwise end at that point.\n\n AutoSetAsyncStackForNewCalls affects only SavedFrame chains; it does not\n affect Debugger.Frame or js::FrameIter. SavedFrame chains are used for\n Error.stack, allocation profiling, Promise debugging, and so on.\n\n See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async\n stack frames."]
        #[repr(C)]
        pub struct AutoSetAsyncStackForNewCalls {
            pub cx: *mut root::JSContext,
            pub oldAsyncStack: root::JS::RootedObject,
            pub oldAsyncCause: *const ::std::os::raw::c_char,
            pub oldAsyncCallIsExplicit: bool,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
            IMPLICIT = 0,
            EXPLICIT = 1,
        }
        #[test]
        fn bindgen_test_layout_AutoSetAsyncStackForNewCalls() {
            const UNINIT: ::std::mem::MaybeUninit<AutoSetAsyncStackForNewCalls> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoSetAsyncStackForNewCalls>(),
                48usize,
                concat!("Size of: ", stringify!(AutoSetAsyncStackForNewCalls))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSetAsyncStackForNewCalls>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoSetAsyncStackForNewCalls))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(cx)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).oldAsyncStack) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(oldAsyncStack)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).oldAsyncCause) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(oldAsyncCause)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).oldAsyncCallIsExplicit) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(oldAsyncCallIsExplicit)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24PropertySpecNameEqualsIdEN14JSPropertySpec4NameENS_6HandleINS_11PropertyKeyEEE"]
            pub fn PropertySpecNameEqualsId(
                name: root::JSPropertySpec_Name,
                id: root::JS::HandleId,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a jsid that does not need to be marked for GC.\n\n 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The\n resulting jsid, on success, is either an interned string or a well-known\n symbol; either way it is immune to GC so there is no need to visit *idp\n during GC marking."]
            #[link_name = "\u{1}_ZN2JS29PropertySpecNameToPermanentIdEP9JSContextN14JSPropertySpec4NameEPNS_11PropertyKeyE"]
            pub fn PropertySpecNameToPermanentId(
                cx: *mut root::JSContext,
                name: root::JSPropertySpec_Name,
                idp: *mut root::jsid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34DisableSpectreMitigationsAfterInitEv"]
            pub fn DisableSpectreMitigationsAfterInit();
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoFilename {
            pub ss_: *mut root::js::ScriptSource,
            pub filename_: [u64; 2usize],
        }
        #[test]
        fn bindgen_test_layout_AutoFilename() {
            const UNINIT: ::std::mem::MaybeUninit<AutoFilename> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoFilename>(),
                24usize,
                concat!("Size of: ", stringify!(AutoFilename))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoFilename>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoFilename))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ss_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoFilename),
                    "::",
                    stringify!(ss_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).filename_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoFilename),
                    "::",
                    stringify!(filename_)
                )
            );
        }
        extern "C" {
            #[doc = " Return the current filename, line number and column number of the most\n currently running frame. Returns true if a scripted frame was found, false\n otherwise.\n\n If a the embedding has hidden the scripted caller for the topmost activation\n record, this will also return false."]
            #[link_name = "\u{1}_ZN2JS22DescribeScriptedCallerEP9JSContextPNS_12AutoFilenameEPjS4_"]
            pub fn DescribeScriptedCaller(
                cx: *mut root::JSContext,
                filename: *mut root::JS::AutoFilename,
                lineno: *mut ::std::os::raw::c_uint,
                column: *mut ::std::os::raw::c_uint,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetScriptedCallerGlobalEP9JSContext"]
            pub fn GetScriptedCallerGlobal(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Informs the JS engine that the scripted caller should be hidden. This can be\n used by the embedding to maintain an override of the scripted caller in its\n calculations, by hiding the scripted caller in the JS engine and pushing data\n onto a separate stack, which it inspects when DescribeScriptedCaller returns\n null.\n\n We maintain a counter on each activation record. Add() increments the counter\n of the topmost activation, and Remove() decrements it. The count may never\n drop below zero, and must always be exactly zero when the activation is\n popped from the stack."]
            #[link_name = "\u{1}_ZN2JS18HideScriptedCallerEP9JSContext"]
            pub fn HideScriptedCaller(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UnhideScriptedCallerEP9JSContext"]
            pub fn UnhideScriptedCaller(cx: *mut root::JSContext);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoHideScriptedCaller {
            pub mContext: *mut root::JSContext,
        }
        #[test]
        fn bindgen_test_layout_AutoHideScriptedCaller() {
            const UNINIT: ::std::mem::MaybeUninit<AutoHideScriptedCaller> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AutoHideScriptedCaller>(),
                8usize,
                concat!("Size of: ", stringify!(AutoHideScriptedCaller))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoHideScriptedCaller>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoHideScriptedCaller))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mContext) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoHideScriptedCaller),
                    "::",
                    stringify!(mContext)
                )
            );
        }
        extern "C" {
            #[doc = " Attempt to disable Wasm's usage of reserving a large virtual memory\n allocation to avoid bounds checking overhead. This must be called before any\n Wasm module or memory is created in this process, or else this function will\n fail."]
            #[link_name = "\u{1}_ZN2JS21DisableWasmHugeMemoryEv"]
            pub fn DisableWasmHugeMemory() -> bool;
        }
        extern "C" {
            #[doc = " Return true iff the given object is either a SavedFrame object or wrapper\n around a SavedFrame object, and it is not the SavedFrame.prototype object."]
            #[link_name = "\u{1}_ZN2JS24IsMaybeWrappedSavedFrameEP8JSObject"]
            pub fn IsMaybeWrappedSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true iff the given object is a SavedFrame object and not the\n SavedFrame.prototype object."]
            #[link_name = "\u{1}_ZN2JS21IsUnwrappedSavedFrameEP8JSObject"]
            pub fn IsUnwrappedSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Set all of the uninitialized lexicals on an object to undefined. Return\n true if any lexicals were initialized and false otherwise."]
            #[link_name = "\u{1}_ZN2JS26ForceLexicalInitializationEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ForceLexicalInitialization(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether we are poisoning unused/released data for error detection. Governed\n by the JS_GC_ALLOW_EXTRA_POISONING #ifdef as well as the\n $JSGC_EXTRA_POISONING environment variable."]
            #[link_name = "\u{1}_ZN2JS13IsGCPoisoningEv"]
            pub fn IsGCPoisoning() -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetRealmPrincipalsEPNS_5RealmE"]
            pub fn GetRealmPrincipals(realm: *mut root::JS::Realm) -> *mut root::JSPrincipals;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18SetRealmPrincipalsEPNS_5RealmEP12JSPrincipals"]
            pub fn SetRealmPrincipals(
                realm: *mut root::JS::Realm,
                principals: *mut root::JSPrincipals,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetIsSecureContextEPNS_5RealmE"]
            pub fn GetIsSecureContext(realm: *mut root::JS::Realm) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetDebuggerObservesWasmEPNS_5RealmE"]
            pub fn GetDebuggerObservesWasm(realm: *mut root::JS::Realm) -> bool;
        }
        #[doc = " <div rustbindgen replaces=\"JS::CallArgs\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CallArgs {
            pub argv_: *mut root::JS::Value,
            pub argc_: ::std::os::raw::c_uint,
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        #[test]
        fn bindgen_test_layout_CallArgs() {
            const UNINIT: ::std::mem::MaybeUninit<CallArgs> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CallArgs>(),
                16usize,
                concat!("Size of: ", stringify!(CallArgs))
            );
            assert_eq!(
                ::std::mem::align_of::<CallArgs>(),
                8usize,
                concat!("Alignment of ", stringify!(CallArgs))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).argv_) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CallArgs),
                    "::",
                    stringify!(argv_)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).argc_) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CallArgs),
                    "::",
                    stringify!(argc_)
                )
            );
        }
        impl CallArgs {
            #[inline]
            pub fn constructing_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_constructing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignoresReturnValue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_ignoresReturnValue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                constructing_: bool,
                ignoresReturnValue_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let constructing_: u8 = unsafe { ::std::mem::transmute(constructing_) };
                    constructing_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let ignoresReturnValue_: u8 =
                        unsafe { ::std::mem::transmute(ignoresReturnValue_) };
                    ignoresReturnValue_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " <div rustbindgen replaces=\"JS::MutableHandleIdVector\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleIdVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_MutableHandleIdVector() {
            const UNINIT: ::std::mem::MaybeUninit<MutableHandleIdVector> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<MutableHandleIdVector>(),
                8usize,
                concat!("Size of: ", stringify!(MutableHandleIdVector))
            );
            assert_eq!(
                ::std::mem::align_of::<MutableHandleIdVector>(),
                8usize,
                concat!("Alignment of ", stringify!(MutableHandleIdVector))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MutableHandleIdVector),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        #[doc = " <div rustbindgen replaces=\"JS::HandleObjectVector\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_HandleObjectVector() {
            const UNINIT: ::std::mem::MaybeUninit<HandleObjectVector> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<HandleObjectVector>(),
                8usize,
                concat!("Size of: ", stringify!(HandleObjectVector))
            );
            assert_eq!(
                ::std::mem::align_of::<HandleObjectVector>(),
                8usize,
                concat!("Alignment of ", stringify!(HandleObjectVector))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleObjectVector),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        #[doc = " <div rustbindgen replaces=\"JS::MutableHandleObjectVector\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_MutableHandleObjectVector() {
            const UNINIT: ::std::mem::MaybeUninit<MutableHandleObjectVector> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<MutableHandleObjectVector>(),
                8usize,
                concat!("Size of: ", stringify!(MutableHandleObjectVector))
            );
            assert_eq!(
                ::std::mem::align_of::<MutableHandleObjectVector>(),
                8usize,
                concat!("Alignment of ", stringify!(MutableHandleObjectVector))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MutableHandleObjectVector),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Realm_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
    }
    pub type jsid = root::JS::PropertyKey;
    pub mod __pstl {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod execution {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    #[doc = " already_AddRefed cooperates with reference counting smart pointers to enable\n you to assign in a pointer _without_ |AddRef|ing it.  You might want to use\n this as a return type from a function that returns an already |AddRef|ed\n pointer.\n\n TODO Move already_AddRefed to namespace mozilla.  This has not yet been done\n because of the sheer number of usages of already_AddRefed.\n\n When should you use already_AddRefed<>?\n * Ensure a consumer takes ownership of a reference\n * Pass ownership without calling AddRef/Release (sometimes required in\n   off-main-thread code)\n * The ref pointer type you're using doesn't support move construction\n\n Otherwise, use std::move(RefPtr/nsCOMPtr/etc)."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct already_AddRefed<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RefPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_Proxy {
        pub _address: u8,
    }
    pub type RefPtr_Proxy_member_function = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_ConstRemovingRefPtrTraits {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSLinearString {
        _unused: [u8; 0],
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSType {
        JSTYPE_UNDEFINED = 0,
        JSTYPE_OBJECT = 1,
        JSTYPE_FUNCTION = 2,
        JSTYPE_STRING = 3,
        JSTYPE_NUMBER = 4,
        JSTYPE_BOOLEAN = 5,
        JSTYPE_SYMBOL = 6,
        JSTYPE_BIGINT = 7,
        JSTYPE_LIMIT = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSProtoKey {
        JSProto_Null = 0,
        JSProto_Object = 1,
        JSProto_Function = 2,
        JSProto_Array = 3,
        JSProto_Boolean = 4,
        JSProto_JSON = 5,
        JSProto_Date = 6,
        JSProto_Math = 7,
        JSProto_Number = 8,
        JSProto_String = 9,
        JSProto_RegExp = 10,
        JSProto_Error = 11,
        JSProto_InternalError = 12,
        JSProto_AggregateError = 13,
        JSProto_EvalError = 14,
        JSProto_RangeError = 15,
        JSProto_ReferenceError = 16,
        JSProto_SyntaxError = 17,
        JSProto_TypeError = 18,
        JSProto_URIError = 19,
        JSProto_DebuggeeWouldRun = 20,
        JSProto_CompileError = 21,
        JSProto_LinkError = 22,
        JSProto_RuntimeError = 23,
        JSProto_ArrayBuffer = 24,
        JSProto_Int8Array = 25,
        JSProto_Uint8Array = 26,
        JSProto_Int16Array = 27,
        JSProto_Uint16Array = 28,
        JSProto_Int32Array = 29,
        JSProto_Uint32Array = 30,
        JSProto_Float32Array = 31,
        JSProto_Float64Array = 32,
        JSProto_Uint8ClampedArray = 33,
        JSProto_BigInt64Array = 34,
        JSProto_BigUint64Array = 35,
        JSProto_BigInt = 36,
        JSProto_Proxy = 37,
        JSProto_WeakMap = 38,
        JSProto_Map = 39,
        JSProto_Set = 40,
        JSProto_DataView = 41,
        JSProto_Symbol = 42,
        JSProto_ShadowRealm = 43,
        JSProto_SharedArrayBuffer = 44,
        JSProto_Intl = 45,
        JSProto_Collator = 46,
        JSProto_DateTimeFormat = 47,
        JSProto_DisplayNames = 48,
        JSProto_ListFormat = 49,
        JSProto_Locale = 50,
        JSProto_NumberFormat = 51,
        JSProto_PluralRules = 52,
        JSProto_RelativeTimeFormat = 53,
        JSProto_Reflect = 54,
        JSProto_WeakSet = 55,
        JSProto_TypedArray = 56,
        JSProto_Atomics = 57,
        JSProto_SavedFrame = 58,
        JSProto_Promise = 59,
        JSProto_AsyncFunction = 60,
        JSProto_GeneratorFunction = 61,
        JSProto_AsyncGeneratorFunction = 62,
        JSProto_ReadableStream = 63,
        JSProto_ReadableStreamDefaultReader = 64,
        JSProto_ReadableStreamDefaultController = 65,
        JSProto_ReadableByteStreamController = 66,
        JSProto_ByteLengthQueuingStrategy = 67,
        JSProto_CountQueuingStrategy = 68,
        JSProto_WebAssembly = 69,
        JSProto_WasmModule = 70,
        JSProto_WasmInstance = 71,
        JSProto_WasmMemory = 72,
        JSProto_WasmTable = 73,
        JSProto_WasmGlobal = 74,
        JSProto_WasmTag = 75,
        JSProto_WasmFunction = 76,
        JSProto_WasmException = 77,
        JSProto_FinalizationRegistry = 78,
        JSProto_WeakRef = 79,
        JSProto_Iterator = 80,
        JSProto_AsyncIterator = 81,
        JSProto_LIMIT = 82,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneReader {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneWriter {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSConstScalarSpec {
        pub _address: u8,
    }
    pub type JSConstDoubleSpec = root::JSConstScalarSpec;
    pub type JSConstIntegerSpec = root::JSConstScalarSpec;
    #[repr(C)]
    pub struct JSTracer__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSTracer {
        pub vtable_: *const JSTracer__bindgen_vtable,
        pub runtime_: *mut root::JSRuntime,
        pub kind_: root::JS::TracerKind,
        pub options_: root::JS::TraceOptions,
        pub context_: root::JS::TracingContext,
    }
    #[test]
    fn bindgen_test_layout_JSTracer() {
        const UNINIT: ::std::mem::MaybeUninit<JSTracer> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSTracer>(),
            48usize,
            concat!("Size of: ", stringify!(JSTracer))
        );
        assert_eq!(
            ::std::mem::align_of::<JSTracer>(),
            8usize,
            concat!("Alignment of ", stringify!(JSTracer))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).runtime_) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(runtime_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).kind_) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(kind_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).options_) as usize - ptr as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(options_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).context_) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(context_)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ProfilingStack {
        pub capacity: u32,
        pub frames: u64,
        pub stackPointer: u32,
    }
    #[test]
    fn bindgen_test_layout_ProfilingStack() {
        const UNINIT: ::std::mem::MaybeUninit<ProfilingStack> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ProfilingStack>(),
            24usize,
            concat!("Size of: ", stringify!(ProfilingStack))
        );
        assert_eq!(
            ::std::mem::align_of::<ProfilingStack>(),
            8usize,
            concat!("Alignment of ", stringify!(ProfilingStack))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ProfilingStack),
                "::",
                stringify!(capacity)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ProfilingStack),
                "::",
                stringify!(frames)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).stackPointer) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ProfilingStack),
                "::",
                stringify!(stackPointer)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    #[test]
    fn bindgen_test_layout_JSAutoRealm() {
        const UNINIT: ::std::mem::MaybeUninit<JSAutoRealm> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSAutoRealm>(),
            16usize,
            concat!("Size of: ", stringify!(JSAutoRealm))
        );
        assert_eq!(
            ::std::mem::align_of::<JSAutoRealm>(),
            8usize,
            concat!("Alignment of ", stringify!(JSAutoRealm))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).cx_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoRealm),
                "::",
                stringify!(cx_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).oldRealm_) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoRealm),
                "::",
                stringify!(oldRealm_)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoNullableRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    #[test]
    fn bindgen_test_layout_JSAutoNullableRealm() {
        const UNINIT: ::std::mem::MaybeUninit<JSAutoNullableRealm> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSAutoNullableRealm>(),
            16usize,
            concat!("Size of: ", stringify!(JSAutoNullableRealm))
        );
        assert_eq!(
            ::std::mem::align_of::<JSAutoNullableRealm>(),
            8usize,
            concat!("Alignment of ", stringify!(JSAutoNullableRealm))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).cx_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoNullableRealm),
                "::",
                stringify!(cx_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).oldRealm_) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoNullableRealm),
                "::",
                stringify!(oldRealm_)
            )
        );
    }
    #[repr(C)]
    pub struct JSPrincipals__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSPrincipals {
        pub vtable_: *const JSPrincipals__bindgen_vtable,
        pub refcount: u32,
    }
    #[test]
    fn bindgen_test_layout_JSPrincipals() {
        const UNINIT: ::std::mem::MaybeUninit<JSPrincipals> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPrincipals>(),
            16usize,
            concat!("Size of: ", stringify!(JSPrincipals))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPrincipals>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPrincipals))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPrincipals),
                "::",
                stringify!(refcount)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_HoldPrincipalsP12JSPrincipals"]
        pub fn JS_HoldPrincipals(principals: *mut root::JSPrincipals);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DropPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_DropPrincipals(cx: *mut root::JSContext, principals: *mut root::JSPrincipals);
    }
    pub type JSSubsumesOp = ::std::option::Option<
        unsafe extern "C" fn(
            first: *mut root::JSPrincipals,
            second: *mut root::JSPrincipals,
        ) -> bool,
    >;
    pub type JSCSPEvalChecker = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            kind: root::JS::RuntimeCode,
            code: root::JS::HandleString,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSSecurityCallbacks {
        pub contentSecurityPolicyAllows: root::JSCSPEvalChecker,
        pub subsumes: root::JSSubsumesOp,
    }
    #[test]
    fn bindgen_test_layout_JSSecurityCallbacks() {
        const UNINIT: ::std::mem::MaybeUninit<JSSecurityCallbacks> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSSecurityCallbacks>(),
            16usize,
            concat!("Size of: ", stringify!(JSSecurityCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSSecurityCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSSecurityCallbacks))
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).contentSecurityPolicyAllows) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSSecurityCallbacks),
                "::",
                stringify!(contentSecurityPolicyAllows)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).subsumes) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSSecurityCallbacks),
                "::",
                stringify!(subsumes)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetSecurityCallbacksP9JSContextPK19JSSecurityCallbacks"]
        pub fn JS_SetSecurityCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSSecurityCallbacks,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetSecurityCallbacksP9JSContext"]
        pub fn JS_GetSecurityCallbacks(
            cx: *mut root::JSContext,
        ) -> *const root::JSSecurityCallbacks;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetTrustedPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_SetTrustedPrincipals(cx: *mut root::JSContext, prin: *mut root::JSPrincipals);
    }
    pub type JSDestroyPrincipalsOp =
        ::std::option::Option<unsafe extern "C" fn(principals: *mut root::JSPrincipals)>;
    extern "C" {
        #[link_name = "\u{1}_Z32JS_InitDestroyPrincipalsCallbackP9JSContextPFvP12JSPrincipalsE"]
        pub fn JS_InitDestroyPrincipalsCallback(
            cx: *mut root::JSContext,
            destroyPrincipals: root::JSDestroyPrincipalsOp,
        );
    }
    pub type JSReadPrincipalsOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            reader: *mut root::JSStructuredCloneReader,
            outPrincipals: *mut *mut root::JSPrincipals,
        ) -> bool,
    >;
    extern "C" {
        #[link_name = "\u{1}_Z29JS_InitReadPrincipalsCallbackP9JSContextPFbS0_P23JSStructuredCloneReaderPP12JSPrincipalsE"]
        pub fn JS_InitReadPrincipalsCallback(
            cx: *mut root::JSContext,
            read: root::JSReadPrincipalsOp,
        );
    }
    extern "C" {
        #[doc = " Set the size of the native stack that should not be exceed. To disable\n stack size checking pass 0.\n\n SpiderMonkey allows for a distinction between system code (such as GCs, which\n may incidentally be triggered by script but are not strictly performed on\n behalf of such script), trusted script (as determined by\n JS_SetTrustedPrincipals), and untrusted script. Each kind of code may have a\n different stack quota, allowing embedders to keep higher-priority machinery\n running in the face of scripted stack exhaustion by something else.\n\n The stack quotas for each kind of code should be monotonically descending,\n and may be specified with this function. If 0 is passed for a given kind\n of code, it defaults to the value of the next-highest-priority kind.\n\n This function may only be called immediately after the runtime is initialized\n and before any code is executed and/or interrupts requested."]
        #[link_name = "\u{1}_Z22JS_SetNativeStackQuotaP9JSContextmmm"]
        pub fn JS_SetNativeStackQuota(
            cx: *mut root::JSContext,
            systemCodeStackSize: root::JS::NativeStackSize,
            trustedScriptStackSize: root::JS::NativeStackSize,
            untrustedScriptStackSize: root::JS::NativeStackSize,
        );
    }
    pub type arena_id_t = usize;
    extern "C" {
        #[link_name = "\u{1}_Z9JS_AssertPKcS0_i"]
        pub fn JS_Assert(
            s: *const ::std::os::raw::c_char,
            file: *const ::std::os::raw::c_char,
            ln: ::std::os::raw::c_int,
        ) -> !;
    }
    extern "C" {
        #[doc = " Given a buffer, return false if the buffer might become a valid JavaScript\n script with the addition of more lines, or true if the validity of such a\n script is conclusively known (because it's the prefix of a valid script --\n and possibly the entirety of such a script).\n\n The intent of this function is to enable interactive compilation: accumulate\n lines in a buffer until JS_Utf8BufferIsCompilableUnit is true, then pass it\n to the compiler.\n\n The provided buffer is interpreted as UTF-8 data.  An error is reported if\n a UTF-8 encoding error is encountered."]
        #[link_name = "\u{1}_Z29JS_Utf8BufferIsCompilableUnitP9JSContextN2JS6HandleIP8JSObjectEEPKcm"]
        pub fn JS_Utf8BufferIsCompilableUnit(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            utf8: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Evaluate a script in the scope of the current global of cx."]
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_ExecuteScript1(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " As above, but providing an explicit scope chain.  envChain must not include\n the global object on it; that's implicit.  It needs to contain the other\n objects that should end up on the script's scope chain."]
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleINS1_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEENS2_IP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript2(
            cx: *mut root::JSContext,
            envChain: root::JS::HandleObjectVector,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleINS1_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEENS2_IP8JSScriptEE"]
        pub fn JS_ExecuteScript3(
            cx: *mut root::JSContext,
            envChain: root::JS::HandleObjectVector,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueType {
        JSVAL_TYPE_DOUBLE = 0,
        JSVAL_TYPE_INT32 = 1,
        JSVAL_TYPE_BOOLEAN = 2,
        JSVAL_TYPE_UNDEFINED = 3,
        JSVAL_TYPE_NULL = 4,
        JSVAL_TYPE_MAGIC = 5,
        JSVAL_TYPE_STRING = 6,
        JSVAL_TYPE_SYMBOL = 7,
        JSVAL_TYPE_PRIVATE_GCTHING = 8,
        JSVAL_TYPE_BIGINT = 9,
        JSVAL_TYPE_OBJECT = 12,
        JSVAL_TYPE_UNKNOWN = 32,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueTag {
        JSVAL_TAG_MAX_DOUBLE = 131056,
        JSVAL_TAG_INT32 = 131057,
        JSVAL_TAG_UNDEFINED = 131059,
        JSVAL_TAG_NULL = 131060,
        JSVAL_TAG_BOOLEAN = 131058,
        JSVAL_TAG_MAGIC = 131061,
        JSVAL_TAG_STRING = 131062,
        JSVAL_TAG_SYMBOL = 131063,
        JSVAL_TAG_PRIVATE_GCTHING = 131064,
        JSVAL_TAG_BIGINT = 131065,
        JSVAL_TAG_OBJECT = 131068,
    }
    #[repr(u64)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueShiftedTag {
        JSVAL_SHIFTED_TAG_MAX_DOUBLE = 18444492278190833663,
        JSVAL_SHIFTED_TAG_INT32 = 18444633011384221696,
        JSVAL_SHIFTED_TAG_UNDEFINED = 18444914486360932352,
        JSVAL_SHIFTED_TAG_NULL = 18445055223849287680,
        JSVAL_SHIFTED_TAG_BOOLEAN = 18444773748872577024,
        JSVAL_SHIFTED_TAG_MAGIC = 18445195961337643008,
        JSVAL_SHIFTED_TAG_STRING = 18445336698825998336,
        JSVAL_SHIFTED_TAG_SYMBOL = 18445477436314353664,
        JSVAL_SHIFTED_TAG_PRIVATE_GCTHING = 18445618173802708992,
        JSVAL_SHIFTED_TAG_BIGINT = 18445758911291064320,
        JSVAL_SHIFTED_TAG_OBJECT = 18446181123756130304,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSWhyMagic {
        #[doc = " a hole in a native object's elements"]
        JS_ELEMENTS_HOLE = 0,
        #[doc = " there is not a pending iterator value"]
        JS_NO_ITER_VALUE = 1,
        #[doc = " exception value thrown when closing a generator"]
        JS_GENERATOR_CLOSING = 2,
        #[doc = " used in debug builds to catch tracing errors"]
        JS_ARG_POISON = 3,
        #[doc = " an empty subnode in the AST serializer"]
        JS_SERIALIZE_NO_NODE = 4,
        #[doc = " magic value passed to natives to indicate construction"]
        JS_IS_CONSTRUCTING = 5,
        #[doc = " see class js::HashableValue"]
        JS_HASH_KEY_EMPTY = 6,
        #[doc = " error while running Ion code"]
        JS_ION_ERROR = 7,
        #[doc = " missing recover instruction result"]
        JS_ION_BAILOUT = 8,
        #[doc = " optimized out slot"]
        JS_OPTIMIZED_OUT = 9,
        #[doc = " uninitialized lexical bindings that produce ReferenceError on touch."]
        JS_UNINITIALIZED_LEXICAL = 10,
        #[doc = " arguments object can't be created because environment is dead."]
        JS_MISSING_ARGUMENTS = 11,
        #[doc = " for local use"]
        JS_GENERIC_MAGIC = 12,
        #[doc = " When an error object is created without the error cause argument, we set\n the error's cause slot to this magic value."]
        JS_ERROR_WITHOUT_CAUSE = 13,
        #[doc = " When an error object is created without the error cause argument, we set\n the error's cause slot to this magic value."]
        JS_WHY_MAGIC_COUNT = 14,
    }
    pub type JS_ICUAllocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUReallocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            p: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUFreeFn = ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, p: *mut ::std::os::raw::c_void),
    >;
    extern "C" {
        #[doc = " This function can be used to track memory used by ICU.  If it is called, it\n *must* be called before JS_Init.  Don't use it unless you know what you're\n doing!"]
        #[link_name = "\u{1}_Z24JS_SetICUMemoryFunctionsPFPvPKvmEPFS_S1_S_mEPFvS1_S_E"]
        pub fn JS_SetICUMemoryFunctions(
            allocFn: root::JS_ICUAllocFn,
            reallocFn: root::JS_ICUReallocFn,
            freeFn: root::JS_ICUFreeFn,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Destroy free-standing resources allocated by SpiderMonkey, not associated\n with any runtime, context, or other structure.\n\n This method should be called after all other JSAPI data has been properly\n cleaned up: every new runtime must have been destroyed, every new context\n must have been destroyed, and so on.  Calling this method before all other\n resources have been destroyed has undefined behavior.\n\n Failure to call this method, at present, has no adverse effects other than\n leaking memory.  This may not always be the case; it's recommended that all\n embedders call this method when all other JSAPI operations have completed.\n\n It is currently not possible to initialize SpiderMonkey multiple times (that\n is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so\n again).  This restriction may eventually be lifted."]
        #[link_name = "\u{1}_Z11JS_ShutDownv"]
        pub fn JS_ShutDown();
    }
    pub type JSONWriteCallback = ::std::option::Option<
        unsafe extern "C" fn(buf: *const u16, len: u32, data: *mut ::std::os::raw::c_void) -> bool,
    >;
    extern "C" {
        #[doc = " Performs the JSON.stringify operation, as specified by ECMAScript, except\n writing stringified data by repeated calls of |callback|, with each such\n call passed |data| as argument."]
        #[link_name = "\u{1}_Z12JS_StringifyP9JSContextN2JS13MutableHandleINS1_5ValueEEENS1_6HandleIP8JSObjectEENS5_IS3_EEPFbPKDsjPvESC_"]
        pub fn JS_Stringify(
            cx: *mut root::JSContext,
            value: root::JS::MutableHandle<root::JS::Value>,
            replacer: root::JS::Handle<*mut root::JSObject>,
            space: root::JS::Handle<root::JS::Value>,
            callback: root::JSONWriteCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript."]
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextPKDsjN2JS13MutableHandleINS3_5ValueEEE"]
        pub fn JS_ParseJSON(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript."]
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ParseJSON1(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript, using the\n given |reviver| argument as the corresponding optional argument to that\n function."]
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextPKDsjN2JS6HandleINS3_5ValueEEENS3_13MutableHandleIS5_EE"]
        pub fn JS_ParseJSONWithReviver(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript, using the\n given |reviver| argument as the corresponding optional argument to that\n function."]
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextN2JS6HandleIP8JSStringEENS2_INS1_5ValueEEENS1_13MutableHandleIS6_EE"]
        pub fn JS_ParseJSONWithReviver1(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Complain when out of memory."]
        #[link_name = "\u{1}_Z20JS_ReportOutOfMemoryP9JSContext"]
        pub fn JS_ReportOutOfMemory(cx: *mut root::JSContext);
    }
    pub type JSNative = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtomState {
        _unused: [u8; 0],
    }
    #[doc = " Add a property named by id to obj."]
    pub type JSAddPropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            v: root::JS::HandleValue,
        ) -> bool,
    >;
    #[doc = " Delete a property named by id in obj.\n\n If an error occurred, return false as per normal JSAPI error practice.\n\n If no error occurred, but the deletion attempt wasn't allowed (perhaps\n because the property was non-configurable), call result.fail() and\n return true.  This will cause |delete obj[id]| to evaluate to false in\n non-strict mode code, and to throw a TypeError in strict mode code.\n\n If no error occurred and the deletion wasn't disallowed (this is *not* the\n same as saying that a deletion actually occurred -- deleting a non-existent\n property, or an inherited property, is allowed -- it's just pointless),\n call result.succeed() and return true."]
    pub type JSDeletePropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool,
    >;
    #[doc = " The type of ObjectOps::enumerate. This callback overrides a portion of\n SpiderMonkey's default [[Enumerate]] internal method. When an ordinary object\n is enumerated, that object and each object on its prototype chain is tested\n for an enumerate op, and those ops are called in order. The properties each\n op adds to the 'properties' vector are added to the set of values the for-in\n loop will iterate over. All of this is nonstandard.\n\n An object is \"enumerated\" when it's the target of a for-in loop or\n JS_Enumerate(). The callback's job is to populate 'properties' with the\n object's property keys. If `enumerableOnly` is true, the callback should only\n add enumerable properties."]
    pub type JSNewEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool,
    >;
    #[doc = " The old-style JSClass.enumerate op should define all lazy properties not\n yet reflected in obj."]
    pub type JSEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool,
    >;
    #[doc = " The type of ObjectOps::funToString.  This callback allows an object to\n provide a custom string to use when Function.prototype.toString is invoked on\n that object.  A null return value means OOM."]
    pub type JSFunToStringOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isToSource: bool,
        ) -> *mut root::JSString,
    >;
    #[doc = " Resolve a lazy property named by id in obj by defining it directly in obj.\n Lazy properties are those reflected from some peer native property space\n (e.g., the DOM attributes for a given node reflected as obj) on demand.\n\n JS looks for a property in an object, and if not found, tries to resolve\n the given id. *resolvedp should be set to true iff the property was defined\n on |obj|."]
    pub type JSResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolvedp: *mut bool,
        ) -> bool,
    >;
    #[doc = " A class with a resolve hook can optionally have a mayResolve hook. This hook\n must have no side effects and must return true for a given id if the resolve\n hook may resolve this id. This is useful when we're doing a \"pure\" lookup: if\n mayResolve returns false, we know we don't have to call the effectful resolve\n hook.\n\n maybeObj, if non-null, is the object on which we're doing the lookup. This\n can be nullptr: during JIT compilation we sometimes know the Class but not\n the object."]
    pub type JSMayResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool,
    >;
    #[doc = " Finalize obj, which the garbage collector has determined to be unreachable\n from other live objects or from GC roots.  Obviously, finalizers must never\n store a reference to obj."]
    pub type JSFinalizeOp = ::std::option::Option<
        unsafe extern "C" fn(gcx: *mut root::JS::GCContext, obj: *mut root::JSObject),
    >;
    #[doc = " Function type for trace operation of the class called to enumerate all\n traceable things reachable from obj's private data structure. For each such\n thing, a trace implementation must call JS::TraceEdge on the thing's\n location.\n\n JSTraceOp implementation can assume that no other threads mutates object\n state. It must not change state of the object or corresponding native\n structures. The only exception for this rule is the case when the embedding\n needs a tight integration with GC. In that case the embedding can check if\n the traversal is a part of the marking phase through calling\n JS_IsGCMarkingTracer and apply a special code like emptying caches or\n marking its native structures."]
    pub type JSTraceOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, obj: *mut root::JSObject),
    >;
    pub type JSObjectMovedOp = ::std::option::Option<
        unsafe extern "C" fn(obj: *mut root::JSObject, old: *mut root::JSObject) -> usize,
    >;
    extern "C" {
        #[link_name = "\u{1}_ZL18JS_NULL_CLASS_SPEC"]
        pub static JS_NULL_CLASS_SPEC: *const root::js::ClassSpec;
    }
    extern "C" {
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_EXT"]
        pub static JS_NULL_CLASS_EXT: *const root::js::ClassExtension;
    }
    extern "C" {
        #[link_name = "\u{1}_ZL18JS_NULL_OBJECT_OPS"]
        pub static JS_NULL_OBJECT_OPS: *const root::js::ObjectOps;
    }
    pub const JSCLASS_DELAY_METADATA_BUILDER: u32 = 2;
    pub const JSCLASS_IS_WRAPPED_NATIVE: u32 = 4;
    pub const JSCLASS_SLOT0_IS_NSISUPPORTS: u32 = 8;
    pub const JSCLASS_IS_DOMJSCLASS: u32 = 16;
    pub const JSCLASS_HAS_XRAYED_CONSTRUCTOR: u32 = 32;
    pub const JSCLASS_EMULATES_UNDEFINED: u32 = 64;
    pub const JSCLASS_USERBIT1: u32 = 128;
    pub const JSCLASS_RESERVED_SLOTS_SHIFT: usize = 8;
    pub const JSCLASS_RESERVED_SLOTS_WIDTH: u32 = 8;
    pub const JSCLASS_RESERVED_SLOTS_MASK: u32 = 255;
    pub const JSCLASS_HIGH_FLAGS_SHIFT: u32 = 16;
    pub const JSCLASS_INTERNAL_FLAG1: u32 = 65536;
    pub const JSCLASS_IS_GLOBAL: u32 = 131072;
    pub const JSCLASS_INTERNAL_FLAG2: u32 = 262144;
    pub const JSCLASS_IS_PROXY: u32 = 524288;
    pub const JSCLASS_SKIP_NURSERY_FINALIZE: u32 = 1048576;
    pub const JSCLASS_USERBIT2: u32 = 2097152;
    pub const JSCLASS_USERBIT3: u32 = 4194304;
    pub const JSCLASS_BACKGROUND_FINALIZE: u32 = 8388608;
    pub const JSCLASS_FOREGROUND_FINALIZE: u32 = 16777216;
    pub const JSCLASS_GLOBAL_APPLICATION_SLOTS: u32 = 5;
    pub const JSCLASS_GLOBAL_SLOT_COUNT: u32 = 6;
    pub const JSCLASS_GLOBAL_FLAGS: u32 = 132608;
    pub const JSCLASS_CACHED_PROTO_SHIFT: u32 = 25;
    pub const JSCLASS_CACHED_PROTO_MASK: u32 = 127;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSClassOps {
        pub addProperty: root::JSAddPropertyOp,
        pub delProperty: root::JSDeletePropertyOp,
        pub enumerate: root::JSEnumerateOp,
        pub newEnumerate: root::JSNewEnumerateOp,
        pub resolve: root::JSResolveOp,
        pub mayResolve: root::JSMayResolveOp,
        pub finalize: root::JSFinalizeOp,
        pub call: root::JSNative,
        pub construct: root::JSNative,
        pub trace: root::JSTraceOp,
    }
    #[test]
    fn bindgen_test_layout_JSClassOps() {
        const UNINIT: ::std::mem::MaybeUninit<JSClassOps> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSClassOps>(),
            80usize,
            concat!("Size of: ", stringify!(JSClassOps))
        );
        assert_eq!(
            ::std::mem::align_of::<JSClassOps>(),
            8usize,
            concat!("Alignment of ", stringify!(JSClassOps))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).addProperty) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(addProperty)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).delProperty) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(delProperty)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).enumerate) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(enumerate)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).newEnumerate) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(newEnumerate)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).resolve) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(resolve)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mayResolve) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(mayResolve)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(finalize)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).call) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(call)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).construct) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(construct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).trace) as usize - ptr as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(trace)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_OPS"]
        pub static JS_NULL_CLASS_OPS: *const root::JSClassOps;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSClass {
        pub name: *const ::std::os::raw::c_char,
        pub flags: u32,
        pub cOps: *const root::JSClassOps,
        pub spec: *const root::js::ClassSpec,
        pub ext: *const root::js::ClassExtension,
        pub oOps: *const root::js::ObjectOps,
    }
    pub const JSClass_NON_NATIVE: u32 = 262144;
    #[test]
    fn bindgen_test_layout_JSClass() {
        const UNINIT: ::std::mem::MaybeUninit<JSClass> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSClass>(),
            48usize,
            concat!("Size of: ", stringify!(JSClass))
        );
        assert_eq!(
            ::std::mem::align_of::<JSClass>(),
            8usize,
            concat!("Alignment of ", stringify!(JSClass))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).cOps) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(cOps)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).spec) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(spec)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).ext) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(ext)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).oOps) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(oOps)
            )
        );
    }
    #[doc = " The property is visible in for/in loops."]
    pub const JSPROP_ENUMERATE: u8 = 1;
    #[doc = " The property is non-writable.  This flag is only valid for data properties."]
    pub const JSPROP_READONLY: u8 = 2;
    #[doc = " The property is non-configurable: it can't be deleted, and if it's an\n accessor descriptor, its getter and setter can't be changed."]
    pub const JSPROP_PERMANENT: u8 = 4;
    #[doc = " Resolve hooks and enumerate hooks must pass this flag when calling\n JS_Define* APIs to reify lazily-defined properties.\n\n JSPROP_RESOLVING is used only with property-defining APIs. It tells the\n engine to skip the resolve hook when performing the lookup at the beginning\n of property definition. This keeps the resolve hook from accidentally\n triggering itself: unchecked recursion.\n\n For enumerate hooks, triggering the resolve hook would be merely silly, not\n fatal, except in some cases involving non-configurable properties."]
    pub const JSPROP_RESOLVING: ::std::os::raw::c_uint = 8;
    pub const JSPROP_FLAGS_MASK: ::std::os::raw::c_uint = 15;
    #[doc = " Wrapper to relace JSNative for JSPropertySpecs and JSFunctionSpecs. This will\n allow us to pass one JSJitInfo per function with the property/function spec,\n without additional field overhead."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSNativeWrapper {
        pub op: root::JSNative,
        pub info: *const root::JSJitInfo,
    }
    #[test]
    fn bindgen_test_layout_JSNativeWrapper() {
        const UNINIT: ::std::mem::MaybeUninit<JSNativeWrapper> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSNativeWrapper>(),
            16usize,
            concat!("Size of: ", stringify!(JSNativeWrapper))
        );
        assert_eq!(
            ::std::mem::align_of::<JSNativeWrapper>(),
            8usize,
            concat!("Alignment of ", stringify!(JSNativeWrapper))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSNativeWrapper),
                "::",
                stringify!(op)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSNativeWrapper),
                "::",
                stringify!(info)
            )
        );
    }
    #[doc = " Description of a property. JS_DefineProperties and JS_InitClass take arrays\n of these and define many properties at once. JS_PSG, JS_PSGS and JS_PS_END\n are helper macros for defining such arrays."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec {
        pub name: root::JSPropertySpec_Name,
        pub attributes_: u8,
        pub kind_: root::JSPropertySpec_Kind,
        pub u: root::JSPropertySpec_AccessorsOrValue,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSPropertySpec_SelfHostedWrapper {
        pub unused: root::JSNative,
        pub funname: *const ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_SelfHostedWrapper() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec_SelfHostedWrapper> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_SelfHostedWrapper>(),
            16usize,
            concat!("Size of: ", stringify!(JSPropertySpec_SelfHostedWrapper))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_SelfHostedWrapper>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(JSPropertySpec_SelfHostedWrapper)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_SelfHostedWrapper),
                "::",
                stringify!(unused)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).funname) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_SelfHostedWrapper),
                "::",
                stringify!(funname)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_ValueWrapper {
        pub type_: root::JSPropertySpec_ValueWrapper_Type,
        pub __bindgen_anon_1: root::JSPropertySpec_ValueWrapper__bindgen_ty_1,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSPropertySpec_ValueWrapper_Type {
        String = 0,
        Int32 = 1,
        Double = 2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_ValueWrapper__bindgen_ty_1 {
        pub string: *const ::std::os::raw::c_char,
        pub int32: i32,
        pub double_: f64,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_ValueWrapper__bindgen_ty_1() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec_ValueWrapper__bindgen_ty_1> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_ValueWrapper__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_ValueWrapper__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1),
                "::",
                stringify!(string)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).int32) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1),
                "::",
                stringify!(int32)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).double_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1),
                "::",
                stringify!(double_)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_ValueWrapper() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec_ValueWrapper> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_ValueWrapper>(),
            16usize,
            concat!("Size of: ", stringify!(JSPropertySpec_ValueWrapper))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_ValueWrapper>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_ValueWrapper))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_ValueWrapper),
                "::",
                stringify!(type_)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Accessor {
        pub native: root::JSNativeWrapper,
        pub selfHosted: root::JSPropertySpec_SelfHostedWrapper,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_Accessor() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec_Accessor> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_Accessor>(),
            16usize,
            concat!("Size of: ", stringify!(JSPropertySpec_Accessor))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_Accessor>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_Accessor))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).native) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Accessor),
                "::",
                stringify!(native)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).selfHosted) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Accessor),
                "::",
                stringify!(selfHosted)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_AccessorsOrValue {
        pub accessors: root::JSPropertySpec_AccessorsOrValue_Accessors,
        pub value: root::JSPropertySpec_ValueWrapper,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_AccessorsOrValue_Accessors {
        pub getter: root::JSPropertySpec_Accessor,
        pub setter: root::JSPropertySpec_Accessor,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_AccessorsOrValue_Accessors() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec_AccessorsOrValue_Accessors> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_AccessorsOrValue_Accessors>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_AccessorsOrValue_Accessors>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).getter) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors),
                "::",
                stringify!(getter)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).setter) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors),
                "::",
                stringify!(setter)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_AccessorsOrValue() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec_AccessorsOrValue> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_AccessorsOrValue>(),
            32usize,
            concat!("Size of: ", stringify!(JSPropertySpec_AccessorsOrValue))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_AccessorsOrValue>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_AccessorsOrValue))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).accessors) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue),
                "::",
                stringify!(accessors)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue),
                "::",
                stringify!(value)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Name {
        pub string_: *const ::std::os::raw::c_char,
        pub symbol_: usize,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_Name() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec_Name> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_Name>(),
            8usize,
            concat!("Size of: ", stringify!(JSPropertySpec_Name))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_Name>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_Name))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).string_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Name),
                "::",
                stringify!(string_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).symbol_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Name),
                "::",
                stringify!(symbol_)
            )
        );
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSPropertySpec_Kind {
        Value = 0,
        SelfHostedAccessor = 1,
        NativeAccessor = 2,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec() {
        const UNINIT: ::std::mem::MaybeUninit<JSPropertySpec> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec>(),
            48usize,
            concat!("Size of: ", stringify!(JSPropertySpec))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).attributes_) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec),
                "::",
                stringify!(attributes_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).kind_) as usize - ptr as usize },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec),
                "::",
                stringify!(kind_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec),
                "::",
                stringify!(u)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSFunctionSpec {
        pub name: root::JSFunctionSpec_Name,
        pub call: root::JSNativeWrapper,
        pub nargs: u16,
        pub flags: u16,
        pub selfHostedName: *const ::std::os::raw::c_char,
    }
    pub type JSFunctionSpec_Name = root::JSPropertySpec_Name;
    #[test]
    fn bindgen_test_layout_JSFunctionSpec() {
        const UNINIT: ::std::mem::MaybeUninit<JSFunctionSpec> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSFunctionSpec>(),
            40usize,
            concat!("Size of: ", stringify!(JSFunctionSpec))
        );
        assert_eq!(
            ::std::mem::align_of::<JSFunctionSpec>(),
            8usize,
            concat!("Alignment of ", stringify!(JSFunctionSpec))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).call) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(call)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).nargs) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(nargs)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).selfHostedName) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(selfHostedName)
            )
        );
    }
    extern "C" {
        #[doc = " DEPRECATED\n\n Allocate memory sufficient to contain the characters of |str| truncated to\n Latin-1 and a trailing null terminator, fill the memory with the characters\n interpreted in that manner plus the null terminator, and return a pointer to\n the memory.\n\n This function *loses information* when it copies the characters of |str| if\n |str| contains code units greater than 0xFF.  Additionally, users that\n depend on null-termination will misinterpret the copied characters if |str|\n contains any nulls.  Avoid using this function if possible, because it will\n eventually be removed."]
        #[link_name = "\u{1}_Z23JS_EncodeStringToLatin1P9JSContextP8JSString"]
        pub fn JS_EncodeStringToLatin1(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[doc = " DEPRECATED\n\n Same behavior as JS_EncodeStringToLatin1(), but encode into a UTF-8 string.\n\n This function *loses information* when it copies the characters of |str| if\n |str| contains invalid UTF-16: U+FFFD REPLACEMENT CHARACTER will be copied\n instead.\n\n The returned string is also subject to misinterpretation if |str| contains\n any nulls (which are faithfully transcribed into the returned string, but\n which will implicitly truncate the string if it's passed to functions that\n expect null-terminated strings).\n\n Avoid using this function if possible, because we'll remove it once we can\n devise a better API for the task."]
        #[link_name = "\u{1}_Z21JS_EncodeStringToUTF8P9JSContextN2JS6HandleIP8JSStringEE"]
        pub fn JS_EncodeStringToUTF8(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[doc = " DEPRECATED\n\n Same behavior as JS_EncodeStringToLatin1(), but encode into an ASCII string.\n\n This function asserts in debug mode that the input string contains only\n ASCII characters.\n\n The returned string is also subject to misinterpretation if |str| contains\n any nulls (which are faithfully transcribed into the returned string, but\n which will implicitly truncate the string if it's passed to functions that\n expect null-terminated strings).\n\n Avoid using this function if possible, because we'll remove it once we can\n devise a better API for the task."]
        #[link_name = "\u{1}_Z22JS_EncodeStringToASCIIP9JSContextP8JSString"]
        pub fn JS_EncodeStringToASCII(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetEmptyStringP9JSContext"]
        pub fn JS_GetEmptyString(cx: *mut root::JSContext) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetEmptyStringValueP9JSContext"]
        pub fn JS_GetEmptyStringValue(cx: *mut root::JSContext) -> root::JS::Value;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewStringCopyNP9JSContextPKcm"]
        pub fn JS_NewStringCopyN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            n: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewStringCopyZP9JSContextPKc"]
        pub fn JS_NewStringCopyZ(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8ZP9JSContextN2JS15ConstUTF8CharsZE"]
        pub fn JS_NewStringCopyUTF8Z(
            cx: *mut root::JSContext,
            s: root::JS::ConstUTF8CharsZ,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8NP9JSContextN2JS9UTF8CharsE"]
        pub fn JS_NewStringCopyUTF8N(
            cx: *mut root::JSContext,
            s: root::JS::UTF8Chars,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_AtomizeStringNP9JSContextPKcm"]
        pub fn JS_AtomizeStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_AtomizeStringP9JSContextPKc"]
        pub fn JS_AtomizeString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AtomizeAndPinStringNP9JSContextPKcm"]
        pub fn JS_AtomizeAndPinStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_AtomizeAndPinStringP9JSContextPKc"]
        pub fn JS_AtomizeAndPinString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyNP9JSContextPKDsm"]
        pub fn JS_NewUCStringCopyN(
            cx: *mut root::JSContext,
            s: *const u16,
            n: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyZP9JSContextPKDs"]
        pub fn JS_NewUCStringCopyZ(cx: *mut root::JSContext, s: *const u16) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_AtomizeUCStringNP9JSContextPKDsm"]
        pub fn JS_AtomizeUCStringN(
            cx: *mut root::JSContext,
            s: *const u16,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_AtomizeUCStringP9JSContextPKDs"]
        pub fn JS_AtomizeUCString(cx: *mut root::JSContext, s: *const u16) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_CompareStringsP9JSContextP8JSStringS2_Pi"]
        pub fn JS_CompareStrings(
            cx: *mut root::JSContext,
            str1: *mut root::JSString,
            str2: *mut root::JSString,
            result: *mut i32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcPb"]
        pub fn JS_StringEqualsAscii(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            match_: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcmPb"]
        pub fn JS_StringEqualsAscii1(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
            match_: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_PutEscapedStringP9JSContextPcmP8JSStringc"]
        pub fn JS_PutEscapedString(
            cx: *mut root::JSContext,
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str_: *mut root::JSString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetStringLengthP8JSString"]
        pub fn JS_GetStringLength(str_: *mut root::JSString) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_StringIsLinearP8JSString"]
        pub fn JS_StringIsLinear(str_: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_GetLatin1StringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetLatin1StringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str_: *mut root::JSString,
            length: *mut usize,
        ) -> *const root::JS::Latin1Char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_GetTwoByteStringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetTwoByteStringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str_: *mut root::JSString,
            length: *mut usize,
        ) -> *const u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetStringCharAtP9JSContextP8JSStringmPDs"]
        pub fn JS_GetStringCharAt(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            index: usize,
            res: *mut u16,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_GetTwoByteExternalStringCharsP8JSString"]
        pub fn JS_GetTwoByteExternalStringChars(str_: *mut root::JSString) -> *const u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_CopyStringCharsP9JSContextN7mozilla5RangeIDsEEP8JSString"]
        pub fn JS_CopyStringChars(
            cx: *mut root::JSContext,
            dest: root::mozilla::Range<u16>,
            str_: *mut root::JSString,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Copies the string's characters to a null-terminated char16_t buffer.\n\n Returns nullptr on OOM."]
        #[link_name = "\u{1}_Z19JS_CopyStringCharsZP9JSContextP8JSString"]
        pub fn JS_CopyStringCharsZ(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueTwoByteChars;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_EnsureLinearStringP9JSContextP8JSString"]
        pub fn JS_EnsureLinearString(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> *mut root::JSLinearString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKc"]
        pub fn JS_LinearStringEqualsAscii(
            str_: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKcm"]
        pub fn JS_LinearStringEqualsAscii1(
            str_: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_PutEscapedLinearStringPcmP14JSLinearStringc"]
        pub fn JS_PutEscapedLinearString(
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str_: *mut root::JSLinearString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
    }
    extern "C" {
        #[doc = " Create a dependent string, i.e., a string that owns no character storage,\n but that refers to a slice of another string's chars.  Dependent strings\n are mutable by definition, so the thread safety comments above apply."]
        #[link_name = "\u{1}_Z21JS_NewDependentStringP9JSContextN2JS6HandleIP8JSStringEEmm"]
        pub fn JS_NewDependentString(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            start: usize,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Concatenate two strings, possibly resulting in a rope.\n See above for thread safety comments."]
        #[link_name = "\u{1}_Z16JS_ConcatStringsP9JSContextN2JS6HandleIP8JSStringEES5_"]
        pub fn JS_ConcatStrings(
            cx: *mut root::JSContext,
            left: root::JS::Handle<*mut root::JSString>,
            right: root::JS::Handle<*mut root::JSString>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before\n the call; on return, *dstlenp contains the number of characters actually\n stored. To determine the necessary destination buffer size, make a sizing\n call that passes nullptr for dst.\n\n On errors, the functions report the error. In that case, *dstlenp contains\n the number of characters or bytes transferred so far.  If cx is nullptr, no\n error is reported on failure, and the functions simply return false.\n\n NB: This function does not store an additional zero byte or char16_t after\n the transcoded string."]
        #[link_name = "\u{1}_Z14JS_DecodeBytesP9JSContextPKcmPDsPm"]
        pub fn JS_DecodeBytes(
            cx: *mut root::JSContext,
            src: *const ::std::os::raw::c_char,
            srclen: usize,
            dst: *mut u16,
            dstlenp: *mut usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get number of bytes in the string encoding (without accounting for a\n terminating zero bytes. The function returns (size_t) -1 if the string\n can not be encoded into bytes and reports an error using cx accordingly."]
        #[link_name = "\u{1}_Z26JS_GetStringEncodingLengthP9JSContextP8JSString"]
        pub fn JS_GetStringEncodingLength(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> usize;
    }
    extern "C" {
        #[doc = " Encode string into a buffer. The function does not stores an additional\n zero byte. The function returns (size_t) -1 if the string can not be\n encoded into bytes with no error reported. Otherwise it returns the number\n of bytes that are necessary to encode the string. If that exceeds the\n length parameter, the string will be cut and only length bytes will be\n written into the buffer."]
        #[link_name = "\u{1}_Z23JS_EncodeStringToBufferP9JSContextP8JSStringPcm"]
        pub fn JS_EncodeStringToBuffer(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            buffer: *mut ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " DO NOT USE, only present for Rust bindings as a temporary hack"]
        #[link_name = "\u{1}_Z33JS_DeprecatedStringHasLatin1CharsP8JSString"]
        pub fn JS_DeprecatedStringHasLatin1Chars(str_: *mut root::JSString) -> bool;
    }
    #[doc = " Read structured data from the reader r. This hook is used to read a value\n previously serialized by a call to the WriteStructuredCloneOp hook.\n\n tag and data are the pair of uint32_t values from the header. The callback\n may use the JS_Read* APIs to read any other relevant parts of the object\n from the reader r. closure is any value passed to the JS_ReadStructuredClone\n function. Return the new object on success, nullptr on error/exception."]
    pub type ReadStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            tag: u32,
            data: u32,
            closure: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSObject,
    >;
    #[doc = " Structured data serialization hook. The engine can write primitive values,\n Objects, Arrays, Dates, RegExps, TypedArrays, ArrayBuffers, Sets, Maps,\n and SharedTypedArrays. Any other type of object requires application support.\n This callback must first use the JS_WriteUint32Pair API to write an object\n header, passing a value greater than JS_SCTAG_USER to the tag parameter.\n Then it can use the JS_Write* APIs to write any other relevant parts of\n the value v to the writer w. closure is any value passed to the\n JS_WriteStructuredClone function.\n\n Return true on success, false on error/exception."]
    pub type WriteStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
            sameProcessScopeRequired: *mut bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[doc = " This is called when JS_WriteStructuredClone is given an invalid transferable.\n To follow HTML5, the application must throw a DATA_CLONE_ERR DOMException\n with error set to one of the JS_SCERR_* values."]
    pub type StructuredCloneErrorOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            errorid: u32,
            closure: *mut ::std::os::raw::c_void,
            errorMessage: *const ::std::os::raw::c_char,
        ),
    >;
    #[doc = " This is called when JS_ReadStructuredClone receives a transferable object\n not known to the engine. If this hook does not exist or returns false, the\n JS engine calls the reportError op if set, otherwise it throws a\n DATA_CLONE_ERR DOM Exception. This method is called before any other\n callback and must return a non-null object in returnObject on success."]
    pub type ReadTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            tag: u32,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
            returnObject: root::JS::MutableHandleObject,
        ) -> bool,
    >;
    #[doc = " Called when JS_WriteStructuredClone receives a transferable object not\n handled by the engine. If this hook does not exist or returns false, the JS\n engine will call the reportError hook or fall back to throwing a\n DATA_CLONE_ERR DOM Exception. This method is called before any other\n callback.\n\n  tag: indicates what type of transferable this is. Must be greater than\n       0xFFFF0201 (value of the internal SCTAG_TRANSFER_MAP_PENDING_ENTRY)\n\n  ownership: see TransferableOwnership, above. Used to communicate any needed\n       ownership info to the FreeTransferStructuredCloneOp.\n\n  content, extraData: what the ReadTransferStructuredCloneOp will receive"]
    pub type TransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            closure: *mut ::std::os::raw::c_void,
            tag: *mut u32,
            ownership: *mut root::JS::TransferableOwnership,
            content: *mut *mut ::std::os::raw::c_void,
            extraData: *mut u64,
        ) -> bool,
    >;
    #[doc = " Called when freeing a transferable handled by the embedding. Note that it\n should never trigger a garbage collection (and will assert in a\n debug build if it does.)\n\n This callback will be used to release ownership in three situations:\n\n 1. During serialization: an object is Transferred from, then an error is\n    encountered later and the incomplete serialization is discarded.\n\n 2. During deserialization: before an object is Transferred to, an error\n    is encountered and the incompletely deserialized clone is discarded.\n\n 3. Serialized data that includes Transferring is never deserialized (eg when\n    the receiver disappears before reading in the message), and the clone data\n is destroyed.\n"]
    pub type FreeTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            tag: u32,
            ownership: root::JS::TransferableOwnership,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
        ),
    >;
    #[doc = " Called when the transferring objects are checked. If this function returns\n false, the serialization ends throwing a DataCloneError exception."]
    pub type CanTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            sameProcessScopeRequired: *mut bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[doc = " Called when a SharedArrayBuffer (including one owned by a Wasm memory object)\n has been processed in context `cx` by structured cloning.  If `receiving` is\n true then the SAB has been received from a channel and a new SAB object has\n been created; if false then an existing SAB has been serialized onto a\n channel.\n\n If the callback returns false then the clone operation (read or write) will\n signal a failure."]
    pub type SharedArrayBufferClonedOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            receiving: bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneCallbacks {
        pub read: root::ReadStructuredCloneOp,
        pub write: root::WriteStructuredCloneOp,
        pub reportError: root::StructuredCloneErrorOp,
        pub readTransfer: root::ReadTransferStructuredCloneOp,
        pub writeTransfer: root::TransferStructuredCloneOp,
        pub freeTransfer: root::FreeTransferStructuredCloneOp,
        pub canTransfer: root::CanTransferStructuredCloneOp,
        pub sabCloned: root::SharedArrayBufferClonedOp,
    }
    #[test]
    fn bindgen_test_layout_JSStructuredCloneCallbacks() {
        const UNINIT: ::std::mem::MaybeUninit<JSStructuredCloneCallbacks> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSStructuredCloneCallbacks>(),
            64usize,
            concat!("Size of: ", stringify!(JSStructuredCloneCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSStructuredCloneCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSStructuredCloneCallbacks))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(read)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).reportError) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(reportError)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).readTransfer) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(readTransfer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).writeTransfer) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(writeTransfer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).freeTransfer) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(freeTransfer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).canTransfer) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(canTransfer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).sabCloned) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(sabCloned)
            )
        );
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum OwnTransferablePolicy {
        #[doc = " The buffer owns any Transferables that it might contain, and should\n properly release them upon destruction."]
        OwnsTransferablesIfAny = 0,
        #[doc = " Do not free any Transferables within this buffer when deleting it. This\n is used to mark a clone buffer as containing data from another process,\n and so it can't legitimately contain pointers. If the buffer claims to\n have transferables, it's a bug or an attack. This is also used for\n abandon(), where a buffer still contains raw data but the ownership has\n been given over to some other entity."]
        IgnoreTransferablesIfAny = 1,
        #[doc = " A buffer that cannot contain Transferables at all. This usually means\n the buffer is empty (not yet filled in, or having been cleared)."]
        NoTransferables = 2,
    }
    #[doc = " JSStructuredCloneData represents structured clone data together with the\n information needed to read/write/transfer/free the records within it, in the\n form of a set of callbacks."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSStructuredCloneData {
        pub bufList_: root::JSStructuredCloneData_BufferList,
        pub scope_: root::JS::StructuredCloneScope,
        pub callbacks_: *const root::JSStructuredCloneCallbacks,
        pub closure_: *mut ::std::os::raw::c_void,
        pub ownTransferables_: root::OwnTransferablePolicy,
        pub refsHeld_: root::js::SharedArrayRawBufferRefs,
    }
    pub type JSStructuredCloneData_BufferList = [u64; 9usize];
    pub type JSStructuredCloneData_Iterator = root::IterImpl;
    pub const JSStructuredCloneData_kStandardCapacity: usize = 4096;
    #[test]
    fn bindgen_test_layout_JSStructuredCloneData() {
        const UNINIT: ::std::mem::MaybeUninit<JSStructuredCloneData> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSStructuredCloneData>(),
            128usize,
            concat!("Size of: ", stringify!(JSStructuredCloneData))
        );
        assert_eq!(
            ::std::mem::align_of::<JSStructuredCloneData>(),
            8usize,
            concat!("Alignment of ", stringify!(JSStructuredCloneData))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).bufList_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(bufList_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).scope_) as usize - ptr as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(scope_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).callbacks_) as usize - ptr as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(callbacks_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).closure_) as usize - ptr as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(closure_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).ownTransferables_) as usize - ptr as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(ownTransferables_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).refsHeld_) as usize - ptr as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(refsHeld_)
            )
        );
    }
    extern "C" {
        #[doc = " Implements StructuredDeserialize and StructuredDeserializeWithTransfer.\n\n Note: If `data` contains transferable objects, it can be read only once."]
        #[link_name = "\u{1}_Z22JS_ReadStructuredCloneP9JSContextRK21JSStructuredCloneDatajN2JS20StructuredCloneScopeENS4_13MutableHandleINS4_5ValueEEERKNS4_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_ReadStructuredClone(
            cx: *mut root::JSContext,
            data: *const root::JSStructuredCloneData,
            version: u32,
            scope: root::JS::StructuredCloneScope,
            vp: root::JS::MutableHandleValue,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Implements StructuredSerialize, StructuredSerializeForStorage, and\n StructuredSerializeWithTransfer.\n\n Note: If the scope is DifferentProcess then the cloneDataPolicy must deny\n shared-memory objects, or an error will be signaled if a shared memory object\n is seen."]
        #[link_name = "\u{1}_Z23JS_WriteStructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEEP21JSStructuredCloneDataNS1_20StructuredCloneScopeERKNS1_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPvS4_"]
        pub fn JS_WriteStructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            data: *mut root::JSStructuredCloneData,
            scope: root::JS::StructuredCloneScope,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
            transferable: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_StructuredCloneHasTransferablesR21JSStructuredCloneDataPb"]
        pub fn JS_StructuredCloneHasTransferables(
            data: *mut root::JSStructuredCloneData,
            hasTransferable: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_StructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIS3_EEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_StructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            vp: root::JS::MutableHandleValue,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    #[doc = " The C-style API calls to read and write structured clones are fragile --\n they rely on the caller to properly handle ownership of the clone data, and\n the handling of the input data as well as the interpretation of the contents\n of the clone buffer are dependent on the callbacks passed in. If you\n serialize and deserialize with different callbacks, the results are\n questionable.\n\n JSAutoStructuredCloneBuffer wraps things up in an RAII class for data\n management, and uses the same callbacks for both writing and reading\n (serializing and deserializing)."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoStructuredCloneBuffer {
        pub data_: root::JSStructuredCloneData,
        pub version_: u32,
    }
    #[test]
    fn bindgen_test_layout_JSAutoStructuredCloneBuffer() {
        const UNINIT: ::std::mem::MaybeUninit<JSAutoStructuredCloneBuffer> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSAutoStructuredCloneBuffer>(),
            136usize,
            concat!("Size of: ", stringify!(JSAutoStructuredCloneBuffer))
        );
        assert_eq!(
            ::std::mem::align_of::<JSAutoStructuredCloneBuffer>(),
            8usize,
            concat!("Alignment of ", stringify!(JSAutoStructuredCloneBuffer))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).data_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoStructuredCloneBuffer),
                "::",
                stringify!(data_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).version_) as usize - ptr as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoStructuredCloneBuffer),
                "::",
                stringify!(version_)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_ReadUint32PairP23JSStructuredCloneReaderPjS1_"]
        pub fn JS_ReadUint32Pair(
            r: *mut root::JSStructuredCloneReader,
            p1: *mut u32,
            p2: *mut u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_ReadBytesP23JSStructuredCloneReaderPvm"]
        pub fn JS_ReadBytes(
            r: *mut root::JSStructuredCloneReader,
            p: *mut ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_ReadStringP23JSStructuredCloneReaderN2JS13MutableHandleIP8JSStringEE"]
        pub fn JS_ReadString(
            r: *mut root::JSStructuredCloneReader,
            str_: root::JS::MutableHandleString,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_ReadDoubleP23JSStructuredCloneReaderPd"]
        pub fn JS_ReadDouble(r: *mut root::JSStructuredCloneReader, v: *mut f64) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_ReadTypedArrayP23JSStructuredCloneReaderN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ReadTypedArray(
            r: *mut root::JSStructuredCloneReader,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_WriteUint32PairP23JSStructuredCloneWriterjj"]
        pub fn JS_WriteUint32Pair(
            w: *mut root::JSStructuredCloneWriter,
            tag: u32,
            data: u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_WriteBytesP23JSStructuredCloneWriterPKvm"]
        pub fn JS_WriteBytes(
            w: *mut root::JSStructuredCloneWriter,
            p: *const ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_WriteStringP23JSStructuredCloneWriterN2JS6HandleIP8JSStringEE"]
        pub fn JS_WriteString(
            w: *mut root::JSStructuredCloneWriter,
            str_: root::JS::HandleString,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_WriteDoubleP23JSStructuredCloneWriterd"]
        pub fn JS_WriteDouble(w: *mut root::JSStructuredCloneWriter, v: f64) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_WriteTypedArrayP23JSStructuredCloneWriterN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_WriteTypedArray(
            w: *mut root::JSStructuredCloneWriter,
            v: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_ObjectNotWrittenP23JSStructuredCloneWriterN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ObjectNotWritten(
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetStructuredCloneScopeP23JSStructuredCloneWriter"]
        pub fn JS_GetStructuredCloneScope(
            w: *mut root::JSStructuredCloneWriter,
        ) -> root::JS::StructuredCloneScope;
    }
    #[doc = " MozRefCountType is Mozilla's reference count type.\n\n We use the same type to represent the refcount of RefCounted objects\n as well, in order to be able to use the leak detection facilities\n that are implemented by XPCOM.\n\n Note that this type is not in the mozilla namespace so that it is\n usable for both C and C++ code."]
    pub type MozRefCountType = usize;
    pub type MozExternalRefCountType = u32;
    #[doc = " A class, expected to be passed by value, which represents the CallArgs for a\n JSJitGetterOp."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitGetterCallArgs {
        pub _base: root::JS::MutableHandle<root::JS::Value>,
    }
    #[test]
    fn bindgen_test_layout_JSJitGetterCallArgs() {
        assert_eq!(
            ::std::mem::size_of::<JSJitGetterCallArgs>(),
            8usize,
            concat!("Size of: ", stringify!(JSJitGetterCallArgs))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitGetterCallArgs>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitGetterCallArgs))
        );
    }
    #[doc = " A class, expected to be passed by value, which represents the CallArgs for a\n JSJitSetterOp."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitSetterCallArgs {
        pub _base: root::JS::MutableHandle<root::JS::Value>,
    }
    #[test]
    fn bindgen_test_layout_JSJitSetterCallArgs() {
        assert_eq!(
            ::std::mem::size_of::<JSJitSetterCallArgs>(),
            8usize,
            concat!("Size of: ", stringify!(JSJitSetterCallArgs))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitSetterCallArgs>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitSetterCallArgs))
        );
    }
    pub type JSJitMethodCallArgs_Base = [u64; 2usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitMethodCallArgsTraits {
        pub _address: u8,
    }
    pub const JSJitMethodCallArgsTraits_offsetOfArgv: usize = 0;
    pub const JSJitMethodCallArgsTraits_offsetOfArgc: usize = 8;
    #[test]
    fn bindgen_test_layout_JSJitMethodCallArgsTraits() {
        assert_eq!(
            ::std::mem::size_of::<JSJitMethodCallArgsTraits>(),
            1usize,
            concat!("Size of: ", stringify!(JSJitMethodCallArgsTraits))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitMethodCallArgsTraits>(),
            1usize,
            concat!("Alignment of ", stringify!(JSJitMethodCallArgsTraits))
        );
    }
    pub type JSJitGetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: root::JSJitGetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitSetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: root::JSJitSetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitMethodOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: *const root::JSJitMethodCallArgs,
        ) -> bool,
    >;
    #[doc = " This struct contains metadata passed from the DOM to the JS Engine for JIT\n optimizations on DOM property accessors.\n\n Eventually, this should be made available to general JSAPI users as *not*\n experimental and *not* a friend API, but we're not ready to do so yet."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSJitInfo {
        pub __bindgen_anon_1: root::JSJitInfo__bindgen_ty_1,
        pub __bindgen_anon_2: root::JSJitInfo__bindgen_ty_2,
        pub __bindgen_anon_3: root::JSJitInfo__bindgen_ty_3,
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_OpType {
        Getter = 0,
        Setter = 1,
        Method = 2,
        StaticMethod = 3,
        InlinableNative = 4,
        IgnoresReturnValueNative = 5,
        OpTypeCount = 6,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_ArgType {
        String = 1,
        Integer = 2,
        Double = 4,
        Boolean = 8,
        Object = 16,
        Null = 32,
        Numeric = 6,
        Primitive = 47,
        ObjectOrNull = 48,
        Any = 63,
        ArgTypeListEnd = -2147483648,
    }
    #[repr(u32)]
    #[doc = " An enum that describes what this getter/setter/method aliases.  This\n determines what things can be hoisted past this call, and if this\n call is movable what it can be hoisted past."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_AliasSet {
        #[doc = " Alias nothing: a constant value, getting it can't affect any other\n values, nothing can affect it."]
        AliasNone = 0,
        #[doc = " Alias things that can modify the DOM but nothing else.  Doing the\n call can't affect the behavior of any other function."]
        AliasDOMSets = 1,
        #[doc = " Alias the world.  Calling this can change arbitrary values anywhere\n in the system.  Most things fall in this bucket."]
        AliasEverything = 2,
        #[doc = " Must be last."]
        AliasSetCount = 3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_1 {
        pub getter: root::JSJitGetterOp,
        pub setter: root::JSJitSetterOp,
        pub method: root::JSJitMethodOp,
        #[doc = " A DOM static method, used for Promise wrappers"]
        pub staticMethod: root::JSNative,
        pub ignoresReturnValueMethod: root::JSNative,
    }
    #[test]
    fn bindgen_test_layout_JSJitInfo__bindgen_ty_1() {
        const UNINIT: ::std::mem::MaybeUninit<JSJitInfo__bindgen_ty_1> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(JSJitInfo__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitInfo__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).getter) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(getter)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).setter) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(setter)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(method)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).staticMethod) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(staticMethod)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).ignoresReturnValueMethod) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(ignoresReturnValueMethod)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_2 {
        pub protoID: u16,
        pub inlinableNative: root::js::jit::InlinableNative,
    }
    #[test]
    fn bindgen_test_layout_JSJitInfo__bindgen_ty_2() {
        const UNINIT: ::std::mem::MaybeUninit<JSJitInfo__bindgen_ty_2> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo__bindgen_ty_2>(),
            2usize,
            concat!("Size of: ", stringify!(JSJitInfo__bindgen_ty_2))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo__bindgen_ty_2>(),
            2usize,
            concat!("Alignment of ", stringify!(JSJitInfo__bindgen_ty_2))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).protoID) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_2),
                "::",
                stringify!(protoID)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).inlinableNative) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_2),
                "::",
                stringify!(inlinableNative)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_3 {
        pub depth: u16,
        pub nativeOp: u16,
    }
    #[test]
    fn bindgen_test_layout_JSJitInfo__bindgen_ty_3() {
        const UNINIT: ::std::mem::MaybeUninit<JSJitInfo__bindgen_ty_3> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo__bindgen_ty_3>(),
            2usize,
            concat!("Size of: ", stringify!(JSJitInfo__bindgen_ty_3))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo__bindgen_ty_3>(),
            2usize,
            concat!("Alignment of ", stringify!(JSJitInfo__bindgen_ty_3))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_3),
                "::",
                stringify!(depth)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).nativeOp) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_3),
                "::",
                stringify!(nativeOp)
            )
        );
    }
    pub const JSJitInfo_OpTypeBits: usize = 4;
    pub const JSJitInfo_AliasSetBits: usize = 4;
    pub const JSJitInfo_ReturnTypeBits: usize = 8;
    pub const JSJitInfo_SlotIndexBits: usize = 10;
    pub const JSJitInfo_maxSlotIndex: usize = 1023;
    #[test]
    fn bindgen_test_layout_JSJitInfo() {
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo>(),
            16usize,
            concat!("Size of: ", stringify!(JSJitInfo))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitInfo))
        );
    }
    impl JSJitInfo {
        #[inline]
        pub fn type_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_type_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn aliasSet_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_aliasSet_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn returnType_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_returnType_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(8usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn isInfallible(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isInfallible(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isMovable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isMovable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(17usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isEliminatable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isEliminatable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(18usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isAlwaysInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isAlwaysInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(19usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isLazilyCachedInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isLazilyCachedInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(20usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isTypedMethod(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isTypedMethod(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(21usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn slotIndex(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
        }
        #[inline]
        pub fn set_slotIndex(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(22usize, 10u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            type_: u32,
            aliasSet_: u32,
            returnType_: u32,
            isInfallible: u32,
            isMovable: u32,
            isEliminatable: u32,
            isAlwaysInSlot: u32,
            isLazilyCachedInSlot: u32,
            isTypedMethod: u32,
            slotIndex: u32,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let type_: u32 = unsafe { ::std::mem::transmute(type_) };
                type_ as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let aliasSet_: u32 = unsafe { ::std::mem::transmute(aliasSet_) };
                aliasSet_ as u64
            });
            __bindgen_bitfield_unit.set(8usize, 8u8, {
                let returnType_: u32 = unsafe { ::std::mem::transmute(returnType_) };
                returnType_ as u64
            });
            __bindgen_bitfield_unit.set(16usize, 1u8, {
                let isInfallible: u32 = unsafe { ::std::mem::transmute(isInfallible) };
                isInfallible as u64
            });
            __bindgen_bitfield_unit.set(17usize, 1u8, {
                let isMovable: u32 = unsafe { ::std::mem::transmute(isMovable) };
                isMovable as u64
            });
            __bindgen_bitfield_unit.set(18usize, 1u8, {
                let isEliminatable: u32 = unsafe { ::std::mem::transmute(isEliminatable) };
                isEliminatable as u64
            });
            __bindgen_bitfield_unit.set(19usize, 1u8, {
                let isAlwaysInSlot: u32 = unsafe { ::std::mem::transmute(isAlwaysInSlot) };
                isAlwaysInSlot as u64
            });
            __bindgen_bitfield_unit.set(20usize, 1u8, {
                let isLazilyCachedInSlot: u32 =
                    unsafe { ::std::mem::transmute(isLazilyCachedInSlot) };
                isLazilyCachedInSlot as u64
            });
            __bindgen_bitfield_unit.set(21usize, 1u8, {
                let isTypedMethod: u32 = unsafe { ::std::mem::transmute(isTypedMethod) };
                isTypedMethod as u64
            });
            __bindgen_bitfield_unit.set(22usize, 10u8, {
                let slotIndex: u32 = unsafe { ::std::mem::transmute(slotIndex) };
                slotIndex as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSTypedMethodJitInfo {
        pub base: root::JSJitInfo,
        pub argTypes: *const root::JSJitInfo_ArgType,
    }
    #[test]
    fn bindgen_test_layout_JSTypedMethodJitInfo() {
        const UNINIT: ::std::mem::MaybeUninit<JSTypedMethodJitInfo> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSTypedMethodJitInfo>(),
            24usize,
            concat!("Size of: ", stringify!(JSTypedMethodJitInfo))
        );
        assert_eq!(
            ::std::mem::align_of::<JSTypedMethodJitInfo>(),
            8usize,
            concat!("Alignment of ", stringify!(JSTypedMethodJitInfo))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTypedMethodJitInfo),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).argTypes) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTypedMethodJitInfo),
                "::",
                stringify!(argTypes)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_NewInt8ArrayP9JSContextm"]
        pub fn JS_NewInt8Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_NewInt8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewInt8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewUint8ArrayP9JSContextm"]
        pub fn JS_NewUint8Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewUint8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewInt16ArrayP9JSContextm"]
        pub fn JS_NewInt16Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewInt16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewInt16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewUint16ArrayP9JSContextm"]
        pub fn JS_NewUint16Array(cx: *mut root::JSContext, nelements: usize)
            -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewUint16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewInt32ArrayP9JSContextm"]
        pub fn JS_NewInt32Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewInt32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewInt32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewUint32ArrayP9JSContextm"]
        pub fn JS_NewUint32Array(cx: *mut root::JSContext, nelements: usize)
            -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewUint32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewFloat32ArrayP9JSContextm"]
        pub fn JS_NewFloat32Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewFloat32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewFloat32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewFloat32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewFloat64ArrayP9JSContextm"]
        pub fn JS_NewFloat64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewFloat64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewFloat64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewFloat64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_NewUint8ClampedArrayP9JSContextm"]
        pub fn JS_NewUint8ClampedArray(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_NewUint8ClampedArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ClampedArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NewUint8ClampedArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint8ClampedArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewBigInt64ArrayP9JSContextm"]
        pub fn JS_NewBigInt64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewBigInt64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewBigInt64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_NewBigInt64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewBigInt64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_NewBigUint64ArrayP9JSContextm"]
        pub fn JS_NewBigUint64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_NewBigUint64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewBigUint64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_NewBigUint64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewBigUint64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Check whether obj supports JS_GetTypedArray* APIs. Note that this may return\n false if a security wrapper is encountered that denies the unwrapping. If\n this test or one of the JS_Is*Array tests succeeds, then it is safe to call\n the various accessor JSAPI calls defined below."]
        #[link_name = "\u{1}_Z21JS_IsTypedArrayObjectP8JSObject"]
        pub fn JS_IsTypedArrayObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may\n return false if a security wrapper is encountered that denies the\n unwrapping. If this test or one of the more specific tests succeeds, then it\n is safe to call the various ArrayBufferView accessor JSAPI calls defined\n below."]
        #[link_name = "\u{1}_Z26JS_IsArrayBufferViewObjectP8JSObject"]
        pub fn JS_IsArrayBufferViewObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Return the isShared flag of a typed array, which denotes whether\n the underlying buffer is a SharedArrayBuffer.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArraySharednessP8JSObject"]
        pub fn JS_GetTypedArraySharedness(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetObjectAsInt8ArrayP8JSObjectPmPbPPa"]
        pub fn JS_GetObjectAsInt8Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsUint8ArrayP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsUint8Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt16ArrayP8JSObjectPmPbPPs"]
        pub fn JS_GetObjectAsInt16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i16,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint16ArrayP8JSObjectPmPbPPt"]
        pub fn JS_GetObjectAsUint16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt32ArrayP8JSObjectPmPbPPi"]
        pub fn JS_GetObjectAsInt32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint32ArrayP8JSObjectPmPbPPj"]
        pub fn JS_GetObjectAsUint32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat32ArrayP8JSObjectPmPbPPf"]
        pub fn JS_GetObjectAsFloat32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat64ArrayP8JSObjectPmPbPPd"]
        pub fn JS_GetObjectAsFloat64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31JS_GetObjectAsUint8ClampedArrayP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsUint8ClampedArray(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetObjectAsBigInt64ArrayP8JSObjectPmPbPPl"]
        pub fn JS_GetObjectAsBigInt64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_GetObjectAsBigUint64ArrayP8JSObjectPmPbPS1_"]
        pub fn JS_GetObjectAsBigUint64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetObjectAsArrayBufferViewP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsArrayBufferView(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewTypeP8JSObject"]
        pub fn JS_GetArrayBufferViewType(obj: *mut root::JSObject) -> root::JS::Scalar::Type;
    }
    extern "C" {
        #[doc = " Return the number of elements in a typed array.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z22JS_GetTypedArrayLengthP8JSObject"]
        pub fn JS_GetTypedArrayLength(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " Return the byte offset from the start of an ArrayBuffer to the start of a\n typed array view.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteOffsetP8JSObject"]
        pub fn JS_GetTypedArrayByteOffset(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " Return the byte length of a typed array.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteLengthP8JSObject"]
        pub fn JS_GetTypedArrayByteLength(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " More generic name for JS_GetTypedArrayByteLength to cover DataViews as well"]
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteLengthP8JSObject"]
        pub fn JS_GetArrayBufferViewByteLength(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " More generic name for JS_GetTypedArrayByteOffset to cover DataViews as well"]
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteOffsetP8JSObject"]
        pub fn JS_GetArrayBufferViewByteOffset(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " Same as above, but for any kind of ArrayBufferView. Prefer the type-specific\n versions when possible."]
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetArrayBufferViewData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Return a \"fixed\" pointer (one that will not move during a GC) to the\n ArrayBufferView's data. Note that this will not keep the object alive; the\n holding object should be rooted or traced. If the view is storing the data\n inline, this will copy the data to the provided buffer, returning nullptr if\n bufSize is inadequate.\n\n Avoid using this unless necessary. JS_GetArrayBufferViewData is simpler and\n more efficient because it requires the caller to ensure that a GC will not\n occur and thus does not need to handle movable data."]
        #[link_name = "\u{1}_Z30JS_GetArrayBufferViewFixedDataP8JSObjectPhm"]
        pub fn JS_GetArrayBufferViewFixedData(
            obj: *mut root::JSObject,
            buffer: *mut u8,
            bufSize: usize,
        ) -> *mut u8;
    }
    extern "C" {
        #[doc = " If the bufSize passed to JS_GetArrayBufferViewFixedData is at least this\n many bytes, then any copied data is guaranteed to fit into the provided\n buffer."]
        #[link_name = "\u{1}_Z27JS_MaxMovableTypedArraySizev"]
        pub fn JS_MaxMovableTypedArraySize() -> usize;
    }
    extern "C" {
        #[doc = " Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView.\n This may return a detached buffer.  |obj| must be an object that would\n return true for JS_IsArrayBufferViewObject()."]
        #[link_name = "\u{1}_Z27JS_GetArrayBufferViewBufferP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_GetArrayBufferViewBuffer(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            isSharedMemory: *mut bool,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Create a new DataView using the given buffer for storage. The given buffer\n must be an ArrayBuffer or SharedArrayBuffer (or a cross-compartment wrapper\n of either type), and the offset and length must fit within the bounds of the\n buffer. Currently, nullptr will be returned and an exception will be thrown\n if these conditions do not hold, but do not depend on that behavior."]
        #[link_name = "\u{1}_Z14JS_NewDataViewP9JSContextN2JS6HandleIP8JSObjectEEmm"]
        pub fn JS_NewDataView(
            cx: *mut root::JSContext,
            buffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            byteLength: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetInt8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt8ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetUint8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetInt16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_GetUint16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetInt32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_GetUint32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetFloat32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetFloat64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetUint8ClampedArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ClampedArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetBigInt64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetBigInt64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetBigUint64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetBigUint64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u64;
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSErrNum {
        JSMSG_NOT_AN_ERROR = 0,
        JSMSG_NOT_DEFINED = 1,
        JSMSG_MORE_ARGS_NEEDED = 2,
        JSMSG_INCOMPATIBLE_PROTO = 3,
        JSMSG_INCOMPATIBLE_PROTO2 = 4,
        JSMSG_NO_CONSTRUCTOR = 5,
        JSMSG_BAD_SORT_ARG = 6,
        JSMSG_BAD_TOSORTED_ARG = 7,
        JSMSG_READ_ONLY = 8,
        JSMSG_CANT_DELETE = 9,
        JSMSG_CANT_TRUNCATE_ARRAY = 10,
        JSMSG_NOT_FUNCTION = 11,
        JSMSG_PROPERTY_NOT_CALLABLE = 12,
        JSMSG_NOT_CONSTRUCTOR = 13,
        JSMSG_BOGUS_CONSTRUCTOR = 14,
        JSMSG_CANT_CONVERT_TO = 15,
        JSMSG_TOPRIMITIVE_NOT_CALLABLE = 16,
        JSMSG_TOPRIMITIVE_RETURNED_OBJECT = 17,
        JSMSG_NO_PROPERTIES = 18,
        JSMSG_PROPERTY_FAIL = 19,
        JSMSG_PROPERTY_FAIL_EXPR = 20,
        JSMSG_BAD_REGEXP_FLAG = 21,
        JSMSG_INVALID_DATA_VIEW_LENGTH = 22,
        JSMSG_OFFSET_LARGER_THAN_FILESIZE = 23,
        JSMSG_OFFSET_OUT_OF_BUFFER = 24,
        JSMSG_OFFSET_OUT_OF_DATAVIEW = 25,
        JSMSG_SPREAD_TOO_LARGE = 26,
        JSMSG_BAD_WEAKMAP_KEY = 27,
        JSMSG_BAD_GETTER_OR_SETTER = 28,
        JSMSG_BAD_ARRAY_LENGTH = 29,
        JSMSG_SOURCE_ARRAY_TOO_LONG = 30,
        JSMSG_REDECLARED_PREV = 31,
        JSMSG_REDECLARED_VAR = 32,
        JSMSG_UNDECLARED_VAR = 33,
        JSMSG_GET_MISSING_PRIVATE = 34,
        JSMSG_SET_MISSING_PRIVATE = 35,
        JSMSG_GETTER_ONLY = 36,
        JSMSG_PRIVATE_SETTER_ONLY = 37,
        JSMSG_OVERWRITING_ACCESSOR = 38,
        JSMSG_INVALID_MAP_ITERABLE = 39,
        JSMSG_NESTING_GENERATOR = 40,
        JSMSG_INCOMPATIBLE_METHOD = 41,
        JSMSG_BAD_SURROGATE_CHAR = 42,
        JSMSG_UTF8_CHAR_TOO_LARGE = 43,
        JSMSG_MALFORMED_UTF8_CHAR = 44,
        JSMSG_BUILTIN_CTOR_NO_NEW = 45,
        JSMSG_EMPTY_ARRAY_REDUCE = 46,
        JSMSG_EMPTY_ITERATOR_REDUCE = 47,
        JSMSG_UNEXPECTED_TYPE = 48,
        JSMSG_MISSING_FUN_ARG = 49,
        JSMSG_OBJECT_REQUIRED = 50,
        JSMSG_OBJECT_REQUIRED_ARG = 51,
        JSMSG_OBJECT_REQUIRED_WEAKMAP_KEY = 52,
        JSMSG_OBJECT_REQUIRED_WEAKSET_VAL = 53,
        JSMSG_OBJECT_REQUIRED_PROP_DESC = 54,
        JSMSG_OBJECT_REQUIRED_RET_OWNKEYS = 55,
        JSMSG_WRONG_TYPE_ARG = 56,
        JSMSG_SET_NON_OBJECT_RECEIVER = 57,
        JSMSG_INVALID_DESCRIPTOR = 58,
        JSMSG_OBJECT_NOT_EXTENSIBLE = 59,
        JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE = 60,
        JSMSG_CANT_REDEFINE_PROP = 61,
        JSMSG_CANT_REDEFINE_ARRAY_LENGTH = 62,
        JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH = 63,
        JSMSG_BAD_GET_SET_FIELD = 64,
        JSMSG_THROW_TYPE_ERROR = 65,
        JSMSG_NOT_EXPECTED_TYPE = 66,
        JSMSG_NOT_ITERABLE = 67,
        JSMSG_ALREADY_HAS_PRAGMA = 68,
        JSMSG_GET_ITER_RETURNED_PRIMITIVE = 69,
        JSMSG_ITER_METHOD_RETURNED_PRIMITIVE = 70,
        JSMSG_CANT_SET_PROTO = 71,
        JSMSG_CANT_SET_PROTO_OF = 72,
        JSMSG_CANT_SET_PROTO_CYCLE = 73,
        JSMSG_INVALID_ARG_TYPE = 74,
        JSMSG_TERMINATED = 75,
        JSMSG_CANT_CALL_CLASS_CONSTRUCTOR = 76,
        JSMSG_UNINITIALIZED_THIS = 77,
        JSMSG_BAD_DERIVED_RETURN = 78,
        JSMSG_BAD_HERITAGE = 79,
        JSMSG_NOT_OBJORNULL = 80,
        JSMSG_CONSTRUCTOR_DISABLED = 81,
        JSMSG_JSON_BAD_PARSE = 82,
        JSMSG_JSON_CYCLIC_VALUE = 83,
        JSMSG_ASSIGN_TO_CALL = 84,
        JSMSG_ASSIGN_TO_PRIVATE_METHOD = 85,
        JSMSG_BAD_INSTANCEOF_RHS = 86,
        JSMSG_BAD_PROTOTYPE = 87,
        JSMSG_IN_NOT_OBJECT = 88,
        JSMSG_IN_STRING = 89,
        JSMSG_TOO_MANY_CON_SPREADARGS = 90,
        JSMSG_TOO_MANY_FUN_SPREADARGS = 91,
        JSMSG_UNINITIALIZED_LEXICAL = 92,
        JSMSG_BAD_CONST_ASSIGN = 93,
        JSMSG_CANT_DECLARE_GLOBAL_BINDING = 94,
        JSMSG_INVALID_DATE = 95,
        JSMSG_BAD_TOISOSTRING_PROP = 96,
        JSMSG_BAD_URI = 97,
        JSMSG_INVALID_NORMALIZE_FORM = 98,
        JSMSG_NEGATIVE_REPETITION_COUNT = 99,
        JSMSG_NOT_A_CODEPOINT = 100,
        JSMSG_RESULTING_STRING_TOO_LARGE = 101,
        JSMSG_FLAGS_UNDEFINED_OR_NULL = 102,
        JSMSG_REQUIRES_GLOBAL_REGEXP = 103,
        JSMSG_BAD_RADIX = 104,
        JSMSG_PRECISION_RANGE = 105,
        JSMSG_BAD_APPLY_ARGS = 106,
        JSMSG_DEPRECATED_USAGE = 107,
        JSMSG_NO_REST_NAME = 108,
        JSMSG_PARAMETER_AFTER_REST = 109,
        JSMSG_TOO_MANY_ARGUMENTS = 110,
        JSMSG_CSP_BLOCKED_EVAL = 111,
        JSMSG_CSP_BLOCKED_FUNCTION = 112,
        JSMSG_CSP_BLOCKED_WASM = 113,
        JSMSG_CSP_BLOCKED_SHADOWREALM = 114,
        JSMSG_ACCESSOR_DEF_DENIED = 115,
        JSMSG_DEAD_OBJECT = 116,
        JSMSG_OBJECT_ACCESS_DENIED = 117,
        JSMSG_PROPERTY_ACCESS_DENIED = 118,
        JSMSG_CANT_CLONE_OBJECT = 119,
        JSMSG_CANT_OPEN = 120,
        JSMSG_SUPPORT_NOT_ENABLED = 121,
        JSMSG_USER_DEFINED_ERROR = 122,
        JSMSG_ALLOC_OVERFLOW = 123,
        JSMSG_BAD_BYTECODE = 124,
        JSMSG_BUFFER_TOO_SMALL = 125,
        JSMSG_BYTECODE_TOO_BIG = 126,
        JSMSG_NEED_DIET = 127,
        JSMSG_OUT_OF_MEMORY = 128,
        JSMSG_OVER_RECURSED = 129,
        JSMSG_TOO_DEEP = 130,
        JSMSG_UNCAUGHT_EXCEPTION = 131,
        JSMSG_UNKNOWN_FORMAT = 132,
        JSMSG_UNSAFE_FILENAME = 133,
        JSMSG_ACCESSOR_WRONG_ARGS = 134,
        JSMSG_ARRAY_INIT_TOO_BIG = 135,
        JSMSG_AS_AFTER_IMPORT_STAR = 136,
        JSMSG_AS_AFTER_RESERVED_WORD = 137,
        JSMSG_AS_AFTER_STRING = 138,
        JSMSG_AWAIT_IN_PARAMETER = 139,
        JSMSG_AWAIT_OUTSIDE_ASYNC = 140,
        JSMSG_AWAIT_OUTSIDE_ASYNC_OR_MODULE = 141,
        JSMSG_TOP_LEVEL_AWAIT_NOT_SUPPORTED = 142,
        JSMSG_BAD_ARROW_ARGS = 143,
        JSMSG_BAD_COALESCE_MIXING = 144,
        JSMSG_BAD_CONST_DECL = 145,
        JSMSG_BAD_CONTINUE = 146,
        JSMSG_BAD_DESTRUCT_ASS = 147,
        JSMSG_BAD_DESTRUCT_TARGET = 148,
        JSMSG_BAD_DESTRUCT_PARENS = 149,
        JSMSG_BAD_DESTRUCT_DECL = 150,
        JSMSG_BAD_DUP_ARGS = 151,
        JSMSG_BAD_FOR_LEFTSIDE = 152,
        JSMSG_LEXICAL_DECL_DEFINES_LET = 153,
        JSMSG_BAD_STARTING_FOROF_LHS = 154,
        JSMSG_BAD_INCOP_OPERAND = 155,
        JSMSG_BAD_LEFTSIDE_OF_ASS = 156,
        JSMSG_BAD_LOCAL_STRING_EXPORT = 157,
        JSMSG_BAD_METHOD_DEF = 158,
        JSMSG_BAD_POW_LEFTSIDE = 159,
        JSMSG_BAD_PROP_ID = 160,
        JSMSG_BAD_RETURN_OR_YIELD = 161,
        JSMSG_BAD_STRICT_ASSIGN = 162,
        JSMSG_BAD_STRICT_ASSIGN_ARGUMENTS = 163,
        JSMSG_BAD_STRICT_ASSIGN_EVAL = 164,
        JSMSG_BAD_SWITCH = 165,
        JSMSG_BAD_SUPER = 166,
        JSMSG_BAD_SUPERPROP = 167,
        JSMSG_BAD_SUPERPRIVATE = 168,
        JSMSG_BAD_SUPERCALL = 169,
        JSMSG_BAD_ARGUMENTS = 170,
        JSMSG_BRACKET_AFTER_LIST = 171,
        JSMSG_BRACKET_IN_INDEX = 172,
        JSMSG_BRACKET_OPENED = 173,
        JSMSG_CATCH_IDENTIFIER = 174,
        JSMSG_CATCH_OR_FINALLY = 175,
        JSMSG_CATCH_WITHOUT_TRY = 176,
        JSMSG_COLON_AFTER_CASE = 177,
        JSMSG_COLON_AFTER_ID = 178,
        JSMSG_COLON_IN_COND = 179,
        JSMSG_COMP_PROP_UNTERM_EXPR = 180,
        JSMSG_CURLY_AFTER_BODY = 181,
        JSMSG_CURLY_OPENED = 182,
        JSMSG_CURLY_AFTER_CATCH = 183,
        JSMSG_CURLY_AFTER_FINALLY = 184,
        JSMSG_CURLY_AFTER_LIST = 185,
        JSMSG_CURLY_AFTER_TRY = 186,
        JSMSG_CURLY_BEFORE_BODY = 187,
        JSMSG_CURLY_BEFORE_CATCH = 188,
        JSMSG_CURLY_BEFORE_CLASS = 189,
        JSMSG_CURLY_BEFORE_FINALLY = 190,
        JSMSG_CURLY_BEFORE_SWITCH = 191,
        JSMSG_CURLY_BEFORE_TRY = 192,
        JSMSG_CURLY_IN_COMPOUND = 193,
        JSMSG_DECLARATION_AFTER_EXPORT = 194,
        JSMSG_DECLARATION_AFTER_IMPORT = 195,
        JSMSG_DEPRECATED_DELETE_OPERAND = 196,
        JSMSG_DEPRECATED_OCTAL_LITERAL = 197,
        JSMSG_DEPRECATED_OCTAL_ESCAPE = 198,
        JSMSG_DEPRECATED_EIGHT_OR_NINE_ESCAPE = 199,
        JSMSG_DEPRECATED_PRAGMA = 200,
        JSMSG_DUPLICATE_EXPORT_NAME = 201,
        JSMSG_DUPLICATE_FORMAL = 202,
        JSMSG_DUPLICATE_LABEL = 203,
        JSMSG_DUPLICATE_PROPERTY = 204,
        JSMSG_DUPLICATE_PROTO_PROPERTY = 205,
        JSMSG_EQUAL_AS_ASSIGN = 206,
        JSMSG_EXPORT_DECL_AT_TOP_LEVEL = 207,
        JSMSG_FINALLY_WITHOUT_TRY = 208,
        JSMSG_FORBIDDEN_AS_STATEMENT = 209,
        JSMSG_FOR_AWAIT_OUTSIDE_ASYNC = 210,
        JSMSG_FROM_AFTER_IMPORT_CLAUSE = 211,
        JSMSG_FROM_AFTER_EXPORT_STAR = 212,
        JSMSG_GARBAGE_AFTER_INPUT = 213,
        JSMSG_IDSTART_AFTER_NUMBER = 214,
        JSMSG_BAD_ESCAPE = 215,
        JSMSG_MISSING_PRIVATE_NAME = 216,
        JSMSG_PRIVATE_DELETE = 217,
        JSMSG_MISSING_PRIVATE_DECL = 218,
        JSMSG_ILLEGAL_CHARACTER = 219,
        JSMSG_IMPORT_META_OUTSIDE_MODULE = 220,
        JSMSG_IMPORT_DECL_AT_TOP_LEVEL = 221,
        JSMSG_OF_AFTER_FOR_LOOP_DECL = 222,
        JSMSG_IN_AFTER_LEXICAL_FOR_DECL = 223,
        JSMSG_INVALID_FOR_IN_DECL_WITH_INIT = 224,
        JSMSG_INVALID_ID = 225,
        JSMSG_SEPARATOR_IN_ZERO_PREFIXED_NUMBER = 226,
        JSMSG_LABEL_NOT_FOUND = 227,
        JSMSG_GENERATOR_LABEL = 228,
        JSMSG_FUNCTION_LABEL = 229,
        JSMSG_SLOPPY_FUNCTION_LABEL = 230,
        JSMSG_LINE_BREAK_AFTER_THROW = 231,
        JSMSG_MALFORMED_ESCAPE = 232,
        JSMSG_MISSING_BINARY_DIGITS = 233,
        JSMSG_MISSING_EXPONENT = 234,
        JSMSG_MISSING_EXPR_AFTER_THROW = 235,
        JSMSG_MISSING_FORMAL = 236,
        JSMSG_MISSING_HEXDIGITS = 237,
        JSMSG_MISSING_OCTAL_DIGITS = 238,
        JSMSG_NUMBER_END_WITH_UNDERSCORE = 239,
        JSMSG_NUMBER_MULTIPLE_ADJACENT_UNDERSCORES = 240,
        JSMSG_MODULE_SPEC_AFTER_FROM = 241,
        JSMSG_NAME_AFTER_DOT = 242,
        JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT = 243,
        JSMSG_NO_BINDING_NAME = 244,
        JSMSG_NO_EXPORT_NAME = 245,
        JSMSG_NO_IMPORT_NAME = 246,
        JSMSG_NO_VARIABLE_NAME = 247,
        JSMSG_PAREN_AFTER_ARGS = 248,
        JSMSG_PAREN_AFTER_CATCH = 249,
        JSMSG_PAREN_AFTER_COND = 250,
        JSMSG_PAREN_AFTER_FOR = 251,
        JSMSG_PAREN_AFTER_FORMAL = 252,
        JSMSG_PAREN_AFTER_FOR_CTRL = 253,
        JSMSG_PAREN_AFTER_SWITCH = 254,
        JSMSG_PAREN_AFTER_WITH = 255,
        JSMSG_PAREN_BEFORE_CATCH = 256,
        JSMSG_PAREN_BEFORE_COND = 257,
        JSMSG_PAREN_BEFORE_FORMAL = 258,
        JSMSG_PAREN_BEFORE_SWITCH = 259,
        JSMSG_PAREN_BEFORE_WITH = 260,
        JSMSG_PAREN_IN_PAREN = 261,
        JSMSG_PAREN_AFTER_DECORATOR = 262,
        JSMSG_RC_AFTER_EXPORT_SPEC_LIST = 263,
        JSMSG_RC_AFTER_IMPORT_SPEC_LIST = 264,
        JSMSG_RESERVED_ID = 265,
        JSMSG_REST_WITH_COMMA = 266,
        JSMSG_REST_WITH_DEFAULT = 267,
        JSMSG_SELFHOSTED_METHOD_CALL = 268,
        JSMSG_SEMI_AFTER_FOR_COND = 269,
        JSMSG_SEMI_AFTER_FOR_INIT = 270,
        JSMSG_SOURCE_TOO_LONG = 271,
        JSMSG_STMT_AFTER_RETURN = 272,
        JSMSG_STRICT_CODE_WITH = 273,
        JSMSG_STRICT_NON_SIMPLE_PARAMS = 274,
        JSMSG_TEMPLSTR_UNTERM_EXPR = 275,
        JSMSG_TOO_MANY_CASES = 276,
        JSMSG_TOO_MANY_CON_ARGS = 277,
        JSMSG_TOO_MANY_DEFAULTS = 278,
        JSMSG_TOO_MANY_FUN_ARGS = 279,
        JSMSG_TOO_MANY_LOCALS = 280,
        JSMSG_TOO_MANY_RESUME_INDEXES = 281,
        JSMSG_TOUGH_BREAK = 282,
        JSMSG_UNEXPECTED_TOKEN = 283,
        JSMSG_UNEXPECTED_TOKEN_NO_EXPECT = 284,
        JSMSG_UNEXPECTED_PARAMLIST_END = 285,
        JSMSG_UNNAMED_CLASS_STMT = 286,
        JSMSG_UNNAMED_FUNCTION_STMT = 287,
        JSMSG_UNPAIRED_SURROGATE_EXPORT = 288,
        JSMSG_UNTERMINATED_COMMENT = 289,
        JSMSG_UNTERMINATED_REGEXP = 290,
        JSMSG_UNTERMINATED_STATIC_CLASS_BLOCK = 291,
        JSMSG_EOF_BEFORE_END_OF_LITERAL = 292,
        JSMSG_EOL_BEFORE_END_OF_STRING = 293,
        JSMSG_EOF_IN_ESCAPE_IN_LITERAL = 294,
        JSMSG_USE_ASM_DIRECTIVE_FAIL = 295,
        JSMSG_VAR_HIDES_ARG = 296,
        JSMSG_WHILE_AFTER_DO = 297,
        JSMSG_YIELD_IN_PARAMETER = 298,
        JSMSG_YIELD_OUTSIDE_GENERATOR = 299,
        JSMSG_BAD_COLUMN_NUMBER = 300,
        JSMSG_BAD_LINE_NUMBER = 301,
        JSMSG_BAD_NEWTARGET = 302,
        JSMSG_BAD_NEW_OPTIONAL = 303,
        JSMSG_BAD_OPTIONAL_TEMPLATE = 304,
        JSMSG_IMPORT_ASSERTIONS_NOT_SUPPORTED = 305,
        JSMSG_ILLEGAL_PRIVATE_FIELD = 306,
        JSMSG_ILLEGAL_PRIVATE_NAME = 307,
        JSMSG_INVALID_PRIVATE_NAME_PRECEDENCE = 308,
        JSMSG_INVALID_PRIVATE_NAME_IN_UNARY_EXPR = 309,
        JSMSG_PRIVATE_FIELD_DOUBLE = 310,
        JSMSG_PRIVATE_BRAND_DOUBLE = 311,
        JSMSG_CURLY_AFTER_ASSERT = 312,
        JSMSG_DUPLICATE_ASSERT_KEY = 313,
        JSMSG_COLON_AFTER_ASSERT_KEY = 314,
        JSMSG_ASSERT_STRING_LITERAL = 315,
        JSMSG_ASSERT_KEY_EXPECTED = 316,
        JSMSG_DECORATOR_NAME_EXPECTED = 317,
        JSMSG_CLASS_EXPECTED = 318,
        JSMSG_BAD_LEADING_UTF8_UNIT = 319,
        JSMSG_NOT_ENOUGH_CODE_UNITS = 320,
        JSMSG_BAD_TRAILING_UTF8_UNIT = 321,
        JSMSG_FORBIDDEN_UTF8_CODE_POINT = 322,
        JSMSG_BAD_CODE_UNITS = 323,
        JSMSG_SMOOSH_COMPILE_ERROR = 324,
        JSMSG_SMOOSH_UNIMPLEMENTED = 325,
        JSMSG_USE_ASM_TYPE_FAIL = 326,
        JSMSG_USE_ASM_LINK_FAIL = 327,
        JSMSG_USE_ASM_TYPE_OK = 328,
        JSMSG_USE_ASM_TYPE_OK_NO_TIME = 329,
        JSMSG_WASM_VERBOSE = 330,
        JSMSG_WASM_COMPILE_WARNING = 331,
        JSMSG_WASM_HUGE_MEMORY_FAILED = 332,
        JSMSG_WASM_COMPILE_ERROR = 333,
        JSMSG_WASM_BAD_IMPORT_TYPE = 334,
        JSMSG_WASM_BAD_IMPORT_SIG = 335,
        JSMSG_WASM_BAD_TAG_SIG = 336,
        JSMSG_WASM_BAD_IMP_INDEX = 337,
        JSMSG_WASM_BAD_IMP_SIZE = 338,
        JSMSG_WASM_BAD_IMP_MAX = 339,
        JSMSG_WASM_IMP_SHARED_REQD = 340,
        JSMSG_WASM_IMP_SHARED_BANNED = 341,
        JSMSG_WASM_NO_SHMEM_LINK = 342,
        JSMSG_WASM_NO_MEM64_LINK = 343,
        JSMSG_WASM_BAD_GLOB_MUT_LINK = 344,
        JSMSG_WASM_BAD_GLOB_TYPE_LINK = 345,
        JSMSG_WASM_BAD_TBL_TYPE_LINK = 346,
        JSMSG_WASM_IND_CALL_TO_NULL = 347,
        JSMSG_WASM_IND_CALL_BAD_SIG = 348,
        JSMSG_WASM_UNREACHABLE = 349,
        JSMSG_WASM_INTEGER_OVERFLOW = 350,
        JSMSG_WASM_INVALID_CONVERSION = 351,
        JSMSG_WASM_INT_DIVIDE_BY_ZERO = 352,
        JSMSG_WASM_OUT_OF_BOUNDS = 353,
        JSMSG_WASM_UNALIGNED_ACCESS = 354,
        JSMSG_WASM_WAKE_OVERFLOW = 355,
        JSMSG_WASM_DEREF_NULL = 356,
        JSMSG_WASM_BAD_CAST = 357,
        JSMSG_WASM_MEM_IMP_LIMIT = 358,
        JSMSG_WASM_TABLE_IMP_LIMIT = 359,
        JSMSG_WASM_ARRAY_IMP_LIMIT = 360,
        JSMSG_WASM_BAD_RANGE = 361,
        JSMSG_WASM_BAD_GROW = 362,
        JSMSG_WASM_TABLE_OUT_OF_BOUNDS = 363,
        JSMSG_WASM_BAD_UINT32 = 364,
        JSMSG_WASM_BAD_BUF_ARG = 365,
        JSMSG_WASM_BAD_MOD_ARG = 366,
        JSMSG_WASM_BAD_BUF_MOD_ARG = 367,
        JSMSG_WASM_BAD_DESC_ARG = 368,
        JSMSG_WASM_BAD_IMPORT_ARG = 369,
        JSMSG_WASM_BAD_IMPORT_FIELD = 370,
        JSMSG_WASM_BAD_REF_NONNULLABLE_VALUE = 371,
        JSMSG_WASM_BAD_FUNCREF_VALUE = 372,
        JSMSG_WASM_BAD_EQREF_VALUE = 373,
        JSMSG_WASM_BAD_VAL_TYPE = 374,
        JSMSG_WASM_BAD_STRING_VAL_TYPE = 375,
        JSMSG_WASM_BAD_STRING_IDX_TYPE = 376,
        JSMSG_WASM_BAD_EXN_ARG = 377,
        JSMSG_WASM_BAD_EXN_PAYLOAD = 378,
        JSMSG_WASM_BAD_EXN_PAYLOAD_LEN = 379,
        JSMSG_WASM_BAD_EXN_TAG = 380,
        JSMSG_WASM_BAD_EXN_OPTIONS = 381,
        JSMSG_WASM_BAD_FUNCTION_VALUE = 382,
        JSMSG_WASM_NO_TRANSFER = 383,
        JSMSG_WASM_TEXT_FAIL = 384,
        JSMSG_WASM_MISSING_MAXIMUM = 385,
        JSMSG_WASM_GLOBAL_IMMUTABLE = 386,
        JSMSG_WASM_WRONG_NUMBER_OF_VALUES = 387,
        JSMSG_WASM_NONSHARED_WAIT = 388,
        JSMSG_WASM_SUPPLY_ONLY_ONE = 389,
        JSMSG_WASM_MISSING_REQUIRED = 390,
        JSMSG_BAD_GETPROTOTYPEOF_TRAP_RETURN = 391,
        JSMSG_INCONSISTENT_GETPROTOTYPEOF_TRAP = 392,
        JSMSG_PROXY_SETPROTOTYPEOF_RETURNED_FALSE = 393,
        JSMSG_INCONSISTENT_SETPROTOTYPEOF_TRAP = 394,
        JSMSG_CANT_CHANGE_EXTENSIBILITY = 395,
        JSMSG_CANT_DEFINE_INVALID = 396,
        JSMSG_CANT_DEFINE_NEW = 397,
        JSMSG_CANT_DEFINE_NE_AS_NC = 398,
        JSMSG_PROXY_DEFINE_RETURNED_FALSE = 399,
        JSMSG_PROXY_DELETE_RETURNED_FALSE = 400,
        JSMSG_PROXY_PREVENTEXTENSIONS_RETURNED_FALSE = 401,
        JSMSG_PROXY_SET_RETURNED_FALSE = 402,
        JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE = 403,
        JSMSG_CANT_DELETE_NON_EXTENSIBLE = 404,
        JSMSG_CANT_REPORT_C_AS_NC = 405,
        JSMSG_CANT_REPORT_E_AS_NE = 406,
        JSMSG_CANT_REPORT_INVALID = 407,
        JSMSG_CANT_REPORT_NC_AS_NE = 408,
        JSMSG_CANT_REPORT_NEW = 409,
        JSMSG_CANT_REPORT_NE_AS_NC = 410,
        JSMSG_CANT_REPORT_W_AS_NW = 411,
        JSMSG_CANT_SET_NW_NC = 412,
        JSMSG_CANT_SET_WO_SETTER = 413,
        JSMSG_CANT_SKIP_NC = 414,
        JSMSG_OWNKEYS_STR_SYM = 415,
        JSMSG_OWNKEYS_DUPLICATE = 416,
        JSMSG_MUST_REPORT_SAME_VALUE = 417,
        JSMSG_MUST_REPORT_UNDEFINED = 418,
        JSMSG_PROXY_CONSTRUCT_OBJECT = 419,
        JSMSG_PROXY_EXTENSIBILITY = 420,
        JSMSG_PROXY_GETOWN_OBJORUNDEF = 421,
        JSMSG_PROXY_REVOKED = 422,
        JSMSG_BAD_TRAP = 423,
        JSMSG_SC_BAD_CLONE_VERSION = 424,
        JSMSG_SC_BAD_SERIALIZED_DATA = 425,
        JSMSG_SC_DUP_TRANSFERABLE = 426,
        JSMSG_SC_NOT_TRANSFERABLE = 427,
        JSMSG_SC_UNSUPPORTED_TYPE = 428,
        JSMSG_SC_NOT_CLONABLE = 429,
        JSMSG_SC_NOT_CLONABLE_WITH_COOP_COEP = 430,
        JSMSG_SC_SAB_DISABLED = 431,
        JSMSG_SC_SAB_REFCNT_OFLO = 432,
        JSMSG_SC_SHMEM_TRANSFERABLE = 433,
        JSMSG_SC_SHMEM_POLICY = 434,
        JSMSG_ASSIGN_FUNCTION_OR_NULL = 435,
        JSMSG_DEBUG_BAD_LINE = 436,
        JSMSG_DEBUG_BAD_OFFSET = 437,
        JSMSG_DEBUG_BREAKPOINT_NOT_ALLOWED = 438,
        JSMSG_DEBUG_BAD_REFERENT = 439,
        JSMSG_DEBUG_BAD_RESUMPTION = 440,
        JSMSG_DEBUG_RESUMPTION_CONFLICT = 441,
        JSMSG_DEBUG_CANT_DEBUG_GLOBAL = 442,
        JSMSG_DEBUG_SAME_COMPARTMENT = 443,
        JSMSG_DEBUG_CCW_REQUIRED = 444,
        JSMSG_DEBUG_COMPARTMENT_MISMATCH = 445,
        JSMSG_DEBUG_LOOP = 446,
        JSMSG_DEBUG_NOT_DEBUGGEE = 447,
        JSMSG_DEBUG_NOT_DEBUGGING = 448,
        JSMSG_DEBUG_NOT_IDLE = 449,
        JSMSG_DEBUG_NOT_ON_STACK = 450,
        JSMSG_DEBUG_NOT_ON_STACK_OR_SUSPENDED = 451,
        JSMSG_DEBUG_NO_ENV_OBJECT = 452,
        JSMSG_DEBUG_PROTO = 453,
        JSMSG_DEBUG_WRONG_OWNER = 454,
        JSMSG_DEBUG_OPTIMIZED_OUT = 455,
        JSMSG_DEBUG_OPTIMIZED_OUT_FUN = 456,
        JSMSG_DEBUG_FORCED_RETURN_DISALLOWED = 457,
        JSMSG_DEBUG_RESUMPTION_VALUE_DISALLOWED = 458,
        JSMSG_DEBUG_VARIABLE_NOT_FOUND = 459,
        JSMSG_DEBUG_WRAPPER_IN_WAY = 460,
        JSMSG_DEBUGGEE_WOULD_RUN = 461,
        JSMSG_NOT_CALLABLE_OR_UNDEFINED = 462,
        JSMSG_NOT_TRACKING_ALLOCATIONS = 463,
        JSMSG_OBJECT_METADATA_CALLBACK_ALREADY_SET = 464,
        JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL = 465,
        JSMSG_QUERY_LINE_WITHOUT_URL = 466,
        JSMSG_DEBUG_CANT_SET_OPT_ENV = 467,
        JSMSG_DEBUG_INVISIBLE_COMPARTMENT = 468,
        JSMSG_DEBUG_CENSUS_BREAKDOWN = 469,
        JSMSG_DEBUG_PROMISE_NOT_RESOLVED = 470,
        JSMSG_DEBUG_PROMISE_NOT_FULFILLED = 471,
        JSMSG_DEBUG_PROMISE_NOT_REJECTED = 472,
        JSMSG_DEBUG_NO_BINARY_SOURCE = 473,
        JSMSG_TESTING_SCRIPTS_ONLY = 474,
        JSMSG_INVALID_ARGS = 475,
        JSMSG_TRACELOGGER_ENABLE_FAIL = 476,
        JSMSG_DATE_NOT_FINITE = 477,
        JSMSG_DUPLICATE_VARIANT_SUBTAG = 478,
        JSMSG_INTERNAL_INTL_ERROR = 479,
        JSMSG_INVALID_CURRENCY_CODE = 480,
        JSMSG_INVALID_UNIT_IDENTIFIER = 481,
        JSMSG_INVALID_DIGITS_VALUE = 482,
        JSMSG_INVALID_KEY = 483,
        JSMSG_INVALID_LANGUAGE_TAG = 484,
        JSMSG_INVALID_LOCALES_ELEMENT = 485,
        JSMSG_INVALID_LOCALE_MATCHER = 486,
        JSMSG_INVALID_OPTION_VALUE = 487,
        JSMSG_INVALID_TIME_ZONE = 488,
        JSMSG_INVALID_DATETIME_OPTION = 489,
        JSMSG_INVALID_DATETIME_STYLE = 490,
        JSMSG_UNDEFINED_CURRENCY = 491,
        JSMSG_UNDEFINED_UNIT = 492,
        JSMSG_UNDEFINED_DATE = 493,
        JSMSG_UNDEFINED_NUMBER = 494,
        JSMSG_UNDEFINED_TYPE = 495,
        JSMSG_EXPONENT_TOO_LARGE = 496,
        JSMSG_NAN_NUMBER_RANGE = 497,
        JSMSG_INVALID_NUMBER_OPTION = 498,
        JSMSG_UNEQUAL_FRACTION_DIGITS = 499,
        JSMSG_BAD_CLASS_RANGE = 500,
        JSMSG_ESCAPE_AT_END_OF_REGEXP = 501,
        JSMSG_EXEC_NOT_OBJORNULL = 502,
        JSMSG_INVALID_DECIMAL_ESCAPE = 503,
        JSMSG_INVALID_GROUP = 504,
        JSMSG_INVALID_IDENTITY_ESCAPE = 505,
        JSMSG_INVALID_UNICODE_ESCAPE = 506,
        JSMSG_MISSING_PAREN = 507,
        JSMSG_NEWREGEXP_FLAGGED = 508,
        JSMSG_NOTHING_TO_REPEAT = 509,
        JSMSG_NUMBERS_OUT_OF_ORDER = 510,
        JSMSG_RANGE_WITH_CLASS_ESCAPE = 511,
        JSMSG_RAW_BRACKET_IN_REGEXP = 512,
        JSMSG_TOO_MANY_PARENS = 513,
        JSMSG_UNICODE_OVERFLOW = 514,
        JSMSG_UNMATCHED_RIGHT_PAREN = 515,
        JSMSG_UNTERM_CLASS = 516,
        JSMSG_INVALID_PROPERTY_NAME = 517,
        JSMSG_INVALID_CLASS_PROPERTY_NAME = 518,
        JSMSG_INCOMPLETE_QUANTIFIER = 519,
        JSMSG_INVALID_QUANTIFIER = 520,
        JSMSG_INVALID_CAPTURE_NAME = 521,
        JSMSG_DUPLICATE_CAPTURE_NAME = 522,
        JSMSG_INVALID_NAMED_REF = 523,
        JSMSG_INVALID_NAMED_CAPTURE_REF = 524,
        JSMSG_INCOMPATIBLE_REGEXP_GETTER = 525,
        JSMSG_DEFAULT_LOCALE_ERROR = 526,
        JSMSG_TYPEDOBJECT_SETTING_IMMUTABLE = 527,
        JSMSG_TOO_LONG_ARRAY = 528,
        JSMSG_BAD_INDEX = 529,
        JSMSG_DEFINE_BAD_INDEX = 530,
        JSMSG_NON_ARRAY_BUFFER_RETURNED = 531,
        JSMSG_SAME_ARRAY_BUFFER_RETURNED = 532,
        JSMSG_SHORT_ARRAY_BUFFER_RETURNED = 533,
        JSMSG_TYPED_ARRAY_BAD_ARGS = 534,
        JSMSG_TYPED_ARRAY_DETACHED = 535,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_BOUNDS = 536,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_MISALIGNED = 537,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_LENGTH_BOUNDS = 538,
        JSMSG_TYPED_ARRAY_CONSTRUCT_ARRAY_LENGTH_BOUNDS = 539,
        JSMSG_TYPED_ARRAY_CONSTRUCT_TOO_LARGE = 540,
        JSMSG_TYPED_ARRAY_CALL_OR_CONSTRUCT = 541,
        JSMSG_NON_TYPED_ARRAY_RETURNED = 542,
        JSMSG_SHORT_TYPED_ARRAY_RETURNED = 543,
        JSMSG_TYPED_ARRAY_NOT_COMPATIBLE = 544,
        JSMSG_ARRAYBUFFER_REQUIRED = 545,
        JSMSG_ARRAYBUFFER_COPY_RANGE = 546,
        JSMSG_SHARED_ARRAY_BAD_LENGTH = 547,
        JSMSG_NON_SHARED_ARRAY_BUFFER_RETURNED = 548,
        JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED = 549,
        JSMSG_SHORT_SHARED_ARRAY_BUFFER_RETURNED = 550,
        JSMSG_BAD_PARSE_NODE = 551,
        JSMSG_SYMBOL_TO_STRING = 552,
        JSMSG_SYMBOL_TO_NUMBER = 553,
        JSMSG_ATOMICS_BAD_ARRAY = 554,
        JSMSG_ATOMICS_WAIT_NOT_ALLOWED = 555,
        JSMSG_CANT_SET_INTERPOSED = 556,
        JSMSG_CANT_DEFINE_WINDOW_ELEMENT = 557,
        JSMSG_CANT_DELETE_WINDOW_ELEMENT = 558,
        JSMSG_CANT_DEFINE_WINDOW_NAMED_PROPERTY = 559,
        JSMSG_CANT_DELETE_WINDOW_NAMED_PROPERTY = 560,
        JSMSG_CANT_PREVENT_EXTENSIONS = 561,
        JSMSG_CANT_DEFINE_WINDOW_NC = 562,
        JSMSG_NO_NAMED_SETTER = 563,
        JSMSG_NO_INDEXED_SETTER = 564,
        JSMSG_NOT_DATA_DESCRIPTOR = 565,
        JSMSG_CANT_DELETE_SUPER = 566,
        JSMSG_REINIT_THIS = 567,
        JSMSG_MISSING_INDIRECT_EXPORT = 568,
        JSMSG_AMBIGUOUS_INDIRECT_EXPORT = 569,
        JSMSG_MISSING_IMPORT = 570,
        JSMSG_AMBIGUOUS_IMPORT = 571,
        JSMSG_MISSING_EXPORT = 572,
        JSMSG_BAD_MODULE_STATUS = 573,
        JSMSG_DYNAMIC_IMPORT_FAILED = 574,
        JSMSG_IMPORT_MAPS_NOT_A_MAP = 575,
        JSMSG_IMPORT_MAPS_IMPORTS_NOT_A_MAP = 576,
        JSMSG_IMPORT_MAPS_SCOPES_NOT_A_MAP = 577,
        JSMSG_IMPORT_MAPS_SCOPE_VALUE_NOT_A_MAP = 578,
        JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF = 579,
        JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY = 580,
        JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE = 581,
        JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE = 582,
        JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON = 583,
        JSMSG_PROMISE_ANY_REJECTION = 584,
        JSMSG_RETURN_NOT_CALLABLE = 585,
        JSMSG_ITERATOR_NO_THROW = 586,
        JSMSG_UNHANDLABLE_PROMISE_REJECTION_WARNING = 587,
        JSMSG_FOR_AWAIT_NOT_OF = 588,
        JSMSG_NOT_AN_ASYNC_GENERATOR = 589,
        JSMSG_NOT_AN_ASYNC_ITERATOR = 590,
        JSMSG_GET_ASYNC_ITER_RETURNED_PRIMITIVE = 591,
        JSMSG_SUSPENDED_QUEUE_NOT_EMPTY = 592,
        JSMSG_READABLESTREAM_UNDERLYINGSOURCE_TYPE_WRONG = 593,
        JSMSG_READABLESTREAM_BYTES_TYPE_NOT_IMPLEMENTED = 594,
        JSMSG_READABLESTREAM_BYOB_READER_FOR_NON_BYTE_STREAM = 595,
        JSMSG_READABLESTREAM_INVALID_READER_MODE = 596,
        JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE = 597,
        JSMSG_READABLESTREAM_LOCKED_METHOD = 598,
        JSMSG_READABLESTREAM_LOCKED = 599,
        JSMSG_READABLESTREAM_NOT_DEFAULT_CONTROLLER = 600,
        JSMSG_READABLESTREAMREADER_NOT_OWNED = 601,
        JSMSG_READABLESTREAMREADER_NOT_EMPTY = 602,
        JSMSG_READABLESTREAMREADER_RELEASED = 603,
        JSMSG_READABLESTREAMCONTROLLER_CLOSED = 604,
        JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE = 605,
        JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE = 606,
        JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK = 607,
        JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL = 608,
        JSMSG_STREAM_MISSING_HIGHWATERMARK = 609,
        JSMSG_STREAM_INVALID_HIGHWATERMARK = 610,
        JSMSG_STREAM_CONSUME_ERROR = 611,
        JSMSG_WASM_ERROR_CONSUMING_RESPONSE = 612,
        JSMSG_WASM_BAD_RESPONSE_VALUE = 613,
        JSMSG_WASM_BAD_RESPONSE_MIME_TYPE = 614,
        JSMSG_WASM_BAD_RESPONSE_CORS_SAME_ORIGIN = 615,
        JSMSG_WASM_BAD_RESPONSE_STATUS = 616,
        JSMSG_WASM_RESPONSE_ALREADY_CONSUMED = 617,
        JSMSG_BIGINT_TO_NUMBER = 618,
        JSMSG_NONINTEGER_NUMBER_TO_BIGINT = 619,
        JSMSG_BIGINT_TOO_LARGE = 620,
        JSMSG_BIGINT_DIVISION_BY_ZERO = 621,
        JSMSG_BIGINT_NEGATIVE_EXPONENT = 622,
        JSMSG_BIGINT_INVALID_SYNTAX = 623,
        JSMSG_BIGINT_NOT_SERIALIZABLE = 624,
        JSMSG_NOT_A_FINALIZATION_REGISTRY = 625,
        JSMSG_BAD_HELD_VALUE = 626,
        JSMSG_BAD_UNREGISTER_TOKEN = 627,
        JSMSG_BAD_FINALIZATION_REGISTRY_OBJECT = 628,
        JSMSG_NOT_A_WEAK_REF = 629,
        JSMSG_BAD_WEAKREF_TARGET = 630,
        JSMSG_NEGATIVE_LIMIT = 631,
        JSMSG_RECORD_TUPLE_NO_OBJECT = 632,
        JSMSG_RECORD_NO_PROTO = 633,
        JSMSG_RECORD_NO_SYMBOL_KEY = 634,
        JSMSG_BAD_TUPLE_INDEX = 635,
        JSMSG_BAD_TUPLE_OBJECT = 636,
        JSMSG_RECORD_TUPLE_TO_NUMBER = 637,
        JSMSG_NOT_SHADOW_REALM = 638,
        JSMSG_SHADOW_REALM_EVALUATE_NOT_STRING = 639,
        JSMSG_SHADOW_REALM_INVALID_RETURN = 640,
        JSMSG_SHADOW_REALM_WRAP_FAILURE = 641,
        JSMSG_SHADOW_REALM_EVALUATE_FAILURE = 642,
        JSMSG_SHADOW_REALM_EVALUATE_FAILURE_DETAIL = 643,
        JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE = 644,
        JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE_DETAIL = 645,
        JSMSG_SHADOW_REALM_EXPORT_NOT_STRING = 646,
        JSMSG_SHADOW_REALM_IMPORTVALUE_FAILED = 647,
        JSMSG_SHADOW_REALM_VALUE_NOT_EXPORTED = 648,
        JSErr_Limit = 649,
    }
    extern "C" {
        #[doc = " Call a function, passing a this-value and arguments. This is the C++\n equivalent of `rval = Reflect.apply(fun, obj, args)`.\n\n Implements: ES6 7.3.12 Call(F, V, [argumentsList]).\n Use this function to invoke the [[Call]] internal method."]
        #[link_name = "\u{1}_Z20JS_CallFunctionValueP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEERKNS1_16HandleValueArrayENS1_13MutableHandleIS6_EE"]
        pub fn JS_CallFunctionValue(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fval: root::JS::Handle<root::JS::Value>,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_CallFunctionP9JSContextN2JS6HandleIP8JSObjectEENS2_IP10JSFunctionEERKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fun: root::JS::Handle<*mut root::JSFunction>,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the method call `rval = obj[name](args)`."]
        #[link_name = "\u{1}_Z19JS_CallFunctionNameP9JSContextN2JS6HandleIP8JSObjectEEPKcRKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunctionName(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_NewContextjP9JSRuntime"]
        pub fn JS_NewContext(
            maxbytes: u32,
            parentRuntime: *mut root::JSRuntime,
        ) -> *mut root::JSContext;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DestroyContextP9JSContext"]
        pub fn JS_DestroyContext(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetContextPrivateP9JSContext"]
        pub fn JS_GetContextPrivate(cx: *mut root::JSContext) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_SetContextPrivateP9JSContextPv"]
        pub fn JS_SetContextPrivate(cx: *mut root::JSContext, data: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetParentRuntimeP9JSContext"]
        pub fn JS_GetParentRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_GetRuntimeP9JSContext"]
        pub fn JS_GetRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetFutexCanWaitP9JSContext"]
        pub fn JS_SetFutexCanWait(cx: *mut root::JSContext);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSGCParamKey {
        #[doc = " Maximum nominal heap before last ditch GC.\n\n Soft limit on the number of bytes we are allowed to allocate in the GC\n heap. Attempts to allocate gcthings over this limit will return null and\n subsequently invoke the standard OOM machinery, independent of available\n physical memory.\n\n Pref: javascript.options.mem.max\n Default: 0xffffffff"]
        JSGC_MAX_BYTES = 0,
        #[doc = " Maximum size of the generational GC nurseries.\n\n This will be rounded to the nearest gc::ChunkSize.\n\n Pref: javascript.options.mem.nursery.max_kb\n Default: JS::DefaultNurseryMaxBytes"]
        JSGC_MAX_NURSERY_BYTES = 2,
        #[doc = " Amount of bytes allocated by the GC."]
        JSGC_BYTES = 3,
        #[doc = " Number of times GC has been invoked. Includes both major and minor GC."]
        JSGC_NUMBER = 4,
        #[doc = " Whether incremental GC is enabled. If not, GC will always run to\n completion.\n\n prefs: javascript.options.mem.gc_incremental.\n Default: false"]
        JSGC_INCREMENTAL_GC_ENABLED = 5,
        #[doc = " Whether per-zone GC is enabled. If not, all zones are collected every time.\n\n prefs: javascript.options.mem.gc_per_zone\n Default: false"]
        JSGC_PER_ZONE_GC_ENABLED = 6,
        #[doc = " Number of cached empty GC chunks."]
        JSGC_UNUSED_CHUNKS = 7,
        #[doc = " Total number of allocated GC chunks."]
        JSGC_TOTAL_CHUNKS = 8,
        #[doc = " Max milliseconds to spend in an incremental GC slice.\n\n A value of zero means there is no maximum.\n\n Pref: javascript.options.mem.gc_incremental_slice_ms\n Default: DefaultTimeBudgetMS."]
        JSGC_SLICE_TIME_BUDGET_MS = 9,
        #[doc = " Maximum size the GC mark stack can grow to.\n\n Pref: none\n Default: MarkStack::DefaultCapacity"]
        JSGC_MARK_STACK_LIMIT = 10,
        #[doc = " GCs less than this far apart in milliseconds will be considered\n 'high-frequency GCs'.\n\n Pref: javascript.options.mem.gc_high_frequency_time_limit_ms\n Default: HighFrequencyThreshold"]
        JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,
        #[doc = " Upper limit for classifying a heap as small (MB).\n\n Dynamic heap growth thresholds are based on whether the heap is small,\n medium or large. Heaps smaller than this size are classified as small;\n larger heaps are classified as medium or large.\n\n Pref: javascript.options.mem.gc_small_heap_size_max_mb\n Default: SmallHeapSizeMaxBytes"]
        JSGC_SMALL_HEAP_SIZE_MAX = 12,
        #[doc = " Lower limit for classifying a heap as large (MB).\n\n Dynamic heap growth thresholds are based on whether the heap is small,\n medium or large. Heaps larger than this size are classified as large;\n smaller heaps are classified as small or medium.\n\n Pref: javascript.options.mem.gc_large_heap_size_min_mb\n Default: LargeHeapSizeMinBytes"]
        JSGC_LARGE_HEAP_SIZE_MIN = 13,
        #[doc = " Heap growth factor for small heaps in the high-frequency GC state.\n\n Pref: javascript.options.mem.gc_high_frequency_small_heap_growth\n Default: HighFrequencySmallHeapGrowth"]
        JSGC_HIGH_FREQUENCY_SMALL_HEAP_GROWTH = 14,
        #[doc = " Heap growth factor for large heaps in the high-frequency GC state.\n\n Pref: javascript.options.mem.gc_high_frequency_large_heap_growth\n Default: HighFrequencyLargeHeapGrowth"]
        JSGC_HIGH_FREQUENCY_LARGE_HEAP_GROWTH = 15,
        #[doc = " Heap growth factor for low frequency GCs.\n\n This factor is applied regardless of the size of the heap when not in the\n high-frequency GC state.\n\n Pref: javascript.options.mem.gc_low_frequency_heap_growth\n Default: LowFrequencyHeapGrowth"]
        JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,
        #[doc = " Whether balanced heap limits are enabled.\n\n If this is set to true then heap limits are calculated in a way designed to\n balance memory usage optimally between many heaps.\n\n Otherwise, heap limits are set based on a linear multiple of the retained\n size after the last collection.\n\n Pref: javascript.options.mem.gc_balanced_heap_limits\n Default: BalancedHeapLimitsEnabled"]
        JSGC_BALANCED_HEAP_LIMITS_ENABLED = 17,
        #[doc = " Heap growth parameter for balanced heap limit calculation.\n\n This parameter trades off GC time for memory usage. Smaller values result\n in lower memory use and larger values result in less time spent collecting.\n\n Heap limits are set to the heap's retained size plus some extra space. The\n extra space is calculated based on several factors but is scaled\n proportionally to this parameter.\n\n Pref: javascript.options.mem.gc_heap_growth_factor\n Default: HeapGrowthFactor"]
        JSGC_HEAP_GROWTH_FACTOR = 18,
        #[doc = " Lower limit for collecting a zone (MB).\n\n Zones smaller than this size will not normally be collected.\n\n Pref: javascript.options.mem.gc_allocation_threshold_mb\n Default GCZoneAllocThresholdBase"]
        JSGC_ALLOCATION_THRESHOLD = 19,
        #[doc = " We try to keep at least this many unused chunks in the free chunk pool at\n all times, even after a shrinking GC.\n\n Pref: javascript.options.mem.gc_min_empty_chunk_count\n Default: MinEmptyChunkCount"]
        JSGC_MIN_EMPTY_CHUNK_COUNT = 21,
        #[doc = " We never keep more than this many unused chunks in the free chunk\n pool.\n\n Pref: javascript.options.mem.gc_min_empty_chunk_count\n Default: MinEmptyChunkCount"]
        JSGC_MAX_EMPTY_CHUNK_COUNT = 22,
        #[doc = " Whether compacting GC is enabled.\n\n Pref: javascript.options.mem.gc_compacting\n Default: CompactingEnabled"]
        JSGC_COMPACTING_ENABLED = 23,
        #[doc = " Limit of how far over the incremental trigger threshold we allow the heap\n to grow before finishing a collection non-incrementally, for small heaps.\n\n We trigger an incremental GC when a trigger threshold is reached but the\n collection may not be fast enough to keep up with the mutator. At some\n point we finish the collection non-incrementally.\n\n Default: SmallHeapIncrementalLimit\n Pref: javascript.options.mem.gc_small_heap_incremental_limit"]
        JSGC_SMALL_HEAP_INCREMENTAL_LIMIT = 25,
        #[doc = " Limit of how far over the incremental trigger threshold we allow the heap\n to grow before finishing a collection non-incrementally, for large heaps.\n\n Default: LargeHeapIncrementalLimit\n Pref: javascript.options.mem.gc_large_heap_incremental_limit"]
        JSGC_LARGE_HEAP_INCREMENTAL_LIMIT = 26,
        #[doc = " Attempt to run a minor GC in the idle time if the free space falls\n below this number of bytes.\n\n Default: NurseryChunkUsableSize / 4\n Pref: None"]
        JSGC_NURSERY_FREE_THRESHOLD_FOR_IDLE_COLLECTION = 27,
        #[doc = " If this percentage of the nursery is tenured and the nursery is at least\n 4MB, then proceed to examine which groups we should pretenure.\n\n Default: PretenureThreshold\n Pref: None"]
        JSGC_PRETENURE_THRESHOLD = 28,
        #[doc = " If the above condition is met, then any object group that tenures more than\n this number of objects will be pretenured (if it can be).\n\n Default: PretenureGroupThreshold\n Pref: None"]
        JSGC_PRETENURE_GROUP_THRESHOLD = 29,
        #[doc = " Attempt to run a minor GC in the idle time if the free space falls\n below this percentage (from 0 to 99).\n\n Default: 25\n Pref: None"]
        JSGC_NURSERY_FREE_THRESHOLD_FOR_IDLE_COLLECTION_PERCENT = 30,
        #[doc = " Minimum size of the generational GC nurseries.\n\n This value will be rounded to the nearest Nursery::SubChunkStep if below\n gc::ChunkSize, otherwise it'll be rounded to the nearest gc::ChunkSize.\n\n Default: Nursery::SubChunkLimit\n Pref: javascript.options.mem.nursery.min_kb"]
        JSGC_MIN_NURSERY_BYTES = 31,
        #[doc = " The minimum time to allow between triggering last ditch GCs in seconds.\n\n Default: 60 seconds\n Pref: None"]
        JSGC_MIN_LAST_DITCH_GC_PERIOD = 32,
        #[doc = " The delay (in heapsize kilobytes) between slices of an incremental GC.\n\n Default: ZoneAllocDelayBytes"]
        JSGC_ZONE_ALLOC_DELAY_KB = 33,
        #[doc = " The delay (in heapsize kilobytes) between slices of an incremental GC.\n\n Default: ZoneAllocDelayBytes"]
        JSGC_NURSERY_BYTES = 34,
        #[doc = " Retained size base value for calculating malloc heap threshold.\n\n Default: MallocThresholdBase"]
        JSGC_MALLOC_THRESHOLD_BASE = 35,
        #[doc = " Whether incremental weakmap marking is enabled.\n\n Pref: javascript.options.mem.incremental_weakmap\n Default: IncrementalWeakMarkEnabled"]
        JSGC_INCREMENTAL_WEAKMAP_ENABLED = 37,
        #[doc = " The chunk size in bytes for this system.\n\n This parameter is read-only."]
        JSGC_CHUNK_BYTES = 38,
        #[doc = " The number of background threads to use for parallel GC work for each CPU\n core, expressed as an integer percentage.\n\n Pref: javascript.options.mem.gc_helper_thread_ratio"]
        JSGC_HELPER_THREAD_RATIO = 39,
        #[doc = " The maximum number of background threads to use for parallel GC work.\n\n Pref: javascript.options.mem.gc_max_helper_threads"]
        JSGC_MAX_HELPER_THREADS = 40,
        #[doc = " The number of background threads to use for parallel GC work.\n\n This parameter is read-only and is set based on the\n JSGC_HELPER_THREAD_RATIO and JSGC_MAX_HELPER_THREADS parameters."]
        JSGC_HELPER_THREAD_COUNT = 41,
        #[doc = " If the percentage of the tenured strings exceeds this threshold, string\n will be allocated in tenured heap instead. (Default is allocated in\n nursery.)"]
        JSGC_PRETENURE_STRING_THRESHOLD = 42,
        #[doc = " If the finalization rate of the tenured strings exceeds this threshold,\n string will be allocated in nursery."]
        JSGC_STOP_PRETENURE_STRING_THRESHOLD = 43,
        #[doc = " A number that is incremented on every major GC slice."]
        JSGC_MAJOR_GC_NUMBER = 44,
        #[doc = " A number that is incremented on every minor GC."]
        JSGC_MINOR_GC_NUMBER = 45,
        #[doc = " JS::MaybeRunNurseryCollection will collect the nursery if it hasn't been\n collected in this many milliseconds.\n\n Default: 5000\n Pref: None"]
        JSGC_NURSERY_TIMEOUT_FOR_IDLE_COLLECTION_MS = 46,
        #[doc = " The system page size in KB.\n\n This parameter is read-only."]
        JSGC_SYSTEM_PAGE_SIZE_KB = 47,
        #[doc = " In an incremental GC, this determines the point at which to start\n increasing the slice budget and frequency of allocation triggered slices to\n try to avoid reaching the incremental limit and finishing the collection\n synchronously.\n\n The threshold is calculated by subtracting this value from the heap's\n incremental limit."]
        JSGC_URGENT_THRESHOLD_MB = 48,
    }
    pub type JSTraceDataOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, data: *mut ::std::os::raw::c_void),
    >;
    pub type JSGrayRootsTracer = ::std::option::Option<
        unsafe extern "C" fn(
            trc: *mut root::JSTracer,
            budget: *mut root::js::SliceBudget,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSGCStatus {
        JSGC_BEGIN = 0,
        JSGC_END = 1,
    }
    pub type JSObjectsTenuredCallback = ::std::option::Option<
        unsafe extern "C" fn(cx: *mut root::JSContext, data: *mut ::std::os::raw::c_void),
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSFinalizeStatus {
        #[doc = " Called when preparing to sweep a group of zones, before anything has been\n swept.  The collector will not yield to the mutator before calling the\n callback with JSFINALIZE_GROUP_START status."]
        JSFINALIZE_GROUP_PREPARE = 0,
        #[doc = " Called after preparing to sweep a group of zones. Weak references to\n unmarked things have been removed at this point, but no GC things have\n been swept. The collector may yield to the mutator after this point."]
        JSFINALIZE_GROUP_START = 1,
        #[doc = " Called after sweeping a group of zones. All dead GC things have been\n swept at this point."]
        JSFINALIZE_GROUP_END = 2,
        #[doc = " Called at the end of collection when everything has been swept."]
        JSFINALIZE_COLLECTION_END = 3,
    }
    pub type JSFinalizeCallback = ::std::option::Option<
        unsafe extern "C" fn(
            gcx: *mut root::JS::GCContext,
            status: root::JSFinalizeStatus,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSWeakPointerZonesCallback = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, data: *mut ::std::os::raw::c_void),
    >;
    pub type JSWeakPointerCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            trc: *mut root::JSTracer,
            comp: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSHostCleanupFinalizationRegistryCallback = ::std::option::Option<
        unsafe extern "C" fn(
            doCleanup: *mut root::JSFunction,
            incumbentGlobal: *mut root::JSObject,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    #[repr(C)]
    pub struct JSExternalStringCallbacks__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Each external string has a pointer to JSExternalStringCallbacks. Embedders\n can use this to implement custom finalization or memory reporting behavior."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSExternalStringCallbacks {
        pub vtable_: *const JSExternalStringCallbacks__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_JSExternalStringCallbacks() {
        assert_eq!(
            ::std::mem::size_of::<JSExternalStringCallbacks>(),
            8usize,
            concat!("Size of: ", stringify!(JSExternalStringCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSExternalStringCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSExternalStringCallbacks))
        );
    }
    pub type JSGCCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            status: root::JSGCStatus,
            reason: root::JS::GCReason,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    extern "C" {
        #[doc = " Register externally maintained GC roots.\n\n traceOp: the trace operation. For each root the implementation should call\n          JS::TraceEdge whenever the root contains a traceable thing.\n data:    the data argument to pass to each invocation of traceOp."]
        #[link_name = "\u{1}_Z24JS_AddExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_AddExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Undo a call to JS_AddExtraGCRootsTracer."]
        #[link_name = "\u{1}_Z27JS_RemoveExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_RemoveExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z5JS_GCP9JSContextN2JS8GCReasonE"]
        pub fn JS_GC(cx: *mut root::JSContext, reason: root::JS::GCReason);
    }
    extern "C" {
        #[link_name = "\u{1}_Z10JS_MaybeGCP9JSContext"]
        pub fn JS_MaybeGC(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_SetGCCallbackP9JSContextPFvS0_10JSGCStatusN2JS8GCReasonEPvES4_"]
        pub fn JS_SetGCCallback(
            cx: *mut root::JSContext,
            cb: root::JSGCCallback,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_SetObjectsTenuredCallbackP9JSContextPFvS0_PvES1_"]
        pub fn JS_SetObjectsTenuredCallback(
            cx: *mut root::JSContext,
            cb: root::JSObjectsTenuredCallback,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_AddFinalizeCallbackP9JSContextPFvPN2JS9GCContextE16JSFinalizeStatusPvES5_"]
        pub fn JS_AddFinalizeCallback(
            cx: *mut root::JSContext,
            cb: root::JSFinalizeCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_RemoveFinalizeCallbackP9JSContextPFvPN2JS9GCContextE16JSFinalizeStatusPvE"]
        pub fn JS_RemoveFinalizeCallback(cx: *mut root::JSContext, cb: root::JSFinalizeCallback);
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_AddWeakPointerZonesCallbackP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_AddWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_RemoveWeakPointerZonesCallbackP9JSContextPFvP8JSTracerPvE"]
        pub fn JS_RemoveWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z36JS_AddWeakPointerCompartmentCallbackP9JSContextPFvP8JSTracerPN2JS11CompartmentEPvES6_"]
        pub fn JS_AddWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z39JS_RemoveWeakPointerCompartmentCallbackP9JSContextPFvP8JSTracerPN2JS11CompartmentEPvE"]
        pub fn JS_RemoveWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_UpdateWeakPointerAfterGCP8JSTracerPN2JS4HeapIP8JSObjectEE"]
        pub fn JS_UpdateWeakPointerAfterGC(
            trc: *mut root::JSTracer,
            objp: *mut root::JS::Heap<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z38JS_UpdateWeakPointerAfterGCUnbarrieredP8JSTracerPP8JSObject"]
        pub fn JS_UpdateWeakPointerAfterGCUnbarriered(
            trc: *mut root::JSTracer,
            objp: *mut *mut root::JSObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_SetGCParameterP9JSContext12JSGCParamKeyj"]
        pub fn JS_SetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey, value: u32);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_ResetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_ResetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_GetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey) -> u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z40JS_SetGCParametersBasedOnAvailableMemoryP9JSContextj"]
        pub fn JS_SetGCParametersBasedOnAvailableMemory(cx: *mut root::JSContext, availMemMB: u32);
    }
    extern "C" {
        #[doc = " Create a new JSString whose chars member refers to external memory, i.e.,\n memory requiring application-specific finalization."]
        #[link_name = "\u{1}_Z20JS_NewExternalStringP9JSContextPKDsmPK25JSExternalStringCallbacks"]
        pub fn JS_NewExternalString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Create a new JSString whose chars member may refer to external memory.\n If a new external string is allocated, |*allocatedExternal| is set to true.\n Otherwise the returned string is either not an external string or an\n external string allocated by a previous call and |*allocatedExternal| is set\n to false. If |*allocatedExternal| is false, |fin| won't be called."]
        #[link_name = "\u{1}_Z25JS_NewMaybeExternalStringP9JSContextPKDsmPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Return the 'callbacks' arg passed to JS_NewExternalString or\n JS_NewMaybeExternalString."]
        #[link_name = "\u{1}_Z29JS_GetExternalStringCallbacksP8JSString"]
        pub fn JS_GetExternalStringCallbacks(
            str_: *mut root::JSString,
        ) -> *const root::JSExternalStringCallbacks;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_DefineDebuggerObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineDebuggerObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    #[repr(C)]
    pub struct JSErrorInterceptor__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Callback used to intercept JavaScript errors."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSErrorInterceptor {
        pub vtable_: *const JSErrorInterceptor__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_JSErrorInterceptor() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorInterceptor>(),
            8usize,
            concat!("Size of: ", stringify!(JSErrorInterceptor))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorInterceptor>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorInterceptor))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_SetErrorInterceptorCallbackP9JSRuntimeP18JSErrorInterceptor"]
        pub fn JS_SetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
            callback: *mut root::JSErrorInterceptor,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_GetErrorInterceptorCallbackP9JSRuntime"]
        pub fn JS_GetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
        ) -> *mut root::JSErrorInterceptor;
    }
    impl root::JSExnType {
        pub const JSEXN_FIRST: root::JSExnType = JSExnType::JSEXN_ERR;
    }
    impl root::JSExnType {
        pub const JSEXN_WARN: root::JSExnType = JSExnType::JSEXN_ERROR_LIMIT;
    }
    #[repr(u32)]
    #[doc = " Possible exception types. These types are part of a JSErrorFormatString\n structure. They define which error to throw in case of a runtime error.\n\n JSEXN_WARN is used for warnings, that are not strictly errors but are handled\n using the generalized error reporting mechanism.  (One side effect of this\n type is to not prepend 'Error:' to warning messages.)  This value can go away\n if we ever decide to use an entirely separate mechanism for warnings."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSExnType {
        JSEXN_ERR = 0,
        JSEXN_INTERNALERR = 1,
        JSEXN_AGGREGATEERR = 2,
        JSEXN_EVALERR = 3,
        JSEXN_RANGEERR = 4,
        JSEXN_REFERENCEERR = 5,
        JSEXN_SYNTAXERR = 6,
        JSEXN_TYPEERR = 7,
        JSEXN_URIERR = 8,
        JSEXN_DEBUGGEEWOULDRUN = 9,
        JSEXN_WASMCOMPILEERROR = 10,
        JSEXN_WASMLINKERROR = 11,
        JSEXN_WASMRUNTIMEERROR = 12,
        JSEXN_ERROR_LIMIT = 13,
        JSEXN_NOTE = 14,
        JSEXN_LIMIT = 15,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSErrorFormatString {
        #[doc = " The error message name in ASCII."]
        pub name: *const ::std::os::raw::c_char,
        #[doc = " The error format string in ASCII."]
        pub format: *const ::std::os::raw::c_char,
        #[doc = " The number of arguments to expand in the formatted error message."]
        pub argCount: u16,
        #[doc = " One of the JSExnType constants above."]
        pub exnType: i16,
    }
    #[test]
    fn bindgen_test_layout_JSErrorFormatString() {
        const UNINIT: ::std::mem::MaybeUninit<JSErrorFormatString> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSErrorFormatString>(),
            24usize,
            concat!("Size of: ", stringify!(JSErrorFormatString))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorFormatString>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorFormatString))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(format)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).argCount) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(argCount)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).exnType) as usize - ptr as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(exnType)
            )
        );
    }
    pub type JSErrorCallback = ::std::option::Option<
        unsafe extern "C" fn(
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
        ) -> *const root::JSErrorFormatString,
    >;
    #[doc = " Base class that implements parts shared by JSErrorReport and\n JSErrorNotes::Note."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorBase {
        pub message_: root::JS::ConstUTF8CharsZ,
        pub filename: *const ::std::os::raw::c_char,
        pub sourceId: ::std::os::raw::c_uint,
        pub lineno: ::std::os::raw::c_uint,
        pub column: ::std::os::raw::c_uint,
        pub errorNumber: ::std::os::raw::c_uint,
        pub errorMessageName: *const ::std::os::raw::c_char,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 7usize],
    }
    #[test]
    fn bindgen_test_layout_JSErrorBase() {
        const UNINIT: ::std::mem::MaybeUninit<JSErrorBase> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSErrorBase>(),
            48usize,
            concat!("Size of: ", stringify!(JSErrorBase))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorBase>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorBase))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).message_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(message_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(filename)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(sourceId)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(lineno)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(column)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).errorNumber) as usize - ptr as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(errorNumber)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).errorMessageName) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(errorMessageName)
            )
        );
    }
    impl JSErrorBase {
        #[inline]
        pub fn ownsMessage_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsMessage_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(ownsMessage_: bool) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let ownsMessage_: u8 = unsafe { ::std::mem::transmute(ownsMessage_) };
                ownsMessage_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[doc = " Notes associated with JSErrorReport."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes {
        pub notes_: [u64; 4usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_Note {
        pub _base: root::JSErrorBase,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_Note() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorNotes_Note>(),
            48usize,
            concat!("Size of: ", stringify!(JSErrorNotes_Note))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorNotes_Note>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorNotes_Note))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSErrorNotes_iterator {
        pub note_: *mut u64,
    }
    pub type JSErrorNotes_iterator_iterator_category = root::std::input_iterator_tag;
    #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
    pub type JSErrorNotes_iterator_value_type = u64;
    pub type JSErrorNotes_iterator_difference_type = isize;
    pub type JSErrorNotes_iterator_pointer = *mut root::JSErrorNotes_iterator_value_type;
    pub type JSErrorNotes_iterator_reference = *mut root::JSErrorNotes_iterator_value_type;
    #[test]
    fn bindgen_test_layout_JSErrorNotes_iterator() {
        const UNINIT: ::std::mem::MaybeUninit<JSErrorNotes_iterator> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSErrorNotes_iterator>(),
            8usize,
            concat!("Size of: ", stringify!(JSErrorNotes_iterator))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorNotes_iterator>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorNotes_iterator))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).note_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorNotes_iterator),
                "::",
                stringify!(note_)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes() {
        const UNINIT: ::std::mem::MaybeUninit<JSErrorNotes> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSErrorNotes>(),
            32usize,
            concat!("Size of: ", stringify!(JSErrorNotes))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorNotes>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorNotes))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).notes_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorNotes),
                "::",
                stringify!(notes_)
            )
        );
    }
    #[doc = " Describes a single error or warning that occurs in the execution of script."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorReport {
        pub _base: root::JSErrorBase,
        pub linebuf_: *const u16,
        pub linebufLength_: usize,
        pub tokenOffset_: usize,
        pub notes: u64,
        pub exnType: i16,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 5usize],
    }
    #[test]
    fn bindgen_test_layout_JSErrorReport() {
        const UNINIT: ::std::mem::MaybeUninit<JSErrorReport> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSErrorReport>(),
            88usize,
            concat!("Size of: ", stringify!(JSErrorReport))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorReport>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorReport))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).linebuf_) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(linebuf_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).linebufLength_) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(linebufLength_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).tokenOffset_) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(tokenOffset_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).notes) as usize - ptr as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(notes)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).exnType) as usize - ptr as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(exnType)
            )
        );
    }
    impl JSErrorReport {
        #[inline]
        pub fn isMuted(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_isMuted(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isWarning_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_isWarning_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ownsLinebuf_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsLinebuf_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            isMuted: bool,
            isWarning_: bool,
            ownsLinebuf_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let isMuted: u8 = unsafe { ::std::mem::transmute(isMuted) };
                isMuted as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let isWarning_: u8 = unsafe { ::std::mem::transmute(isWarning_) };
                isWarning_ as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let ownsLinebuf_: u8 = unsafe { ::std::mem::transmute(ownsLinebuf_) };
                ownsLinebuf_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    extern "C" {
        #[doc = " Report an exception represented by the sprintf-like conversion of format\n and its arguments."]
        #[link_name = "\u{1}_Z19JS_ReportErrorASCIIP9JSContextPKcz"]
        pub fn JS_ReportErrorASCII(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_ReportErrorLatin1P9JSContextPKcz"]
        pub fn JS_ReportErrorLatin1(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_ReportErrorUTF8P9JSContextPKcz"]
        pub fn JS_ReportErrorUTF8(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_ReportErrorNumberASCIIP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberASCII(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberASCIIVAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberASCIIVA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberLatin1P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberLatin1(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_ReportErrorNumberLatin1VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberLatin1VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_ReportErrorNumberUTF8P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUTF8(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberUTF8VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberUTF8VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_ReportErrorNumberUTF8ArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKc"]
        pub fn JS_ReportErrorNumberUTF8Array(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            args: *mut *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_ReportErrorNumberUCP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUC(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberUCArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKDs"]
        pub fn JS_ReportErrorNumberUCArray(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            args: *mut *const u16,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_ExpandErrorArgumentsASCIIP9JSContextPFPK19JSErrorFormatStringPvjEjP13JSErrorReportz"]
        pub fn JS_ExpandErrorArgumentsASCII(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            errorNumber: ::std::os::raw::c_uint,
            reportp: *mut root::JSErrorReport,
            ...
        ) -> bool;
    }
    extern "C" {
        #[doc = " Complain when an allocation size overflows the maximum supported limit."]
        #[link_name = "\u{1}_Z27JS_ReportAllocationOverflowP9JSContext"]
        pub fn JS_ReportAllocationOverflow(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_IsExceptionPendingP9JSContext"]
        pub fn JS_IsExceptionPending(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_IsThrowingOutOfMemoryP9JSContext"]
        pub fn JS_IsThrowingOutOfMemory(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetPendingExceptionP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPendingException(
            cx: *mut root::JSContext,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_SetPendingExceptionP9JSContextN2JS6HandleINS1_5ValueEEENS1_22ExceptionStackBehaviorE"]
        pub fn JS_SetPendingException(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            behavior: root::JS::ExceptionStackBehavior,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_ClearPendingExceptionP9JSContext"]
        pub fn JS_ClearPendingException(cx: *mut root::JSContext);
    }
    extern "C" {
        #[doc = " If the given object is an exception object, the exception will have (or be\n able to lazily create) an error report struct, and this function will return\n the address of that struct.  Otherwise, it returns nullptr. The lifetime\n of the error report struct that might be returned is the same as the\n lifetime of the exception object."]
        #[link_name = "\u{1}_Z21JS_ErrorFromExceptionP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ErrorFromException(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSErrorReport;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_IsGlobalObjectP8JSObject"]
        pub fn JS_IsGlobalObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewGlobalObjectP9JSContextPK7JSClassP12JSPrincipalsN2JS21OnNewGlobalHookOptionERKNS6_12RealmOptionsE"]
        pub fn JS_NewGlobalObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            principals: *mut root::JSPrincipals,
            hookOption: root::JS::OnNewGlobalHookOption,
            options: *const root::JS::RealmOptions,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Spidermonkey does not have a good way of keeping track of what compartments\n should be marked on their own. We can mark the roots unconditionally, but\n marking GC things only relevant in live compartments is hard. To mitigate\n this, we create a static trace hook, installed on each global object, from\n which we can be sure the compartment is relevant, and mark it.\n\n It is still possible to specify custom trace hooks for global object classes.\n They can be provided via the RealmOptions passed to JS_NewGlobalObject."]
        #[link_name = "\u{1}_Z24JS_GlobalObjectTraceHookP8JSTracerP8JSObject"]
        pub fn JS_GlobalObjectTraceHook(trc: *mut root::JSTracer, global: *mut root::JSObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_FireOnNewGlobalObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FireOnNewGlobalObject(cx: *mut root::JSContext, global: root::JS::HandleObject);
    }
    pub type JSInterruptCallback =
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::JSContext) -> bool>;
    extern "C" {
        #[link_name = "\u{1}_Z20JS_CheckForInterruptP9JSContext"]
        pub fn JS_CheckForInterrupt(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AddInterruptCallbackP9JSContextPFbS0_E"]
        pub fn JS_AddInterruptCallback(
            cx: *mut root::JSContext,
            callback: root::JSInterruptCallback,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_DisableInterruptCallbackP9JSContext"]
        pub fn JS_DisableInterruptCallback(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_ResetInterruptCallbackP9JSContextb"]
        pub fn JS_ResetInterruptCallback(cx: *mut root::JSContext, enable: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_RequestInterruptCallbackP9JSContext"]
        pub fn JS_RequestInterruptCallback(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_RequestInterruptCallbackCanWaitP9JSContext"]
        pub fn JS_RequestInterruptCallbackCanWait(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z9JS_mallocP9JSContextm"]
        pub fn JS_malloc(cx: *mut root::JSContext, nbytes: usize) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z10JS_reallocP9JSContextPvmm"]
        pub fn JS_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " A wrapper for |js_free(p)| that may delay |js_free(p)| invocation as a\n performance optimization.  |cx| may be nullptr."]
        #[link_name = "\u{1}_Z7JS_freeP9JSContextPv"]
        pub fn JS_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Same as above, but for buffers that will be used with the BYOB\n (Bring Your Own Buffer) JSString creation functions, such as\n JS_NewLatin1String and JS_NewUCString"]
        #[link_name = "\u{1}_Z16JS_string_mallocP9JSContextm"]
        pub fn JS_string_malloc(
            cx: *mut root::JSContext,
            nbytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_string_reallocP9JSContextPvmm"]
        pub fn JS_string_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_string_freeP9JSContextPv"]
        pub fn JS_string_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Define a property on obj.\n\n This function uses JS::ObjectOpResult to indicate conditions that ES6\n specifies as non-error failures. This is inconvenient at best, so use this\n function only if you are implementing a proxy handler's defineProperty()\n method. For all other purposes, use one of the many DefineProperty functions\n below that throw an exception in all failure cases.\n\n Implements: ES6 [[DefineOwnProperty]] internal method."]
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefinePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Define a property on obj, throwing a TypeError if the attempt fails.\n This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`."]
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefinePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEEj"]
        pub fn JS_DefinePropertyById2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefinePropertyById3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_S5_j"]
        pub fn JS_DefinePropertyById4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_j"]
        pub fn JS_DefinePropertyById5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_IP8JSStringEEj"]
        pub fn JS_DefinePropertyById6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEij"]
        pub fn JS_DefinePropertyById7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEjj"]
        pub fn JS_DefinePropertyById8(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEdj"]
        pub fn JS_DefinePropertyById9(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefineProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_S5_j"]
        pub fn JS_DefineProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_j"]
        pub fn JS_DefineProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_IP8JSStringEEj"]
        pub fn JS_DefineProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcij"]
        pub fn JS_DefineProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcjj"]
        pub fn JS_DefineProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcdj"]
        pub fn JS_DefineProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefineUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefineUCProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineUCProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_S5_j"]
        pub fn JS_DefineUCProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_j"]
        pub fn JS_DefineUCProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_IP8JSStringEEj"]
        pub fn JS_DefineUCProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmij"]
        pub fn JS_DefineUCProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmjj"]
        pub fn JS_DefineUCProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmdj"]
        pub fn JS_DefineUCProperty8(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_S5_j"]
        pub fn JS_DefineElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_j"]
        pub fn JS_DefineElement2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEEj"]
        pub fn JS_DefineElement3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjij"]
        pub fn JS_DefineElement4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjjj"]
        pub fn JS_DefineElement5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjdj"]
        pub fn JS_DefineElement6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Compute the expression `id in obj`.\n\n If obj has an own or inherited property obj[id], set *foundp = true and\n return true. If not, set *foundp = false and return true. On error, return\n false with an exception pending.\n\n Implements: ES6 [[Has]] internal method."]
        #[link_name = "\u{1}_Z18JS_HasPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_HasPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_HasUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_HasUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            vp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_HasElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_HasElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether obj has an own property with the key `id`.\n\n Implements: ES6 7.3.11 HasOwnProperty(O, P)."]
        #[link_name = "\u{1}_Z21JS_HasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_HasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the value of the property `obj[id]`, or undefined if no such property\n exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`.\n\n Most callers don't need the `receiver` argument. Consider using\n JS_GetProperty instead. (But if you're implementing a proxy handler's set()\n method, it's often correct to call this function and pass the receiver\n through.)\n\n Implements: ES6 [[Get]] internal method."]
        #[link_name = "\u{1}_Z23JS_ForwardGetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEENS1_13MutableHandleIS8_EE"]
        pub fn JS_ForwardGetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            receiver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_ForwardGetElementToP9JSContextN2JS6HandleIP8JSObjectEEjS5_NS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ForwardGetElementTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            receiver: root::JS::Handle<*mut root::JSObject>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the value of the property `obj[id]`, or undefined if no such property\n exists. The result is stored in vp.\n\n Implements: ES6 7.3.1 Get(O, P)."]
        #[link_name = "\u{1}_Z18JS_GetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_GetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_GetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_GetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`.\n\n This function has a `receiver` argument that most callers don't need.\n Consider using JS_SetProperty instead.\n\n Implements: ES6 [[Set]] internal method."]
        #[link_name = "\u{1}_Z23JS_ForwardSetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEES9_RNS1_14ObjectOpResultE"]
        pub fn JS_ForwardSetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            v: root::JS::Handle<root::JS::Value>,
            receiver: root::JS::Handle<root::JS::Value>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the assignment `obj[id] = v`.\n\n This function performs non-strict assignment, so if the property is\n read-only, nothing happens and no error is thrown."]
        #[link_name = "\u{1}_Z18JS_SetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEE"]
        pub fn JS_SetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_SetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEE"]
        pub fn JS_SetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_SetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEE"]
        pub fn JS_SetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEE"]
        pub fn JS_SetElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_"]
        pub fn JS_SetElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEE"]
        pub fn JS_SetElement2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<*mut root::JSString>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_SetElement3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: i32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjj"]
        pub fn JS_SetElement4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjd"]
        pub fn JS_SetElement5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: f64,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Delete a property. This is the C++ equivalent of\n `result = Reflect.deleteProperty(obj, id)`.\n\n This function has a `result` out parameter that most callers don't need.\n Unless you can pass through an ObjectOpResult provided by your caller, it's\n probably best to use the JS_DeletePropertyById signature with just 3\n arguments.\n\n Implements: ES6 [[Delete]] internal method."]
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEERNS1_14ObjectOpResultE"]
        pub fn JS_DeletePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DeleteUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEjRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Delete a property, ignoring strict failures. This is the C++ equivalent of\n the JS `delete obj[id]` in non-strict mode code."]
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS1_11PropertyKeyE"]
        pub fn JS_DeletePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::jsid,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKc"]
        pub fn JS_DeleteProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEj"]
        pub fn JS_DeleteElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get an array of the non-symbol enumerable properties of obj.\n This function is roughly equivalent to:\n\n     var result = [];\n     for (key in obj) {\n         result.push(key);\n     }\n     return result;\n\n This is the closest thing we currently have to the ES6 [[Enumerate]]\n internal method.\n\n The array of ids returned by JS_Enumerate must be rooted to protect its\n contents from garbage collection. Use JS::Rooted<JS::IdVector>."]
        #[link_name = "\u{1}_Z12JS_EnumerateP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_8GCVectorINS1_11PropertyKeyELm0EN2js15TempAllocPolicyEEEEE"]
        pub fn JS_Enumerate(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            props: root::JS::MutableHandle<root::JS::IdVector>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Other property-defining functions"]
        #[link_name = "\u{1}_Z15JS_DefineObjectP9JSContextN2JS6HandleIP8JSObjectEEPKcPK7JSClassj"]
        pub fn JS_DefineObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            clasp: *const root::JSClass,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefinePropertiesP9JSContextN2JS6HandleIP8JSObjectEEPK14JSPropertySpec"]
        pub fn JS_DefineProperties(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            ps: *const root::JSPropertySpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_AlreadyHasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_AlreadyHasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_AlreadyHasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_AlreadyHasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_AlreadyHasOwnUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_AlreadyHasOwnUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AlreadyHasOwnElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_AlreadyHasOwnElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_DefineFunctionsP9JSContextN2JS6HandleIP8JSObjectEEPK14JSFunctionSpec"]
        pub fn JS_DefineFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fs: *const root::JSFunctionSpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefineFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineUCFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefineFunctionByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunctionById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    pub type JSIterateCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut root::JS::Compartment,
        ) -> root::JS::CompartmentIterResult,
    >;
    extern "C" {
        #[doc = " This function calls |compartmentCallback| on every compartment until either\n all compartments have been iterated or CompartmentIterResult::Stop is\n returned. Beware that there is no guarantee that the compartment will survive\n after the callback returns. Also, barriers are disabled via the TraceSession."]
        #[link_name = "\u{1}_Z22JS_IterateCompartmentsP9JSContextPvPFN2JS21CompartmentIterResultES0_S1_PNS2_11CompartmentEE"]
        pub fn JS_IterateCompartments(
            cx: *mut root::JSContext,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
    }
    extern "C" {
        #[doc = " This function calls |compartmentCallback| on every compartment in the given\n zone until either all compartments have been iterated or\n CompartmentIterResult::Stop is returned. Beware that there is no guarantee\n that the compartment will survive after the callback returns. Also, barriers\n are disabled via the TraceSession."]
        #[link_name = "\u{1}_Z28JS_IterateCompartmentsInZoneP9JSContextPN2JS4ZoneEPvPFNS1_21CompartmentIterResultES0_S4_PNS1_11CompartmentEE"]
        pub fn JS_IterateCompartmentsInZone(
            cx: *mut root::JSContext,
            zone: *mut root::JS::Zone,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
    }
    #[doc = " Callback used to ask the embedding for the cross compartment wrapper handler\n that implements the desired prolicy for this kind of object in the\n destination compartment. |obj| is the object to be wrapped. If |existing| is\n non-nullptr, it will point to an existing wrapper object that should be\n re-used if possible. |existing| is guaranteed to be a cross-compartment\n wrapper with a lazily-defined prototype and the correct global. It is\n guaranteed not to wrap a function."]
    pub type JSWrapObjectCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::HandleObject,
            arg3: root::JS::HandleObject,
        ) -> *mut root::JSObject,
    >;
    #[doc = " Callback used by the wrap hook to ask the embedding to prepare an object\n for wrapping in a context. This might include unwrapping other wrappers\n or even finding a more suitable object for the new compartment. If |origObj|\n is non-null, then it is the original object we are going to swap into during\n a transplant."]
    pub type JSPreWrapCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::HandleObject,
            arg3: root::JS::HandleObject,
            arg4: root::JS::HandleObject,
            arg5: root::JS::HandleObject,
            arg6: root::JS::MutableHandleObject,
        ),
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSWrapObjectCallbacks {
        pub wrap: root::JSWrapObjectCallback,
        pub preWrap: root::JSPreWrapCallback,
    }
    #[test]
    fn bindgen_test_layout_JSWrapObjectCallbacks() {
        const UNINIT: ::std::mem::MaybeUninit<JSWrapObjectCallbacks> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSWrapObjectCallbacks>(),
            16usize,
            concat!("Size of: ", stringify!(JSWrapObjectCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSWrapObjectCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSWrapObjectCallbacks))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).wrap) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSWrapObjectCallbacks),
                "::",
                stringify!(wrap)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).preWrap) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSWrapObjectCallbacks),
                "::",
                stringify!(preWrap)
            )
        );
    }
    pub type JSDestroyZoneCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::JS::GCContext, arg2: *mut root::JS::Zone),
    >;
    pub type JSDestroyCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::JS::GCContext, arg2: *mut root::JS::Compartment),
    >;
    pub type JSSizeOfIncludingThisCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: root::mozilla::MallocSizeOf,
            arg2: *mut root::JS::Compartment,
        ) -> usize,
    >;
    extern "C" {
        #[link_name = "\u{1}_Z25JS_SetDestroyZoneCallbackP9JSContextPFvPN2JS9GCContextEPNS1_4ZoneEE"]
        pub fn JS_SetDestroyZoneCallback(
            cx: *mut root::JSContext,
            callback: root::JSDestroyZoneCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_SetDestroyCompartmentCallbackP9JSContextPFvPN2JS9GCContextEPNS1_11CompartmentEE"]
        pub fn JS_SetDestroyCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSDestroyCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z44JS_SetSizeOfIncludingThisCompartmentCallbackP9JSContextPFmPFmPKvEPN2JS11CompartmentEE"]
        pub fn JS_SetSizeOfIncludingThisCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSSizeOfIncludingThisCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_SetCompartmentPrivatePN2JS11CompartmentEPv"]
        pub fn JS_SetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetCompartmentPrivatePN2JS11CompartmentE"]
        pub fn JS_GetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetZoneUserDataPN2JS4ZoneEPv"]
        pub fn JS_SetZoneUserData(zone: *mut root::JS::Zone, data: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetZoneUserDataPN2JS4ZoneE"]
        pub fn JS_GetZoneUserData(zone: *mut root::JS::Zone) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_RefreshCrossCompartmentWrappersP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_RefreshCrossCompartmentWrappers(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Mark a jsid after entering a new compartment. Different zones separately\n mark the ids in a runtime, and this must be used any time an id is obtained\n from one compartment and then used in another compartment, unless the two\n compartments are guaranteed to be in the same zone."]
        #[link_name = "\u{1}_Z18JS_MarkCrossZoneIdP9JSContextN2JS11PropertyKeyE"]
        pub fn JS_MarkCrossZoneId(cx: *mut root::JSContext, id: root::jsid);
    }
    extern "C" {
        #[doc = " If value stores a jsid (an atomized string or symbol), mark that id as for\n JS_MarkCrossZoneId."]
        #[link_name = "\u{1}_Z23JS_MarkCrossZoneIdValueP9JSContextRKN2JS5ValueE"]
        pub fn JS_MarkCrossZoneIdValue(cx: *mut root::JSContext, value: *const root::JS::Value);
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_StringHasBeenPinnedP9JSContextP8JSString"]
        pub fn JS_StringHasBeenPinned(cx: *mut root::JSContext, str_: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[doc = " Microseconds since the epoch, midnight, January 1, 1970 UTC."]
        #[link_name = "\u{1}_Z6JS_Nowv"]
        pub fn JS_Now() -> i64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ValueToObjectP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIP8JSObjectEE"]
        pub fn JS_ValueToObject(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            objp: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_ValueToFunctionP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToFunction(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_ValueToConstructorP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToConstructor(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ValueToSourceP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToSource(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DoubleIsInt32dPi"]
        pub fn JS_DoubleIsInt32(d: f64, ip: *mut i32) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_TypeOfValueP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_TypeOfValue(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> root::JSType;
    }
    extern "C" {
        #[doc = " True iff fun is the global eval function."]
        #[link_name = "\u{1}_Z24JS_IsBuiltinEvalFunctionP10JSFunction"]
        pub fn JS_IsBuiltinEvalFunction(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[doc = " True iff fun is the Function constructor."]
        #[link_name = "\u{1}_Z31JS_IsBuiltinFunctionConstructorP10JSFunction"]
        pub fn JS_IsBuiltinFunctionConstructor(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetImplementationVersionv"]
        pub fn JS_GetImplementationVersion() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_SetWrapObjectCallbacksP9JSContextPK21JSWrapObjectCallbacks"]
        pub fn JS_SetWrapObjectCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSWrapObjectCallbacks,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_WrapObjectP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_WrapObject(cx: *mut root::JSContext, objp: root::JS::MutableHandleObject)
            -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_WrapValueP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_WrapValue(cx: *mut root::JSContext, vp: root::JS::MutableHandleValue) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_TransplantObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_TransplantObject(
            cx: *mut root::JSContext,
            origobj: root::JS::HandleObject,
            target: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Resolve id, which must contain either a string or an int, to a standard\n class name in obj if possible, defining the class's constructor and/or\n prototype and storing true in *resolved.  If id does not name a standard\n class or a top-level property induced by initializing a standard class,\n store false in *resolved and just return true.  Return false on error,\n as usual for bool result-typed API entry points.\n\n This API can be called directly from a global object class's resolve op,\n to define standard classes lazily. The class should either have an enumerate\n hook that calls JS_EnumerateStandardClasses, or a newEnumerate hook that\n calls JS_NewEnumerateStandardClasses. newEnumerate is preferred because it's\n faster (does not define all standard classes)."]
        #[link_name = "\u{1}_Z23JS_ResolveStandardClassP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_ResolveStandardClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolved: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_MayResolveStandardClassRK11JSAtomStateN2JS11PropertyKeyEP8JSObject"]
        pub fn JS_MayResolveStandardClass(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_EnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_EnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Fill \"properties\" with a list of standard class names that have not yet been\n resolved on \"obj\".  This can be used as (part of) a newEnumerate class hook\n on a global.  Already-resolved things are excluded because they might have\n been deleted by script after being resolved and enumeration considers\n already-defined properties anyway."]
        #[link_name = "\u{1}_Z30JS_NewEnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Fill \"properties\" with a list of standard class names.  This can be used for\n proxies that want to define behavior that looks like enumerating a global\n without touching the global itself."]
        #[link_name = "\u{1}_Z47JS_NewEnumerateStandardClassesIncludingResolvedP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClassesIncludingResolved(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetClassObjectP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassObject(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetClassPrototypeP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassPrototype(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_IdToProtoKeyP9JSContextN2JS6HandleINS1_11PropertyKeyEEE"]
        pub fn JS_IdToProtoKey(
            cx: *mut root::JSContext,
            id: root::JS::HandleId,
        ) -> root::JSProtoKey;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GlobalLexicalEnvironmentP8JSObject"]
        pub fn JS_GlobalLexicalEnvironment(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_HasExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_HasExtensibleLexicalEnvironment(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31JS_ExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_ExtensibleLexicalEnvironment(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the\n given global."]
        #[link_name = "\u{1}_Z19JS_InitReflectParseP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_InitReflectParse(
            cx: *mut root::JSContext,
            global: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Add various profiling-related functions as properties of the given object.\n Defined in builtin/Profilers.cpp."]
        #[link_name = "\u{1}_Z27JS_DefineProfilingFunctionsP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineProfilingFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_ValueToIdP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_ValueToId(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            idp: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_StringToIdP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_StringToId(
            cx: *mut root::JSContext,
            s: root::JS::HandleString,
            idp: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_IdToValueP9JSContextN2JS11PropertyKeyENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_IdToValue(
            cx: *mut root::JSContext,
            id: root::jsid,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_InitClassP9JSContextN2JS6HandleIP8JSObjectEES5_PK7JSClassPFbS0_jPNS1_5ValueEEjPK14JSPropertySpecPK14JSFunctionSpecSF_SI_"]
        pub fn JS_InitClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            parent_proto: root::JS::HandleObject,
            clasp: *const root::JSClass,
            constructor: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            ps: *const root::JSPropertySpec,
            fs: *const root::JSFunctionSpec,
            static_ps: *const root::JSPropertySpec,
            static_fs: *const root::JSFunctionSpec,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Set up ctor.prototype = proto and proto.constructor = ctor with the\n right property flags."]
        #[link_name = "\u{1}_Z30JS_LinkConstructorAndPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_LinkConstructorAndPrototype(
            cx: *mut root::JSContext,
            ctor: root::JS::Handle<*mut root::JSObject>,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_InstanceOfP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassPNS1_8CallArgsE"]
        pub fn JS_InstanceOf(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            clasp: *const root::JSClass,
            args: *mut root::JS::CallArgs,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_HasInstanceP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEEPb"]
        pub fn JS_HasInstance(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            v: root::JS::Handle<root::JS::Value>,
            bp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetConstructorP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_GetConstructor(
            cx: *mut root::JSContext,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_NewObjectP9JSContextPK7JSClass"]
        pub fn JS_NewObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z11JS_IsNativeP8JSObject"]
        pub fn JS_IsNative(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default\n proto. If proto is nullptr, the JS object will have `null` as [[Prototype]]."]
        #[link_name = "\u{1}_Z26JS_NewObjectWithGivenProtoP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithGivenProto(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Creates a new plain object, like `new Object()`, with Object.prototype as\n [[Prototype]]."]
        #[link_name = "\u{1}_Z17JS_NewPlainObjectP9JSContext"]
        pub fn JS_NewPlainObject(cx: *mut root::JSContext) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Freeze obj, and all objects it refers to, recursively. This will not recurse\n through non-extensible objects, on the assumption that those are already\n deep-frozen."]
        #[link_name = "\u{1}_Z19JS_DeepFreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DeepFreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Freezes an object; see ES5's Object.freeze(obj) method."]
        #[link_name = "\u{1}_Z15JS_FreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the prototype of |obj|, storing it in |proto|.\n\n Implements: ES6 [[GetPrototypeOf]] internal method."]
        #[link_name = "\u{1}_Z15JS_GetPrototypeP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " If |obj| (underneath any functionally-transparent wrapper proxies) has as\n its [[GetPrototypeOf]] trap the ordinary [[GetPrototypeOf]] behavior defined\n for ordinary objects, set |*isOrdinary = true| and store |obj|'s prototype\n in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both\n outparams have unspecified value."]
        #[link_name = "\u{1}_Z25JS_GetPrototypeIfOrdinaryP9JSContextN2JS6HandleIP8JSObjectEEPbNS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototypeIfOrdinary(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isOrdinary: *mut bool,
            result: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Change the prototype of obj.\n\n Implements: ES6 [[SetPrototypeOf]] internal method.\n\n In cases where ES6 [[SetPrototypeOf]] returns false without an exception,\n JS_SetPrototype throws a TypeError and returns false.\n\n Performance warning: JS_SetPrototype is very bad for performance. It may\n cause compiled jit-code to be invalidated. It also causes not only obj but\n all other objects in the same \"group\" as obj to be permanently deoptimized.\n It's better to create the object with the right prototype from the start."]
        #[link_name = "\u{1}_Z15JS_SetPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_SetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether obj is extensible. Extensible objects can have new\n properties defined on them. Inextensible objects can't, and their\n [[Prototype]] slot is fixed as well.\n\n Implements: ES6 [[IsExtensible]] internal method."]
        #[link_name = "\u{1}_Z15JS_IsExtensibleP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_IsExtensible(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            extensible: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Attempt to make |obj| non-extensible.\n\n Not all failures are treated as errors. See the comment on\n JS::ObjectOpResult in js/public/Class.h.\n\n Implements: ES6 [[PreventExtensions]] internal method."]
        #[link_name = "\u{1}_Z20JS_PreventExtensionsP9JSContextN2JS6HandleIP8JSObjectEERNS1_14ObjectOpResultE"]
        pub fn JS_PreventExtensions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt\n to modify it will fail.  If an error occurs during the attempt, return false\n (with a pending exception set, depending upon the nature of the error).  If\n no error occurs, return true with |*succeeded| set to indicate whether the\n attempt successfully made the [[Prototype]] immutable.\n\n This is a nonstandard internal method."]
        #[link_name = "\u{1}_Z24JS_SetImmutablePrototypeP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_SetImmutablePrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            succeeded: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Equivalent to `Object.assign(target, src)`: Copies the properties from the\n `src` object (which must not be null) to `target` (which also must not be\n null)."]
        #[link_name = "\u{1}_Z15JS_AssignObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_AssignObject(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Assign 'undefined' to all of the object's non-reserved slots. Note: this is\n done for all slots, regardless of the associated property descriptor."]
        #[link_name = "\u{1}_Z36JS_SetAllNonReservedSlotsToUndefinedN2JS6HandleIP8JSObjectEE"]
        pub fn JS_SetAllNonReservedSlotsToUndefined(obj: root::JS::HandleObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetReservedSlotP8JSObjectjRKN2JS5ValueE"]
        pub fn JS_SetReservedSlot(obj: *mut root::JSObject, index: u32, v: *const root::JS::Value);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_InitReservedSlotP8JSObjectjPvmN2JS9MemoryUseE"]
        pub fn JS_InitReservedSlot(
            obj: *mut root::JSObject,
            index: u32,
            ptr: *mut ::std::os::raw::c_void,
            nbytes: usize,
            use_: root::JS::MemoryUse,
        );
    }
    pub const JSFUN_CONSTRUCTOR: ::std::os::raw::c_uint = 1024;
    pub const JSFUN_FLAGS_MASK: ::std::os::raw::c_uint = 1024;
    extern "C" {
        #[link_name = "\u{1}_Z14JS_NewFunctionP9JSContextPFbS0_jPN2JS5ValueEEjjPKc"]
        pub fn JS_NewFunction(
            cx: *mut root::JSContext,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
            name: *const ::std::os::raw::c_char,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionObjectP10JSFunction"]
        pub fn JS_GetFunctionObject(fun: *mut root::JSFunction) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Return the function's identifier as a JSString, or null if fun is unnamed.\n The returned string lives as long as fun, so you don't need to root a saved\n reference to it if fun is well-connected or rooted, and provided you bound\n the use of the saved reference by fun's lifetime."]
        #[link_name = "\u{1}_Z16JS_GetFunctionIdP10JSFunction"]
        pub fn JS_GetFunctionId(fun: *mut root::JSFunction) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Return a function's display name. This is the defined name if one was given\n where the function was defined, or it could be an inferred name by the JS\n engine in the case that the function was defined to be anonymous. This can\n still return nullptr if a useful display name could not be inferred. The\n same restrictions on rooting as those in JS_GetFunctionId apply."]
        #[link_name = "\u{1}_Z23JS_GetFunctionDisplayIdP10JSFunction"]
        pub fn JS_GetFunctionDisplayId(fun: *mut root::JSFunction) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetFunctionArityP10JSFunction"]
        pub fn JS_GetFunctionArity(fun: *mut root::JSFunction) -> u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionLengthP9JSContextN2JS6HandleIP10JSFunctionEEPt"]
        pub fn JS_GetFunctionLength(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
            length: *mut u16,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Infallible predicate to test whether obj is a function object (faster than\n comparing obj's class name to \"Function\", but equivalent unless someone has\n overwritten the \"Function\" identifier with a different constructor and then\n created instances using that constructor that might be passed in as obj)."]
        #[link_name = "\u{1}_Z19JS_ObjectIsFunctionP8JSObject"]
        pub fn JS_ObjectIsFunction(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_IsNativeFunctionP8JSObjectPFbP9JSContextjPN2JS5ValueEE"]
        pub fn JS_IsNativeFunction(funobj: *mut root::JSObject, call: root::JSNative) -> bool;
    }
    extern "C" {
        #[doc = " Return whether the given function is a valid constructor."]
        #[link_name = "\u{1}_Z16JS_IsConstructorP10JSFunction"]
        pub fn JS_IsConstructor(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_IsFunctionBoundP10JSFunction"]
        pub fn JS_IsFunctionBound(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetBoundFunctionTargetP10JSFunction"]
        pub fn JS_GetBoundFunctionTarget(fun: *mut root::JSFunction) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetGlobalFromScriptP8JSScript"]
        pub fn JS_GetGlobalFromScript(script: *mut root::JSScript) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetScriptFilenameP8JSScript"]
        pub fn JS_GetScriptFilename(script: *mut root::JSScript) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetScriptBaseLineNumberP9JSContextP8JSScript"]
        pub fn JS_GetScriptBaseLineNumber(
            cx: *mut root::JSContext,
            script: *mut root::JSScript,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionScriptP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_GetFunctionScript(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
        ) -> *mut root::JSScript;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_DecompileScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_DecompileScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_DecompileFunctionP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_DecompileFunction(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " A JS context always has an \"owner thread\". The owner thread is set when the\n context is created (to the current thread) and practically all entry points\n into the JS engine check that a context (or anything contained in the\n context: runtime, compartment, object, etc) is only touched by its owner\n thread. Embeddings may check this invariant outside the JS engine by calling\n JS_AbortIfWrongThread (which will abort if not on the owner thread, even for\n non-debug builds)."]
        #[link_name = "\u{1}_Z21JS_AbortIfWrongThreadP9JSContext"]
        pub fn JS_AbortIfWrongThread(cx: *mut root::JSContext);
    }
    extern "C" {
        #[doc = " A constructor can request that the JS engine create a default new 'this'\n object of the given class, using the callee to determine parentage and\n [[Prototype]]."]
        #[link_name = "\u{1}_Z26JS_NewObjectForConstructorP9JSContextPK7JSClassRKN2JS8CallArgsE"]
        pub fn JS_NewObjectForConstructor(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            args: *const root::JS::CallArgs,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_SetParallelParsingEnabledP9JSContextb"]
        pub fn JS_SetParallelParsingEnabled(cx: *mut root::JSContext, enabled: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z36JS_SetOffthreadIonCompilationEnabledP9JSContextb"]
        pub fn JS_SetOffthreadIonCompilationEnabled(cx: *mut root::JSContext, enabled: bool);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitCompilerOption {
        JSJITCOMPILER_BASELINE_INTERPRETER_WARMUP_TRIGGER = 0,
        JSJITCOMPILER_BASELINE_WARMUP_TRIGGER = 1,
        JSJITCOMPILER_IC_FORCE_MEGAMORPHIC = 2,
        JSJITCOMPILER_ION_NORMAL_WARMUP_TRIGGER = 3,
        JSJITCOMPILER_ION_GVN_ENABLE = 4,
        JSJITCOMPILER_ION_FORCE_IC = 5,
        JSJITCOMPILER_ION_ENABLE = 6,
        JSJITCOMPILER_JIT_TRUSTEDPRINCIPALS_ENABLE = 7,
        JSJITCOMPILER_ION_CHECK_RANGE_ANALYSIS = 8,
        JSJITCOMPILER_ION_FREQUENT_BAILOUT_THRESHOLD = 9,
        JSJITCOMPILER_BASE_REG_FOR_LOCALS = 10,
        JSJITCOMPILER_INLINING_BYTECODE_MAX_LENGTH = 11,
        JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE = 12,
        JSJITCOMPILER_BASELINE_ENABLE = 13,
        JSJITCOMPILER_OFFTHREAD_COMPILATION_ENABLE = 14,
        JSJITCOMPILER_FULL_DEBUG_CHECKS = 15,
        JSJITCOMPILER_JUMP_THRESHOLD = 16,
        JSJITCOMPILER_NATIVE_REGEXP_ENABLE = 17,
        JSJITCOMPILER_SIMULATOR_ALWAYS_INTERRUPT = 18,
        JSJITCOMPILER_SPECTRE_INDEX_MASKING = 19,
        JSJITCOMPILER_SPECTRE_OBJECT_MITIGATIONS = 20,
        JSJITCOMPILER_SPECTRE_STRING_MITIGATIONS = 21,
        JSJITCOMPILER_SPECTRE_VALUE_MASKING = 22,
        JSJITCOMPILER_SPECTRE_JIT_TO_CXX_CALLS = 23,
        JSJITCOMPILER_WATCHTOWER_MEGAMORPHIC = 24,
        JSJITCOMPILER_WASM_FOLD_OFFSETS = 25,
        JSJITCOMPILER_WASM_DELAY_TIER2 = 26,
        JSJITCOMPILER_WASM_JIT_BASELINE = 27,
        JSJITCOMPILER_WASM_JIT_OPTIMIZING = 28,
        JSJITCOMPILER_NOT_AN_OPTION = 29,
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_SetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionj"]
        pub fn JS_SetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            value: u32,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionPj"]
        pub fn JS_GetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            valueOut: *mut u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Convert a uint32_t index into a jsid."]
        #[link_name = "\u{1}_Z12JS_IndexToIdP9JSContextjN2JS13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_IndexToId(
            cx: *mut root::JSContext,
            index: u32,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Convert chars into a jsid.\n\n |chars| may not be an index."]
        #[link_name = "\u{1}_Z12JS_CharsToIdP9JSContextN2JS12TwoByteCharsENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_CharsToId(
            cx: *mut root::JSContext,
            chars: root::JS::TwoByteChars,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[doc = "  Test if the given string is a valid ECMAScript identifier"]
        #[link_name = "\u{1}_Z15JS_IsIdentifierP9JSContextN2JS6HandleIP8JSStringEEPb"]
        pub fn JS_IsIdentifier(
            cx: *mut root::JSContext,
            str_: root::JS::HandleString,
            isIdentifier: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Test whether the given chars + length are a valid ECMAScript identifier.\n This version is infallible, so just returns whether the chars are an\n identifier."]
        #[link_name = "\u{1}_Z15JS_IsIdentifierPKDsm"]
        pub fn JS_IsIdentifier1(chars: *const u16, length: usize) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetGrayGCRootsTracerP9JSContextPFbP8JSTracerRN2js11SliceBudgetEPvES6_"]
        pub fn JS_SetGrayGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSGrayRootsTracer,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_FindCompilationScopeP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FindCompilationScope(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetObjectFunctionP8JSObject"]
        pub fn JS_GetObjectFunction(obj: *mut root::JSObject) -> *mut root::JSFunction;
    }
    extern "C" {
        #[doc = " Allocate an object in exactly the same way as JS_NewObjectWithGivenProto, but\n without invoking the metadata callback on it.  This allows creation of\n internal bookkeeping objects that are guaranteed to not have metadata\n attached to them."]
        #[link_name = "\u{1}_Z27JS_NewObjectWithoutMetadataP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithoutMetadata(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakMapKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakMapKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakSetKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakSetKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether the given object is backed by a DeadObjectProxy.\n\n Such objects hold no other objects (they have no outgoing reference edges)\n and will throw if you touch them (e.g. by reading/writing a property)."]
        #[link_name = "\u{1}_Z16JS_IsDeadWrapperP8JSObject"]
        pub fn JS_IsDeadWrapper(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Creates a new dead wrapper object in the given scope. To be used when\n attempting to wrap objects from scopes which are already dead.\n\n If origObject is passed, it must be an proxy object, and will be\n used to determine the characteristics of the new dead wrapper."]
        #[link_name = "\u{1}_Z17JS_NewDeadWrapperP9JSContextP8JSObject"]
        pub fn JS_NewDeadWrapper(
            cx: *mut root::JSContext,
            origObject: *mut root::JSObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z35JS_TraceShapeCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceShapeCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            shape: root::JS::GCCellPtr,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z41JS_TraceObjectGroupCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceObjectGroupCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            group: root::JS::GCCellPtr,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetScriptPrincipalsP8JSScript"]
        pub fn JS_GetScriptPrincipals(script: *mut root::JSScript) -> *mut root::JSPrincipals;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_ScriptHasMutedErrorsP8JSScript"]
        pub fn JS_ScriptHasMutedErrors(script: *mut root::JSScript) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_CloneObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CloneObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Copy the own properties of src to dst in a fast way.  src and dst must both\n be native and must be in the compartment of cx.  They must have the same\n class, the same parent, and the same prototype.  Class reserved slots will\n NOT be copied.\n\n dst must not have any properties on it before this function is called.\n\n src must have been allocated via JS_NewObjectWithoutMetadata so that we can\n be sure it has no metadata that needs copying to dst.  This also means that\n dst needs to have the compartment global as its parent.  This function will\n preserve the existing metadata on dst, if any."]
        #[link_name = "\u{1}_Z49JS_InitializePropertiesFromCompatibleNativeObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_InitializePropertiesFromCompatibleNativeObject(
            cx: *mut root::JSContext,
            dst: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Copies all own properties and private fields from |obj| to |target|. Both\n |obj| and |target| must not be cross-compartment wrappers because we have to\n enter their realms.\n\n This function immediately enters a realm, and does not impose any\n restrictions on the realm of |cx|."]
        #[link_name = "\u{1}_Z36JS_CopyOwnPropertiesAndPrivateFieldsP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CopyOwnPropertiesAndPrivateFields(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_WrapPropertyDescriptor(
            cx: *mut root::JSContext,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEE"]
        pub fn JS_WrapPropertyDescriptor1(cx: *mut root::JSContext, desc: u8) -> bool;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunctionSpecWithHelp {
        pub name: *const ::std::os::raw::c_char,
        pub call: root::JSNative,
        pub nargs: u16,
        pub flags: u16,
        pub jitInfo: *const root::JSJitInfo,
        pub usage: *const ::std::os::raw::c_char,
        pub help: *const ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_JSFunctionSpecWithHelp() {
        const UNINIT: ::std::mem::MaybeUninit<JSFunctionSpecWithHelp> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSFunctionSpecWithHelp>(),
            48usize,
            concat!("Size of: ", stringify!(JSFunctionSpecWithHelp))
        );
        assert_eq!(
            ::std::mem::align_of::<JSFunctionSpecWithHelp>(),
            8usize,
            concat!("Alignment of ", stringify!(JSFunctionSpecWithHelp))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).call) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(call)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).nargs) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(nargs)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).jitInfo) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(jitInfo)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).help) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(help)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_DefineFunctionsWithHelpP9JSContextN2JS6HandleIP8JSObjectEEPK22JSFunctionSpecWithHelp"]
        pub fn JS_DefineFunctionsWithHelp(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            fs: *const root::JSFunctionSpecWithHelp,
        ) -> bool;
    }
    pub mod glue {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[link_name = "\u{1}_ZN4glue7JS_InitEv"]
            pub fn JS_Init() -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18JS_NewRealmOptionsEv"]
            pub fn JS_NewRealmOptions() -> *mut root::JS::RealmOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18DeleteRealmOptionsEPN2JS12RealmOptionsE"]
            pub fn DeleteRealmOptions(options: *mut root::JS::RealmOptions);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26JS_NewOwningCompileOptionsEP9JSContext"]
            pub fn JS_NewOwningCompileOptions(
                cx: *mut root::JSContext,
            ) -> *mut root::JS::OwningCompileOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26DeleteOwningCompileOptionsEPN2JS20OwningCompileOptionsE"]
            pub fn DeleteOwningCompileOptions(optiosn: *mut root::JS::OwningCompileOptions);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_AsShadowZoneEPN2JS4ZoneE"]
            pub fn JS_AsShadowZone(zone: *mut root::JS::Zone) -> *mut root::JS::shadow::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_CallArgsFromVpEjPN2JS5ValueE"]
            pub fn JS_CallArgsFromVp(
                argc: ::std::os::raw::c_uint,
                vp: *mut root::JS::Value,
            ) -> root::JS::CallArgs;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue25JS_StackCapture_AllFramesEPN7mozilla7VariantIJN2JS9AllFramesENS2_9MaxFramesENS2_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_AllFrames(arg1: *mut root::JS::StackCapture);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue25JS_StackCapture_MaxFramesEjPN7mozilla7VariantIJN2JS9AllFramesENS2_9MaxFramesENS2_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_MaxFrames(max: u32, arg1: *mut root::JS::StackCapture);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue34JS_StackCapture_FirstSubsumedFrameEP9JSContextbPN7mozilla7VariantIJN2JS9AllFramesENS4_9MaxFramesENS4_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_FirstSubsumedFrame(
                cx: *mut root::JSContext,
                ignoreSelfHostedFrames: bool,
                arg1: *mut root::JS::StackCapture,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue20JS_ForOfIteratorInitEPN2JS13ForOfIteratorENS0_6HandleINS0_5ValueEEENS1_19NonIterableBehaviorE"]
            pub fn JS_ForOfIteratorInit(
                iterator: *mut root::JS::ForOfIterator,
                iterable: root::JS::HandleValue,
                nonIterableBehavior: root::JS::ForOfIterator_NonIterableBehavior,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue20JS_ForOfIteratorNextEPN2JS13ForOfIteratorENS0_13MutableHandleINS0_5ValueEEEPb"]
            pub fn JS_ForOfIteratorNext(
                iterator: *mut root::JS::ForOfIterator,
                val: root::JS::MutableHandleValue,
                done: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18JS_ValueSetBooleanEPN2JS5ValueEb"]
            pub fn JS_ValueSetBoolean(value: *mut root::JS::Value, x: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueIsBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueIsBoolean(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueToBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueToBoolean(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueSetDoubleEPN2JS5ValueEd"]
            pub fn JS_ValueSetDouble(value: *mut root::JS::Value, x: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueIsDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueIsDouble(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueToDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueToDouble(value: *const root::JS::Value) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueSetInt32EPN2JS5ValueEi"]
            pub fn JS_ValueSetInt32(value: *mut root::JS::Value, x: i32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueIsInt32EPKN2JS5ValueE"]
            pub fn JS_ValueIsInt32(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueToInt32EPKN2JS5ValueE"]
            pub fn JS_ValueToInt32(value: *const root::JS::Value) -> i32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueIsNumberEPKN2JS5ValueE"]
            pub fn JS_ValueIsNumber(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueToNumberEPKN2JS5ValueE"]
            pub fn JS_ValueToNumber(value: *const root::JS::Value) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueSetNullEPN2JS5ValueE"]
            pub fn JS_ValueSetNull(value: *mut root::JS::Value);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue14JS_ValueIsNullEPKN2JS5ValueE"]
            pub fn JS_ValueIsNull(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue19JS_ValueIsUndefinedEPKN2JS5ValueE"]
            pub fn JS_ValueIsUndefined(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue21GetLinearStringLengthEP14JSLinearString"]
            pub fn GetLinearStringLength(s: *mut root::JSLinearString) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue21GetLinearStringCharAtEP14JSLinearStringm"]
            pub fn GetLinearStringCharAt(s: *mut root::JSLinearString, idx: usize) -> u16;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18AtomToLinearStringEP6JSAtom"]
            pub fn AtomToLinearString(atom: *mut root::JSAtom) -> *mut root::JSLinearString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue22FromPropertyDescriptorEP9JSContextN2JS6HandleINS2_18PropertyDescriptorEEENS2_13MutableHandleINS2_5ValueEEE"]
            pub fn FromPropertyDescriptor(
                cx: *mut root::JSContext,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                vp: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue31JS_GetOwnPropertyDescriptorByIdEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS2_13MutableHandleINS2_18PropertyDescriptorEEEPb"]
            pub fn JS_GetOwnPropertyDescriptorById(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue27JS_GetOwnPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_13MutableHandleINS2_18PropertyDescriptorEEEPb"]
            pub fn JS_GetOwnPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                name: *const ::std::os::raw::c_char,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue29JS_GetOwnUCPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_13MutableHandleINS2_18PropertyDescriptorEEEPb"]
            pub fn JS_GetOwnUCPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                name: *const u16,
                namelen: usize,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue28JS_GetPropertyDescriptorByIdEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS2_13MutableHandleINS2_18PropertyDescriptorEEENS9_IS5_EEPb"]
            pub fn JS_GetPropertyDescriptorById(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                holder: root::JS::MutableHandleObject,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue24JS_GetPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_13MutableHandleINS2_18PropertyDescriptorEEENS9_IS5_EEPb"]
            pub fn JS_GetPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                name: *const ::std::os::raw::c_char,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                holder: root::JS::MutableHandleObject,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26JS_GetUCPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_13MutableHandleINS2_18PropertyDescriptorEEENS9_IS5_EEPb"]
            pub fn JS_GetUCPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                name: *const u16,
                namelen: usize,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                holder: root::JS::MutableHandleObject,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue30SetPropertyIgnoringNamedGetterEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS3_INS2_5ValueEEESA_NS3_INS2_18PropertyDescriptorEEERNS2_14ObjectOpResultE"]
            pub fn SetPropertyIgnoringNamedGetter(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                ownDesc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue11CreateErrorEP9JSContext9JSExnTypeN2JS6HandleIP8JSObjectEENS4_IP8JSStringEEjjP13JSErrorReportSA_NS4_INS3_5ValueEEENS3_13MutableHandleISD_EE"]
            pub fn CreateError(
                cx: *mut root::JSContext,
                type_: root::JSExnType,
                stack: root::JS::HandleObject,
                fileName: root::JS::HandleString,
                lineNumber: u32,
                columnNumber: u32,
                report: *mut root::JSErrorReport,
                message: root::JS::HandleString,
                cause: root::JS::HandleValue,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue12GetErrorTypeERKN2JS5ValueE"]
            pub fn GetErrorType(val: *const root::JS::Value) -> root::JSExnType;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17GetExceptionCauseEP8JSObject"]
            pub fn GetExceptionCause(exc: *mut root::JSObject) -> root::JS::Value;
        }
    }
    #[doc = " <div rustbindgen replaces=\"JSJitMethodCallArgs\"></div>"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitMethodCallArgs {
        pub argv_: *mut root::JS::Value,
        pub argc_: ::std::os::raw::c_uint,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_JSJitMethodCallArgs() {
        const UNINIT: ::std::mem::MaybeUninit<JSJitMethodCallArgs> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSJitMethodCallArgs>(),
            16usize,
            concat!("Size of: ", stringify!(JSJitMethodCallArgs))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitMethodCallArgs>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitMethodCallArgs))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).argv_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitMethodCallArgs),
                "::",
                stringify!(argv_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).argc_) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitMethodCallArgs),
                "::",
                stringify!(argc_)
            )
        );
    }
    impl JSJitMethodCallArgs {
        #[inline]
        pub fn constructing_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_constructing_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ignoresReturnValue_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ignoresReturnValue_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            constructing_: bool,
            ignoresReturnValue_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let constructing_: u8 = unsafe { ::std::mem::transmute(constructing_) };
                constructing_ as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let ignoresReturnValue_: u8 = unsafe { ::std::mem::transmute(ignoresReturnValue_) };
                ignoresReturnValue_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub type __builtin_va_list = [root::__va_list_tag; 1usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout___va_list_tag() {
        const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<__va_list_tag>(),
            24usize,
            concat!("Size of: ", stringify!(__va_list_tag))
        );
        assert_eq!(
            ::std::mem::align_of::<__va_list_tag>(),
            8usize,
            concat!("Alignment of ", stringify!(__va_list_tag))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSFunction_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_PropertyKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::PropertyKey>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::PropertyKey>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSFunction_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_PropertyKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::PropertyKey>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::PropertyKey>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_StackGCVector_open1_PropertyKey_TempAllocPolicy_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<u64>(),
            8usize,
            concat!("Size of template specialization: ", stringify!(u64))
        );
        assert_eq!(
            ::std::mem::align_of::<u64>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(u64))
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_numeric_limits_open0_int64_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::numeric_limits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::numeric_limits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::numeric_limits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::numeric_limits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_numeric_limits_open0_uint64_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::numeric_limits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::numeric_limits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::numeric_limits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::numeric_limits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_73 {
        pub _address: u8,
    }
    #[test]
    fn __bindgen_test_layout_GenericTracerImpl_open0_CallbackTracer_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::js::GenericTracerImpl>(),
            48usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::js::GenericTracerImpl)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::js::GenericTracerImpl>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::js::GenericTracerImpl)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Opaque_open0_uint64_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Opaque<u64>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Opaque<u64>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Opaque<u64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Opaque<u64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_TenuredHeap_open0_ptr_JSObject_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::TenuredHeap>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::TenuredHeap)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::TenuredHeap>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::TenuredHeap)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_LinkedListElement_open0_PersistentRootedBase_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::LinkedListElement>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::LinkedListElement)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::LinkedListElement>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::LinkedListElement)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_74 {
        pub _address: u8,
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JobQueue_SavedJobQueue_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JobQueue_SavedJobQueue_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_EnumSet_open0_PropertyAttribute_unsigned_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::EnumSet<::std::os::raw::c_uchar>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::EnumSet<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::EnumSet<::std::os::raw::c_uchar>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::EnumSet<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_34() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_35() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_36() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_37() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_38() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_39() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_40() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_41() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_42() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_43() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_44() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_45() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_46() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_47() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_48() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_49() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_50() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_51() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_52() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_53() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_54() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_55() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_56() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_57() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_58() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_59() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_Latin1Char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_Latin1Char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_unsigned_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_unsigned_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_unsigned_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_unsigned_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_char16_t_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_char16_t_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_const_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_char16_t_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_60() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_61() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct IterImpl {
        pub mSegment: usize,
        pub mData: *mut ::std::os::raw::c_char,
        pub mDataEnd: *mut ::std::os::raw::c_char,
        pub mAbsoluteOffset: usize,
    }
    #[test]
    fn bindgen_test_layout_IterImpl() {
        const UNINIT: ::std::mem::MaybeUninit<IterImpl> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<IterImpl>(),
            32usize,
            concat!("Size of: ", stringify!(IterImpl))
        );
        assert_eq!(
            ::std::mem::align_of::<IterImpl>(),
            8usize,
            concat!("Alignment of ", stringify!(IterImpl))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mSegment) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(IterImpl),
                "::",
                stringify!(mSegment)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mData) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(IterImpl),
                "::",
                stringify!(mData)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mDataEnd) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(IterImpl),
                "::",
                stringify!(mDataEnd)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mAbsoluteOffset) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(IterImpl),
                "::",
                stringify!(mAbsoluteOffset)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_AtomicRefCounted_open0_WasmModule_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::js::AtomicRefCounted>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::js::AtomicRefCounted)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::js::AtomicRefCounted>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::js::AtomicRefCounted)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_uint8_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u8>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u8>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_62() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_63() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_64() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_65() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_66() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_67() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_68() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_69() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_70() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_71() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_72() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_73() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_74() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_75() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_76() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_77() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_78() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_79() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_80() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_81() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_82() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_83() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_84() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_85() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_86() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_87() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_88() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_89() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_90() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_PropertyKey_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::PropertyKey>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::PropertyKey>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_91() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_92() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_BaseTimeDuration_open0_TimeDurationValueCalculator_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::BaseTimeDuration>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::BaseTimeDuration)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::BaseTimeDuration>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::BaseTimeDuration)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_93() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_94() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSFunction_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_95() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_96() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSFunction_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_97() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_98() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_99() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_100() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_101() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_102() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_103() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_104() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_105() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_106() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_107() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_108() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_109() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_110() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_111() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_112() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_113() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_114() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_115() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_116() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_117() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_118() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_119() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_120() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_121() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_122() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_123() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_124() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_125() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_126() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_127() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_128() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_129() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_130() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_131() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_132() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_133() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_134() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_135() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_136() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_137() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_138() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_139() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_140() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_141() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_142() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_143() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_144() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_145() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_146() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_147() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_148() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_149() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_150() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_151() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_152() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_153() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_154() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_155() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_156() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_157() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_158() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_159() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_160() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_34() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_35() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_161() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_36() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_162() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_37() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_163() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_38() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_164() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_39() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_165() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_166() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_167() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_168() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_169() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_170() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_171() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_172() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_173() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_174() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_175() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_176() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_177() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_178() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_179() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_180() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_181() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_182() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_183() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_184() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_185() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_186() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_187() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_188() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_189() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_40() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_41() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_190() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_191() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_192() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_193() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_42() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_194() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_195() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_196() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_197() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSFunction_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_198() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
}
