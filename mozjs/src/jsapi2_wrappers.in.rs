wrap!(jsapi: pub fn ReportOutOfMemory(cx: &JSContext));
wrap!(jsapi: pub fn ReportLargeOutOfMemory(cx: &JSContext));
wrap!(jsapi: pub fn SetContextProfilingStack(cx: &JSContext, profilingStack: *mut ProfilingStack));
wrap!(jsapi: pub fn EnableContextProfilingStack(cx: &JSContext, enabled: bool));
wrap!(jsapi: pub fn RegisterContextProfilingEventMarker(cx: &JSContext, mark: ::std::option::Option<unsafe extern "C" fn(arg1: MarkerCategory, arg2: *const ::std::os::raw::c_char, arg3: *const ::std::os::raw::c_char)>, interval: ::std::option::Option<unsafe extern "C" fn(arg1: MarkerCategory, arg2: *const ::std::os::raw::c_char, arg3: TimeStamp, arg4: *const ::std::os::raw::c_char)>));
wrap!(jsapi: pub fn SetStackFormat(cx: &JSContext, format: StackFormat));
wrap!(jsapi: pub fn GetStackFormat(cx: &JSContext) -> StackFormat);
wrap!(jsapi: pub fn ToBooleanSlow(v: HandleValue) -> bool);
wrap!(jsapi: pub fn ToNumberSlow(cx: &mut JSContext, v: HandleValue, dp: *mut f64) -> bool);
wrap!(jsapi: pub fn ToInt8Slow(cx: &mut JSContext, v: HandleValue, out: *mut i8) -> bool);
wrap!(jsapi: pub fn ToUint8Slow(cx: &mut JSContext, v: HandleValue, out: *mut u8) -> bool);
wrap!(jsapi: pub fn ToInt16Slow(cx: &mut JSContext, v: HandleValue, out: *mut i16) -> bool);
wrap!(jsapi: pub fn ToInt32Slow(cx: &mut JSContext, v: HandleValue, out: *mut i32) -> bool);
wrap!(jsapi: pub fn ToUint32Slow(cx: &mut JSContext, v: HandleValue, out: *mut u32) -> bool);
wrap!(jsapi: pub fn ToUint16Slow(cx: &mut JSContext, v: HandleValue, out: *mut u16) -> bool);
wrap!(jsapi: pub fn ToInt64Slow(cx: &mut JSContext, v: HandleValue, out: *mut i64) -> bool);
wrap!(jsapi: pub fn ToUint64Slow(cx: &mut JSContext, v: HandleValue, out: *mut u64) -> bool);
wrap!(jsapi: pub fn ToStringSlow(cx: &mut JSContext, v: HandleValue) -> *mut JSString);
wrap!(jsapi: pub fn ToObjectSlow(cx: &mut JSContext, v: HandleValue, reportScanStack: bool) -> *mut JSObject);
wrap!(jsapi: pub fn NukeNonCCWProxy(cx: &mut JSContext, proxy: HandleObject));
wrap!(jsapi: pub fn NukeRemovedCrossCompartmentWrapper(cx: &JSContext, wrapper: *mut JSObject));
wrap!(jsapi: pub fn GetFirstSubsumedSavedFrame(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, selfHosted: SavedFrameSelfHosted) -> *mut JSObject);
wrap!(jsapi: pub fn TransparentObjectWrapper(cx: &mut JSContext, existing: HandleObject, obj: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn CheckedUnwrapDynamic(obj: *mut JSObject, cx: &mut JSContext, stopAtWindowProxy: bool) -> *mut JSObject);
wrap!(jsapi: pub fn UnwrapOneCheckedDynamic(obj: HandleObject, cx: &mut JSContext, stopAtWindowProxy: bool) -> *mut JSObject);
wrap!(jsapi: pub fn ReportAccessDenied(cx: &mut JSContext));
wrap!(jsapi: pub fn NukeCrossCompartmentWrapper(cx: &JSContext, wrapper: *mut JSObject));
wrap!(jsapi: pub fn NukeCrossCompartmentWrapperIfExists(cx: &JSContext, source: *mut Compartment, target: *mut JSObject));
wrap!(jsapi: pub fn RemapWrapper(cx: &mut JSContext, wobj: *mut JSObject, newTarget: *mut JSObject));
wrap!(jsapi: pub fn RemapDeadWrapper(cx: &mut JSContext, wobj: HandleObject, newTarget: HandleObject));
wrap!(jsapi: pub fn RemapAllWrappersForObject(cx: &mut JSContext, oldTarget: HandleObject, newTarget: HandleObject) -> bool);
wrap!(jsapi: pub fn RecomputeWrappers(cx: &mut JSContext, sourceFilter: *const CompartmentFilter, targetFilter: *const CompartmentFilter) -> bool);
wrap!(jsapi: pub fn SetWindowProxyClass(cx: &JSContext, clasp: *const JSClass));
wrap!(jsapi: pub fn SetWindowProxy(cx: &JSContext, global: Handle<*mut JSObject>, windowProxy: Handle<*mut JSObject>));
wrap!(jsapi: pub fn IsArgumentsObject(obj: HandleObject) -> bool);
wrap!(jsapi: pub fn AddRawValueRoot(cx: &JSContext, vp: *mut Value, name: *const ::std::os::raw::c_char) -> bool);
wrap!(jsapi: pub fn RemoveRawValueRoot(cx: &JSContext, vp: *mut Value));
wrap!(jsapi: pub fn UseInternalJobQueues(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn EnqueueJob(cx: &mut JSContext, job: HandleObject) -> bool);
wrap!(jsapi: pub fn StopDrainingJobQueue(cx: &JSContext));
wrap!(jsapi: pub fn RestartDrainingJobQueue(cx: &JSContext));
wrap!(jsapi: pub fn RunJobs(cx: &mut JSContext));
wrap!(jsapi: pub fn ShouldIgnorePropertyDefinition(cx: &JSContext, key: JSProtoKey, id: jsid) -> bool);
wrap!(jsapi: pub fn AssertSameCompartment(cx: &JSContext, obj: *mut JSObject));
wrap!(jsapi: pub fn AssertSameCompartment1(cx: &JSContext, v: HandleValue));
wrap!(jsapi: pub fn DefineFunctionWithReserved(cx: &mut JSContext, obj: *mut JSObject, name: *const ::std::os::raw::c_char, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn NewFunctionWithReserved(cx: &mut JSContext, call: JSNative, nargs: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, name: *const ::std::os::raw::c_char) -> *mut JSFunction);
wrap!(jsapi: pub fn NewFunctionByIdWithReserved(cx: &JSContext, native: JSNative, nargs: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, id: jsid) -> *mut JSFunction);
wrap!(jsapi: pub fn NewFunctionByIdWithReservedAndProto(cx: &JSContext, native: JSNative, proto: Handle<*mut JSObject>, nargs: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, id: jsid) -> *mut JSFunction);
wrap!(jsapi: pub fn GetObjectProto(cx: &mut JSContext, obj: HandleObject, proto: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn GetRealmOriginalEval(cx: &JSContext, eval: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn GetPropertyKeys(cx: &mut JSContext, obj: HandleObject, flags: ::std::os::raw::c_uint, props: MutableHandleIdVector) -> bool);
wrap!(jsapi: pub fn SetPreserveWrapperCallbacks(cx: &JSContext, preserveWrapper: PreserveWrapperCallback, hasReleasedWrapper: HasReleasedWrapperCallback));
wrap!(jsapi: pub fn IsObjectInContextCompartment(obj: *mut JSObject, cx: &JSContext) -> bool);
wrap!(jsapi: pub fn SetDOMCallbacks(cx: &JSContext, callbacks: *const DOMCallbacks));
wrap!(jsapi: pub fn GetDOMCallbacks(cx: &JSContext) -> *const DOMCallbacks);
wrap!(jsapi: pub fn GetTestingFunctions(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetErrorTypeName(cx: &JSContext, exnType: i16) -> *mut JSLinearString);
wrap!(jsapi: pub fn NukeCrossCompartmentWrappers(cx: &JSContext, sourceFilter: *const CompartmentFilter, target: *mut Realm, nukeReferencesToWindow: NukeReferencesToWindow, nukeReferencesFromTarget: NukeReferencesFromTarget) -> bool);
wrap!(jsapi: pub fn DateIsValid(cx: &mut JSContext, obj: HandleObject, isValid: *mut bool) -> bool);
wrap!(jsapi: pub fn DateGetMsecSinceEpoch(cx: &mut JSContext, obj: HandleObject, msecSinceEpoch: *mut f64) -> bool);
wrap!(jsapi: pub fn PrepareScriptEnvironmentAndInvoke(cx: &mut JSContext, global: HandleObject, closure: *mut ScriptEnvironmentPreparer_Closure));
wrap!(jsapi: pub fn SetScriptEnvironmentPreparer(cx: &JSContext, preparer: *mut ScriptEnvironmentPreparer));
wrap!(jsapi: pub fn SetAllocationMetadataBuilder(cx: &JSContext, callback: *const AllocationMetadataBuilder));
wrap!(jsapi: pub fn GetElementsWithAdder(cx: &mut JSContext, obj: HandleObject, receiver: HandleObject, begin: u32, end: u32, adder: *mut ElementAdder) -> bool);
wrap!(jsapi: pub fn ForwardToNative(cx: &mut JSContext, native: JSNative, args: *const CallArgs) -> bool);
wrap!(jsapi: pub fn ExecuteInFrameScriptEnvironment(cx: &mut JSContext, obj: HandleObject, script: HandleScript, scope: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn ReportIsNotFunction(cx: &mut JSContext, v: HandleValue) -> bool);
wrap!(jsapi: pub fn GetGCHeapUsage(cx: &JSContext) -> u64);
wrap!(jsapi: pub fn RemapRemoteWindowProxies(cx: &mut JSContext, callback: *mut CompartmentTransplantCallback, newTarget: MutableHandleObject));
wrap!(jsapi: pub fn ComputeThis(cx: &mut JSContext, vp: *mut Value, thisObject: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn StringToLinearStringSlow(cx: &JSContext, str_: *mut JSString) -> *mut JSLinearString);
wrap!(jsapi: pub fn BigIntFromInt64(cx: &mut JSContext, num: i64) -> *mut BigInt);
wrap!(jsapi: pub fn BigIntFromUint64(cx: &mut JSContext, num: u64) -> *mut BigInt);
wrap!(jsapi: pub fn BigIntFromBool(cx: &mut JSContext, b: bool) -> *mut BigInt);
wrap!(jsapi: pub fn CallMethodIfWrapped(cx: &mut JSContext, test: IsAcceptableThis, impl_: NativeImpl, args: *const CallArgs) -> bool);
wrap!(jsapi: pub fn ReportSourceTooLong(cx: &mut JSContext));
wrap!(jsapi: pub fn IsIncrementalBarrierNeeded(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn GetCurrentRealmOrNull(cx: &JSContext) -> *mut Realm);
wrap!(jsapi: pub fn SetDestroyRealmCallback(cx: &JSContext, callback: DestroyRealmCallback));
wrap!(jsapi: pub fn SetRealmNameCallback(cx: &JSContext, callback: RealmNameCallback));
wrap!(jsapi: pub fn InitRealmStandardClasses(cx: &mut JSContext) -> bool);
wrap!(jsapi: pub fn MaybeFreezeCtorAndPrototype(cx: &mut JSContext, ctor: HandleObject, maybeProto: HandleObject) -> bool);
wrap!(jsapi: pub fn GetRealmObjectPrototype(cx: &JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetRealmFunctionPrototype(cx: &JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetRealmArrayPrototype(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetRealmErrorPrototype(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetRealmIteratorPrototype(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetRealmAsyncIteratorPrototype(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetRealmKeyObject(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetFunctionRealm(cx: &mut JSContext, objArg: HandleObject) -> *mut Realm);
wrap!(jsapi: pub fn EnterRealm(cx: &JSContext, target: *mut JSObject) -> *mut Realm);
wrap!(jsapi: pub fn LeaveRealm(cx: &JSContext, oldRealm: *mut Realm));
wrap!(jsapi: pub fn ResetRealmMathRandomSeed(cx: &JSContext));
wrap!(jsapi: pub fn Call(cx: &mut JSContext, thisv: Handle<Value>, fun: Handle<Value>, args: *const HandleValueArray, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn Construct(cx: &mut JSContext, fun: Handle<Value>, newTarget: Handle<*mut JSObject>, args: *const HandleValueArray, objp: MutableHandle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn Construct1(cx: &mut JSContext, fun: Handle<Value>, args: *const HandleValueArray, objp: MutableHandle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn LossyTwoByteCharsToNewLatin1CharsZ(cx: &JSContext, tbchars: *const Range<u16>) -> Latin1CharsZ);
wrap!(jsapi: pub fn UTF8CharsToNewTwoByteCharsZ(cx: &mut JSContext, utf8: *const UTF8Chars, outlen: *mut usize, destArenaId: arena_id_t) -> TwoByteCharsZ);
wrap!(jsapi: pub fn LossyUTF8CharsToNewTwoByteCharsZ(cx: &JSContext, utf8: *const UTF8Chars, outlen: *mut usize, destArenaId: arena_id_t) -> TwoByteCharsZ);
wrap!(jsapi: pub fn UTF8CharsToNewLatin1CharsZ(cx: &mut JSContext, utf8: *const UTF8Chars, outlen: *mut usize, destArenaId: arena_id_t) -> Latin1CharsZ);
wrap!(jsapi: pub fn EncodeNarrowToUtf8(cx: &mut JSContext, chars: *const ::std::os::raw::c_char) -> UniqueChars);
wrap!(jsapi: pub fn EncodeUtf8ToNarrow(cx: &mut JSContext, chars: *const ::std::os::raw::c_char) -> UniqueChars);
wrap!(jsapi: pub fn EncodeUtf8ToWide(cx: &JSContext, chars: *const ::std::os::raw::c_char) -> UniqueWideChars);
wrap!(jsapi: pub fn GetWellKnownSymbolKey(cx: &JSContext, which: SymbolCode) -> PropertyKey);
wrap!(jsapi: pub fn ToGetterId(cx: &mut JSContext, id: Handle<PropertyKey>, getterId: MutableHandle<PropertyKey>) -> bool);
wrap!(jsapi: pub fn ToSetterId(cx: &mut JSContext, id: Handle<PropertyKey>, setterId: MutableHandle<PropertyKey>) -> bool);
wrap!(jsapi: pub fn SetHostEnsureCanAddPrivateElementHook(cx: &JSContext, op: EnsureCanAddPrivateElementOp));
wrap!(jsapi: pub fn SetBrittleMode(cx: &JSContext, setting: bool) -> bool);
wrap!(jsapi: pub fn PrepareZoneForGC(cx: &JSContext, zone: *mut Zone));
wrap!(jsapi: pub fn PrepareForFullGC(cx: &JSContext));
wrap!(jsapi: pub fn PrepareForIncrementalGC(cx: &JSContext));
wrap!(jsapi: pub fn IsGCScheduled(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn SkipZoneForGC(cx: &JSContext, zone: *mut Zone));
wrap!(jsapi: pub fn NonIncrementalGC(cx: &mut JSContext, options: GCOptions, reason: GCReason));
wrap!(jsapi: pub fn StartIncrementalGC(cx: &mut JSContext, options: GCOptions, reason: GCReason, budget: *const SliceBudget));
wrap!(jsapi: pub fn IncrementalGCSlice(cx: &mut JSContext, reason: GCReason, budget: *const SliceBudget));
wrap!(jsapi: pub fn IncrementalGCHasForegroundWork(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn FinishIncrementalGC(cx: &mut JSContext, reason: GCReason));
wrap!(jsapi: pub fn AbortIncrementalGC(cx: &mut JSContext));
wrap!(jsapi: pub fn MinorGcToJSON(cx: &JSContext) -> UniqueChars);
wrap!(jsapi: pub fn SetGCSliceCallback(cx: &JSContext, callback: GCSliceCallback) -> GCSliceCallback);
wrap!(jsapi: pub fn AddGCNurseryCollectionCallback(cx: &JSContext, callback: GCNurseryCollectionCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn RemoveGCNurseryCollectionCallback(cx: &JSContext, callback: GCNurseryCollectionCallback, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn SetDoCycleCollectionCallback(cx: &JSContext, callback: DoCycleCollectionCallback) -> DoCycleCollectionCallback);
wrap!(jsapi: pub fn SetCreateGCSliceBudgetCallback(cx: &JSContext, cb: CreateSliceBudgetCallback));
wrap!(jsapi: pub fn IsIncrementalGCEnabled(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn IsIncrementalGCInProgress(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn SetLowMemoryState(cx: &JSContext, newState: bool));
wrap!(jsapi: pub fn NotifyGCRootsRemoved(cx: &JSContext));
wrap!(jsapi: pub fn SetHostCleanupFinalizationRegistryCallback(cx: &JSContext, cb: JSHostCleanupFinalizationRegistryCallback, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn ClearKeptObjects(cx: &JSContext));
wrap!(jsapi: pub fn ReportUncatchableException(cx: &JSContext));
wrap!(jsapi: pub fn GetPendingExceptionStack(cx: &mut JSContext, exceptionStack: *mut ExceptionStack) -> bool);
wrap!(jsapi: pub fn StealPendingExceptionStack(cx: &mut JSContext, exceptionStack: *mut ExceptionStack) -> bool);
wrap!(jsapi: pub fn SetPendingExceptionStack(cx: &JSContext, exceptionStack: *const ExceptionStack));
wrap!(jsapi: pub fn ExceptionStackOrNull(obj: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn CurrentGlobalOrNull(cx: &JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn CurrentGlobal(cx: &JSContext) -> *const *mut JSObject);
wrap!(jsapi: pub fn NewMapObject(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn MapSize(cx: &JSContext, obj: HandleObject) -> u32);
wrap!(jsapi: pub fn MapGet(cx: &mut JSContext, obj: HandleObject, key: HandleValue, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapHas(cx: &mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn MapSet(cx: &mut JSContext, obj: HandleObject, key: HandleValue, val: HandleValue) -> bool);
wrap!(jsapi: pub fn MapDelete(cx: &mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn MapClear(cx: &JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn MapKeys(cx: &mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapValues(cx: &mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapEntries(cx: &mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapForEach(cx: &mut JSContext, obj: HandleObject, callbackFn: HandleValue, thisVal: HandleValue) -> bool);
wrap!(jsapi: pub fn NewSetObject(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn SetSize(cx: &JSContext, obj: HandleObject) -> u32);
wrap!(jsapi: pub fn SetHas(cx: &mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn SetDelete(cx: &mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn SetAdd(cx: &mut JSContext, obj: HandleObject, key: HandleValue) -> bool);
wrap!(jsapi: pub fn SetClear(cx: &JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn SetKeys(cx: &mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetValues(cx: &mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetEntries(cx: &mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetForEach(cx: &mut JSContext, obj: HandleObject, callbackFn: HandleValue, thisVal: HandleValue) -> bool);
wrap!(jsapi: pub fn SetOutOfMemoryCallback(cx: &JSContext, cb: OutOfMemoryCallback, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn ToCompletePropertyDescriptor(cx: &mut JSContext, descriptor: Handle<Value>, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn NewSymbol(cx: &mut JSContext, description: Handle<*mut JSString>) -> *mut Symbol);
wrap!(jsapi: pub fn GetSymbolFor(cx: &mut JSContext, key: Handle<*mut JSString>) -> *mut Symbol);
wrap!(jsapi: pub fn GetSymbolDescription(symbol: Handle<*mut Symbol>) -> *mut JSString);
wrap!(jsapi: pub fn GetSymbolCode(symbol: Handle<*mut Symbol>) -> SymbolCode);
wrap!(jsapi: pub fn GetWellKnownSymbol(cx: &JSContext, which: SymbolCode) -> *mut Symbol);
wrap!(jsapi: pub fn IterateRealms(cx: &JSContext, data: *mut ::std::os::raw::c_void, realmCallback: IterateRealmCallback));
wrap!(jsapi: pub fn IterateRealmsWithPrincipals(cx: &JSContext, principals: *mut JSPrincipals, data: *mut ::std::os::raw::c_void, realmCallback: IterateRealmCallback));
wrap!(jsapi: pub fn IterateRealmsInCompartment(cx: &JSContext, compartment: *mut Compartment, data: *mut ::std::os::raw::c_void, realmCallback: IterateRealmCallback));
wrap!(jsapi: pub fn RealmCreationOptionsRef1(cx: &JSContext) -> *const RealmCreationOptions);
wrap!(jsapi: pub fn RealmBehaviorsRef1(cx: &JSContext) -> *const RealmBehaviors);
wrap!(jsapi: pub fn CaptureCurrentStack(cx: &mut JSContext, stackp: MutableHandleObject, capture: *mut StackCapture, startAfter: HandleObject) -> bool);
wrap!(jsapi: pub fn IsAsyncStackCaptureEnabledForRealm(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn BuildStackString(cx: &mut JSContext, principals: *mut JSPrincipals, stack: HandleObject, stringp: MutableHandleString, indent: usize, stackFormat: StackFormat) -> bool);
wrap!(jsapi: pub fn InitConsumeStreamCallback(cx: &JSContext, consume: ConsumeStreamCallback, report: ReportStreamErrorCallback));
wrap!(jsapi: pub fn NewStringFromLatin1Buffer(cx: &JSContext, buffer: RefPtr<StringBuffer>, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn NewStringFromKnownLiveLatin1Buffer(cx: &mut JSContext, buffer: *mut StringBuffer, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn NewStringFromTwoByteBuffer(cx: &JSContext, buffer: RefPtr<StringBuffer>, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn NewStringFromKnownLiveTwoByteBuffer(cx: &mut JSContext, buffer: *mut StringBuffer, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn NewStringFromUTF8Buffer(cx: &mut JSContext, buffer: RefPtr<StringBuffer>, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn NewStringFromKnownLiveUTF8Buffer(cx: &mut JSContext, buffer: *mut StringBuffer, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn GetJSTimers(cx: &JSContext) -> JSTimers);
wrap!(jsapi: pub fn NewWeakMapObject(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetWeakMapEntry(cx: &JSContext, mapObj: HandleObject, key: HandleValue, val: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetWeakMapEntry(cx: &mut JSContext, mapObj: HandleObject, key: HandleValue, val: HandleValue) -> bool);
wrap!(jsapi: pub fn ProtoKeyToId(cx: &JSContext, key: JSProtoKey, idp: MutableHandleId));
wrap!(jsapi: pub fn ToPrimitive(cx: &mut JSContext, obj: HandleObject, hint: JSType, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn GetFirstArgumentAsTypeHint(cx: &mut JSContext, args: *const CallArgs, result: *mut JSType) -> bool);
wrap!(jsapi: pub fn OrdinaryHasInstance(cx: &mut JSContext, objArg: HandleObject, v: HandleValue, bp: *mut bool) -> bool);
wrap!(jsapi: pub fn IsMapObject(cx: &mut JSContext, obj: HandleObject, isMap: *mut bool) -> bool);
wrap!(jsapi: pub fn IsSetObject(cx: &mut JSContext, obj: HandleObject, isSet: *mut bool) -> bool);
wrap!(jsapi: pub fn GetSelfHostedFunction(cx: &mut JSContext, selfHostedName: *const ::std::os::raw::c_char, id: HandleId, nargs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn NewFunctionFromSpec(cx: &mut JSContext, fs: *const JSFunctionSpec, id: HandleId) -> *mut JSFunction);
wrap!(jsapi: pub fn NewFunctionFromSpec1(cx: &mut JSContext, fs: *const JSFunctionSpec) -> *mut JSFunction);
wrap!(jsapi: pub fn PropertySpecNameEqualsId(name: JSPropertySpec_Name, id: HandleId) -> bool);
wrap!(jsapi: pub fn PropertySpecNameToPermanentId(cx: &JSContext, name: JSPropertySpec_Name, idp: *mut jsid) -> bool);
wrap!(jsapi: pub fn GetScriptedCallerGlobal(cx: &JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn HideScriptedCaller(cx: &JSContext));
wrap!(jsapi: pub fn UnhideScriptedCaller(cx: &JSContext));
wrap!(jsapi: pub fn NewArrayBuffer(cx: &mut JSContext, nbytes: usize) -> *mut JSObject);
wrap!(jsapi: pub fn CopyArrayBuffer(cx: &mut JSContext, maybeArrayBuffer: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn NewArrayBufferWithUserOwnedContents(cx: &mut JSContext, nbytes: usize, contents: *mut ::std::os::raw::c_void) -> *mut JSObject);
wrap!(jsapi: pub fn NewMappedArrayBufferWithContents(cx: &mut JSContext, nbytes: usize, contents: *mut ::std::os::raw::c_void) -> *mut JSObject);
wrap!(jsapi: pub fn DetachArrayBuffer(cx: &mut JSContext, obj: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn HasDefinedArrayBufferDetachKey(cx: &mut JSContext, obj: Handle<*mut JSObject>, isDefined: *mut bool) -> bool);
wrap!(jsapi: pub fn StealArrayBufferContents(cx: &mut JSContext, obj: Handle<*mut JSObject>) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn ArrayBufferCopyData(cx: &mut JSContext, toBlock: Handle<*mut JSObject>, toIndex: usize, fromBlock: Handle<*mut JSObject>, fromIndex: usize, count: usize) -> bool);
wrap!(jsapi: pub fn ArrayBufferClone(cx: &mut JSContext, srcBuffer: Handle<*mut JSObject>, srcByteOffset: usize, srcLength: usize) -> *mut JSObject);
wrap!(jsapi: pub fn NumberToBigInt(cx: &mut JSContext, num: f64) -> *mut BigInt);
wrap!(jsapi: pub fn StringToBigInt(cx: &mut JSContext, chars: *const Range<Latin1Char>) -> *mut BigInt);
wrap!(jsapi: pub fn StringToBigInt1(cx: &mut JSContext, chars: *const Range<u16>) -> *mut BigInt);
wrap!(jsapi: pub fn ToBigInt(cx: &mut JSContext, val: Handle<Value>) -> *mut BigInt);
wrap!(jsapi: pub fn BigIntToString(cx: &mut JSContext, bi: Handle<*mut BigInt>, radix: u8) -> *mut JSString);
wrap!(jsapi: pub fn Evaluate(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn Evaluate1(cx: &mut JSContext, envChain: *const EnvironmentChain, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn Evaluate2(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<Utf8Unit>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn EvaluateUtf8Path(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn Compile(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>) -> *mut JSScript);
wrap!(jsapi: pub fn Compile1(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<Utf8Unit>) -> *mut JSScript);
wrap!(jsapi: pub fn CompileUtf8File(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, file: *mut FILE) -> *mut JSScript);
wrap!(jsapi: pub fn CompileUtf8Path(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char) -> *mut JSScript);
wrap!(jsapi: pub fn CompileFunction(cx: &mut JSContext, envChain: *const EnvironmentChain, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, srcBuf: *mut SourceText<u16>) -> *mut JSFunction);
wrap!(jsapi: pub fn CompileFunction1(cx: &mut JSContext, envChain: *const EnvironmentChain, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, srcBuf: *mut SourceText<Utf8Unit>) -> *mut JSFunction);
wrap!(jsapi: pub fn CompileFunctionUtf8(cx: &mut JSContext, envChain: *const EnvironmentChain, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, utf8: *const ::std::os::raw::c_char, length: usize) -> *mut JSFunction);
wrap!(jsapi: pub fn ExposeScriptToDebugger(cx: &mut JSContext, script: Handle<*mut JSScript>));
wrap!(jsapi: pub fn UpdateDebugMetadata(cx: &mut JSContext, script: Handle<*mut JSScript>, options: *const InstantiateOptions, privateValue: HandleValue, elementAttributeName: HandleString, introScript: HandleScript, scriptOrModule: HandleScript) -> bool);
wrap!(jsapi: pub fn ContextOptionsRef(cx: &JSContext) -> *mut ContextOptions);
wrap!(jsapi: pub fn OrdinaryToPrimitive(cx: &mut JSContext, obj: HandleObject, type_: JSType, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn NewDateObject(cx: &mut JSContext, time: ClippedTime) -> *mut JSObject);
wrap!(jsapi: pub fn NewDateObject1(cx: &mut JSContext, year: ::std::os::raw::c_int, mon: ::std::os::raw::c_int, mday: ::std::os::raw::c_int, hour: ::std::os::raw::c_int, min: ::std::os::raw::c_int, sec: ::std::os::raw::c_int) -> *mut JSObject);
wrap!(jsapi: pub fn ObjectIsDate(cx: &mut JSContext, obj: Handle<*mut JSObject>, isDate: *mut bool) -> bool);
wrap!(jsapi: pub fn IsISOStyleDate(cx: &JSContext, str_: *const Latin1Chars) -> bool);
wrap!(jsapi: pub fn StrictlyEqual(cx: &JSContext, v1: Handle<Value>, v2: Handle<Value>, equal: *mut bool) -> bool);
wrap!(jsapi: pub fn LooselyEqual(cx: &mut JSContext, v1: Handle<Value>, v2: Handle<Value>, equal: *mut bool) -> bool);
wrap!(jsapi: pub fn SameValue(cx: &JSContext, v1: Handle<Value>, v2: Handle<Value>, same: *mut bool) -> bool);
wrap!(jsapi: pub fn InitSelfHostedCode(cx: &mut JSContext, cache: SelfHostedCache, writer: SelfHostedWriter) -> bool);
wrap!(jsapi: pub fn ToJSONMaybeSafely(cx: &mut JSContext, input: Handle<*mut JSObject>, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn ToJSON(cx: &mut JSContext, value: Handle<Value>, replacer: Handle<*mut JSObject>, space: Handle<Value>, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn ParseJSONWithHandler(chars: *const Latin1Char, len: u32, handler: *mut JSONParseHandler) -> bool);
wrap!(jsapi: pub fn ParseJSONWithHandler1(chars: *const u16, len: u32, handler: *mut JSONParseHandler) -> bool);
wrap!(jsapi: pub fn CollectRuntimeStats(cx: &mut JSContext, rtStats: *mut RuntimeStats, opv: *mut ObjectPrivateVisitor, anonymize: bool) -> bool);
wrap!(jsapi: pub fn SystemCompartmentCount(cx: &JSContext) -> usize);
wrap!(jsapi: pub fn UserCompartmentCount(cx: &JSContext) -> usize);
wrap!(jsapi: pub fn SystemRealmCount(cx: &JSContext) -> usize);
wrap!(jsapi: pub fn UserRealmCount(cx: &JSContext) -> usize);
wrap!(jsapi: pub fn PeakSizeOfTemporary(cx: &JSContext) -> usize);
wrap!(jsapi: pub fn AddSizeOfTab(cx: &mut JSContext, obj: HandleObject, mallocSizeOf: MallocSizeOf, opv: *mut ObjectPrivateVisitor, sizes: *mut TabSizes) -> bool);
wrap!(jsapi: pub fn AddServoSizeOf(cx: &mut JSContext, mallocSizeOf: MallocSizeOf, opv: *mut ObjectPrivateVisitor, sizes: *mut ServoSizes) -> bool);
wrap!(jsapi: pub fn FinishDynamicModuleImport(cx: &mut JSContext, evaluationPromise: Handle<*mut JSObject>, referencingPrivate: Handle<Value>, moduleRequest: Handle<*mut JSObject>, promise: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn CompileModule(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>) -> *mut JSObject);
wrap!(jsapi: pub fn CompileModule1(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<Utf8Unit>) -> *mut JSObject);
wrap!(jsapi: pub fn CompileJsonModule(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>) -> *mut JSObject);
wrap!(jsapi: pub fn CompileJsonModule1(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<Utf8Unit>) -> *mut JSObject);
wrap!(jsapi: pub fn ModuleLink(cx: &mut JSContext, moduleRecord: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn ModuleEvaluate(cx: &mut JSContext, moduleRecord: Handle<*mut JSObject>, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn ThrowOnModuleEvaluationFailure(cx: &mut JSContext, evaluationPromise: Handle<*mut JSObject>, errorBehaviour: ModuleErrorBehaviour) -> bool);
wrap!(jsapi: pub fn GetRequestedModulesCount(cx: &JSContext, moduleRecord: Handle<*mut JSObject>) -> u32);
wrap!(jsapi: pub fn GetRequestedModuleSpecifier(cx: &mut JSContext, moduleRecord: Handle<*mut JSObject>, index: u32) -> *mut JSString);
wrap!(jsapi: pub fn GetRequestedModuleSourcePos(cx: &JSContext, moduleRecord: Handle<*mut JSObject>, index: u32, lineNumber: *mut u32, columnNumber: *mut ColumnNumberOneOrigin));
wrap!(jsapi: pub fn GetRequestedModuleType(cx: &JSContext, moduleRecord: Handle<*mut JSObject>, index: u32) -> ModuleType);
wrap!(jsapi: pub fn GetModuleScript(moduleRecord: Handle<*mut JSObject>) -> *mut JSScript);
wrap!(jsapi: pub fn CreateModuleRequest(cx: &mut JSContext, specifierArg: Handle<*mut JSString>, moduleType: ModuleType) -> *mut JSObject);
wrap!(jsapi: pub fn GetModuleRequestSpecifier(cx: &JSContext, moduleRequestArg: Handle<*mut JSObject>) -> *mut JSString);
wrap!(jsapi: pub fn GetModuleRequestType(cx: &JSContext, moduleRequestArg: Handle<*mut JSObject>) -> ModuleType);
wrap!(jsapi: pub fn GetModuleObject(moduleScript: Handle<*mut JSScript>) -> *mut JSObject);
wrap!(jsapi: pub fn GetModuleNamespace(cx: &mut JSContext, moduleRecord: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn GetModuleForNamespace(cx: &JSContext, moduleNamespace: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn GetModuleEnvironment(cx: &JSContext, moduleObj: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn GetBuiltinClass(cx: &mut JSContext, obj: Handle<*mut JSObject>, cls: *mut ESClass) -> bool);
wrap!(jsapi: pub fn SetJobQueue(cx: &JSContext, queue: *mut JobQueue));
wrap!(jsapi: pub fn SetPromiseRejectionTrackerCallback(cx: &JSContext, callback: PromiseRejectionTrackerCallback, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JobQueueIsEmpty(cx: &JSContext));
wrap!(jsapi: pub fn JobQueueMayNotBeEmpty(cx: &JSContext));
wrap!(jsapi: pub fn NewPromiseObject(cx: &mut JSContext, executor: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn IsPromiseObject(obj: HandleObject) -> bool);
wrap!(jsapi: pub fn GetPromiseConstructor(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetPromisePrototype(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn GetPromiseState(promise: HandleObject) -> PromiseState);
wrap!(jsapi: pub fn GetPromiseID(promise: HandleObject) -> u64);
wrap!(jsapi: pub fn GetPromiseIsHandled(promise: HandleObject) -> bool);
wrap!(jsapi: pub fn SetSettledPromiseIsHandled(cx: &mut JSContext, promise: HandleObject) -> bool);
wrap!(jsapi: pub fn SetAnyPromiseIsHandled(cx: &mut JSContext, promise: HandleObject) -> bool);
wrap!(jsapi: pub fn GetPromiseAllocationSite(promise: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn GetPromiseResolutionSite(promise: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn CallOriginalPromiseResolve(cx: &mut JSContext, resolutionValue: HandleValue) -> *mut JSObject);
wrap!(jsapi: pub fn CallOriginalPromiseReject(cx: &mut JSContext, rejectionValue: HandleValue) -> *mut JSObject);
wrap!(jsapi: pub fn ResolvePromise(cx: &mut JSContext, promiseObj: HandleObject, resolutionValue: HandleValue) -> bool);
wrap!(jsapi: pub fn RejectPromise(cx: &mut JSContext, promiseObj: HandleObject, rejectionValue: HandleValue) -> bool);
wrap!(jsapi: pub fn CallOriginalPromiseThen(cx: &mut JSContext, promise: HandleObject, onFulfilled: HandleObject, onRejected: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn AddPromiseReactions(cx: &mut JSContext, promise: HandleObject, onFulfilled: HandleObject, onRejected: HandleObject) -> bool);
wrap!(jsapi: pub fn AddPromiseReactionsIgnoringUnhandledRejection(cx: &mut JSContext, promise: HandleObject, onFulfilled: HandleObject, onRejected: HandleObject) -> bool);
wrap!(jsapi: pub fn GetPromiseUserInputEventHandlingState(promise: HandleObject) -> PromiseUserInputEventHandlingState);
wrap!(jsapi: pub fn SetPromiseUserInputEventHandlingState(promise: HandleObject, state: PromiseUserInputEventHandlingState) -> bool);
wrap!(jsapi: pub fn GetWaitForAllPromise(cx: &mut JSContext, promises: HandleObjectVector) -> *mut JSObject);
wrap!(jsapi: pub fn InitDispatchsToEventLoop(cx: &JSContext, callback: DispatchToEventLoopCallback, delayedCallback: DelayedDispatchToEventLoopCallback, closure: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn ShutdownAsyncTasks(cx: &mut JSContext));
wrap!(jsapi: pub fn NewArrayObject(cx: &mut JSContext, contents: *const HandleValueArray) -> *mut JSObject);
wrap!(jsapi: pub fn NewArrayObject1(cx: &mut JSContext, length: usize) -> *mut JSObject);
wrap!(jsapi: pub fn IsArrayObject(cx: &mut JSContext, value: Handle<Value>, isArray: *mut bool) -> bool);
wrap!(jsapi: pub fn IsArrayObject1(cx: &mut JSContext, obj: Handle<*mut JSObject>, isArray: *mut bool) -> bool);
wrap!(jsapi: pub fn GetArrayLength(cx: &mut JSContext, obj: Handle<*mut JSObject>, lengthp: *mut u32) -> bool);
wrap!(jsapi: pub fn SetArrayLength(cx: &mut JSContext, obj: Handle<*mut JSObject>, length: u32) -> bool);
wrap!(jsapi: pub fn IsArray(cx: &mut JSContext, obj: Handle<*mut JSObject>, isArray: *mut bool) -> bool);
wrap!(jsapi: pub fn IsArray1(cx: &mut JSContext, obj: Handle<*mut JSObject>, answer: *mut IsArrayAnswer) -> bool);
wrap!(jsapi: pub fn NewRegExpObject(cx: &mut JSContext, bytes: *const ::std::os::raw::c_char, length: usize, flags: RegExpFlags) -> *mut JSObject);
wrap!(jsapi: pub fn NewUCRegExpObject(cx: &mut JSContext, chars: *const u16, length: usize, flags: RegExpFlags) -> *mut JSObject);
wrap!(jsapi: pub fn SetRegExpInput(cx: &JSContext, obj: Handle<*mut JSObject>, input: Handle<*mut JSString>) -> bool);
wrap!(jsapi: pub fn ClearRegExpStatics(cx: &JSContext, obj: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn ExecuteRegExp(cx: &mut JSContext, obj: Handle<*mut JSObject>, reobj: Handle<*mut JSObject>, chars: *const u16, length: usize, indexp: *mut usize, test: bool, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn ExecuteRegExpNoStatics(cx: &mut JSContext, reobj: Handle<*mut JSObject>, chars: *const u16, length: usize, indexp: *mut usize, test: bool, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn ObjectIsRegExp(cx: &mut JSContext, obj: Handle<*mut JSObject>, isRegExp: *mut bool) -> bool);
wrap!(jsapi: pub fn GetRegExpSource(cx: &mut JSContext, obj: Handle<*mut JSObject>) -> *mut JSString);
wrap!(jsapi: pub fn CheckRegExpSyntax(cx: &mut JSContext, chars: *const u16, length: usize, flags: RegExpFlags, error: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn GetSavedFrameSource(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, sourcep: MutableHandle<*mut JSString>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameSourceId(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, sourceIdp: *mut u32, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameLine(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, linep: *mut u32, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameColumn(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, columnp: *mut TaggedColumnNumberOneOrigin, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameFunctionDisplayName(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, namep: MutableHandle<*mut JSString>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameAsyncCause(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, asyncCausep: MutableHandle<*mut JSString>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameAsyncParent(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, asyncParentp: MutableHandle<*mut JSObject>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameParent(cx: &mut JSContext, principals: *mut JSPrincipals, savedFrame: Handle<*mut JSObject>, parentp: MutableHandle<*mut JSObject>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn ConvertSavedFrameToPlainObject(cx: &mut JSContext, savedFrame: HandleObject, selfHosted: SavedFrameSelfHosted) -> *mut JSObject);
wrap!(jsapi: pub fn NewSharedArrayBuffer(cx: &mut JSContext, nbytes: usize) -> *mut JSObject);
wrap!(jsapi: pub fn ContainsSharedArrayBuffer(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn GetWarningReporter(cx: &JSContext) -> WarningReporter);
wrap!(jsapi: pub fn SetWarningReporter(cx: &JSContext, reporter: WarningReporter) -> WarningReporter);
wrap!(jsapi: pub fn IsWasmModuleObject(obj: HandleObject) -> bool);
wrap!(jsapi: pub fn GetWasmModule(obj: HandleObject) -> RefPtr<WasmModule>);
wrap!(jsapi: pub fn CompileGlobalScriptToStencil(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<Utf8Unit>) -> already_AddRefed<Stencil>);
wrap!(jsapi: pub fn CompileGlobalScriptToStencil1(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>) -> already_AddRefed<Stencil>);
wrap!(jsapi: pub fn CompileModuleScriptToStencil(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<Utf8Unit>) -> already_AddRefed<Stencil>);
wrap!(jsapi: pub fn CompileModuleScriptToStencil1(cx: &mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>) -> already_AddRefed<Stencil>);
wrap!(jsapi: pub fn InstantiateGlobalStencil(cx: &JSContext, options: *const InstantiateOptions, stencil: *mut Stencil, storage: *mut InstantiationStorage) -> *mut JSScript);
wrap!(jsapi: pub fn InstantiateModuleStencil(cx: &JSContext, options: *const InstantiateOptions, stencil: *mut Stencil, storage: *mut InstantiationStorage) -> *mut JSObject);
wrap!(jsapi: pub fn DecodeStencil(cx: &JSContext, options: *const ReadOnlyDecodeOptions, range: *const TranscodeRange, stencilOut: *mut *mut Stencil) -> TranscodeResult);
wrap!(jsapi: pub fn StartCollectingDelazifications(cx: &JSContext, script: Handle<*mut JSScript>, stencil: *mut Stencil, alreadyStarted: *mut bool) -> bool);
wrap!(jsapi: pub fn StartCollectingDelazifications1(cx: &JSContext, module: Handle<*mut JSObject>, stencil: *mut Stencil, alreadyStarted: *mut bool) -> bool);
wrap!(jsapi: pub fn FinishCollectingDelazifications(cx: &mut JSContext, script: Handle<*mut JSScript>, buffer: *mut TranscodeBuffer) -> bool);
wrap!(jsapi: pub fn FinishCollectingDelazifications1(cx: &mut JSContext, module: Handle<*mut JSObject>, buffer: *mut TranscodeBuffer) -> bool);
wrap!(jsapi: pub fn FinishCollectingDelazifications2(cx: &JSContext, script: Handle<*mut JSScript>, stencilOut: *mut *mut Stencil) -> bool);
wrap!(jsapi: pub fn AbortCollectingDelazifications(script: Handle<*mut JSScript>));
wrap!(jsapi: pub fn AbortCollectingDelazifications1(module: Handle<*mut JSObject>));
wrap!(jsapi: pub fn EnsureNonInlineArrayBufferOrView(cx: &mut JSContext, obj: *mut JSObject) -> bool);
wrap!(jsapi: pub fn ForceLexicalInitialization(cx: &JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_ReportOutOfMemory(cx: &JSContext));
wrap!(jsapi: pub fn JS_CallFunctionValue(cx: &mut JSContext, obj: Handle<*mut JSObject>, fval: Handle<Value>, args: *const HandleValueArray, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_CallFunction(cx: &mut JSContext, obj: Handle<*mut JSObject>, fun: Handle<*mut JSFunction>, args: *const HandleValueArray, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_CallFunctionName(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, args: *const HandleValueArray, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_EncodeStringToLatin1(cx: &JSContext, str_: *mut JSString) -> UniqueChars);
wrap!(jsapi: pub fn JS_EncodeStringToUTF8(cx: &JSContext, str_: Handle<*mut JSString>) -> UniqueChars);
wrap!(jsapi: pub fn JS_EncodeStringToASCII(cx: &JSContext, str_: *mut JSString) -> UniqueChars);
wrap!(jsapi: pub fn JS_DestroyContext(cx: &mut JSContext));
wrap!(jsapi: pub fn JS_GetContextPrivate(cx: &JSContext) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_SetContextPrivate(cx: &JSContext, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JS_GetParentRuntime(cx: &JSContext) -> *mut JSRuntime);
wrap!(jsapi: pub fn JS_GetRuntime(cx: &JSContext) -> *mut JSRuntime);
wrap!(jsapi: pub fn JS_SetFutexCanWait(cx: &JSContext));
wrap!(jsapi: pub fn JS_AddExtraGCRootsTracer(cx: &JSContext, traceOp: JSTraceDataOp, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_RemoveExtraGCRootsTracer(cx: &JSContext, traceOp: JSTraceDataOp, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JS_GC(cx: &mut JSContext, reason: GCReason));
wrap!(jsapi: pub fn JS_MaybeGC(cx: &mut JSContext));
wrap!(jsapi: pub fn JS_SetGCCallback(cx: &JSContext, cb: JSGCCallback, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JS_SetObjectsTenuredCallback(cx: &JSContext, cb: JSObjectsTenuredCallback, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JS_AddFinalizeCallback(cx: &JSContext, cb: JSFinalizeCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_RemoveFinalizeCallback(cx: &JSContext, cb: JSFinalizeCallback));
wrap!(jsapi: pub fn JS_AddWeakPointerZonesCallback(cx: &JSContext, cb: JSWeakPointerZonesCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_RemoveWeakPointerZonesCallback(cx: &JSContext, cb: JSWeakPointerZonesCallback));
wrap!(jsapi: pub fn JS_AddWeakPointerCompartmentCallback(cx: &JSContext, cb: JSWeakPointerCompartmentCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_RemoveWeakPointerCompartmentCallback(cx: &JSContext, cb: JSWeakPointerCompartmentCallback));
wrap!(jsapi: pub fn JS_SetGCParameter(cx: &mut JSContext, key: JSGCParamKey, value: u32));
wrap!(jsapi: pub fn JS_ResetGCParameter(cx: &mut JSContext, key: JSGCParamKey));
wrap!(jsapi: pub fn JS_GetGCParameter(cx: &JSContext, key: JSGCParamKey) -> u32);
wrap!(jsapi: pub fn JS_SetGCParametersBasedOnAvailableMemory(cx: &mut JSContext, availMemMB: u32));
wrap!(jsapi: pub fn JS_NewExternalStringLatin1(cx: &mut JSContext, chars: *const Latin1Char, length: usize, callbacks: *const JSExternalStringCallbacks) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewExternalUCString(cx: &mut JSContext, chars: *const u16, length: usize, callbacks: *const JSExternalStringCallbacks) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewMaybeExternalStringLatin1(cx: &mut JSContext, chars: *const Latin1Char, length: usize, callbacks: *const JSExternalStringCallbacks, allocatedExternal: *mut bool) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewMaybeExternalUCString(cx: &mut JSContext, chars: *const u16, length: usize, callbacks: *const JSExternalStringCallbacks, allocatedExternal: *mut bool) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewMaybeExternalStringUTF8(cx: &mut JSContext, utf8: *const UTF8Chars, callbacks: *const JSExternalStringCallbacks, allocatedExternal: *mut bool) -> *mut JSString);
wrap!(jsapi: pub fn JS_DefineDebuggerObject(cx: &mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_TracerEnterLabelLatin1(cx: &mut JSContext, label: *const ::std::os::raw::c_char));
wrap!(jsapi: pub fn JS_TracerEnterLabelTwoByte(cx: &mut JSContext, label: *const u16));
wrap!(jsapi: pub fn JS_TracerIsTracing(cx: &mut JSContext) -> bool);
wrap!(jsapi: pub fn JS_TracerLeaveLabelLatin1(cx: &mut JSContext, label: *const ::std::os::raw::c_char));
wrap!(jsapi: pub fn JS_TracerLeaveLabelTwoByte(cx: &mut JSContext, label: *const u16));
wrap!(jsapi: pub fn JS_ReportErrorNumberUTF8Array(cx: &mut JSContext, errorCallback: JSErrorCallback, userRef: *mut ::std::os::raw::c_void, errorNumber: ::std::os::raw::c_uint, args: *mut *const ::std::os::raw::c_char));
wrap!(jsapi: pub fn JS_ReportErrorNumberUCArray(cx: &mut JSContext, errorCallback: JSErrorCallback, userRef: *mut ::std::os::raw::c_void, errorNumber: ::std::os::raw::c_uint, args: *mut *const u16));
wrap!(jsapi: pub fn JS_ReportAllocationOverflow(cx: &JSContext));
wrap!(jsapi: pub fn JS_IsExceptionPending(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn JS_IsThrowingOutOfMemory(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn JS_GetPendingException(cx: &mut JSContext, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_SetPendingException(cx: &mut JSContext, v: HandleValue, behavior: ExceptionStackBehavior));
wrap!(jsapi: pub fn JS_ClearPendingException(cx: &JSContext));
wrap!(jsapi: pub fn JS_ErrorFromException(cx: &JSContext, obj: HandleObject) -> *mut JSErrorReport);
wrap!(jsapi: pub fn JS_NewGlobalObject(cx: &mut JSContext, clasp: *const JSClass, principals: *mut JSPrincipals, hookOption: OnNewGlobalHookOption, options: *const RealmOptions) -> *mut JSObject);
wrap!(jsapi: pub fn JS_FireOnNewGlobalObject(cx: &mut JSContext, global: HandleObject));
wrap!(jsapi: pub fn JS_CheckForInterrupt(cx: &mut JSContext) -> bool);
wrap!(jsapi: pub fn JS_AddInterruptCallback(cx: &JSContext, callback: JSInterruptCallback) -> bool);
wrap!(jsapi: pub fn JS_DisableInterruptCallback(cx: &JSContext) -> bool);
wrap!(jsapi: pub fn JS_ResetInterruptCallback(cx: &JSContext, enable: bool));
wrap!(jsapi: pub fn JS_RequestInterruptCallback(cx: &JSContext));
wrap!(jsapi: pub fn JS_RequestInterruptCallbackCanWait(cx: &JSContext));
wrap!(jsapi: pub fn JS_malloc(cx: &JSContext, nbytes: usize) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_realloc(cx: &JSContext, p: *mut ::std::os::raw::c_void, oldBytes: usize, newBytes: usize) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_free(cx: &JSContext, p: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JS_string_malloc(cx: &JSContext, nbytes: usize) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_string_realloc(cx: &JSContext, p: *mut ::std::os::raw::c_void, oldBytes: usize, newBytes: usize) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_string_free(cx: &JSContext, p: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JS_DropPrincipals(cx: &JSContext, principals: *mut JSPrincipals));
wrap!(jsapi: pub fn JS_SetSecurityCallbacks(cx: &JSContext, callbacks: *const JSSecurityCallbacks));
wrap!(jsapi: pub fn JS_GetSecurityCallbacks(cx: &JSContext) -> *const JSSecurityCallbacks);
wrap!(jsapi: pub fn JS_SetTrustedPrincipals(cx: &JSContext, prin: *mut JSPrincipals));
wrap!(jsapi: pub fn JS_InitDestroyPrincipalsCallback(cx: &JSContext, destroyPrincipals: JSDestroyPrincipalsOp));
wrap!(jsapi: pub fn JS_InitReadPrincipalsCallback(cx: &JSContext, read: JSReadPrincipalsOp));
wrap!(jsapi: pub fn JS_DefinePropertyById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, desc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById1(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, desc: Handle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById2(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, value: Handle<Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById3(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, getter: JSNative, setter: JSNative, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById4(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, getter: Handle<*mut JSObject>, setter: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById5(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, value: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById6(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, value: Handle<*mut JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById7(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById8(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById9(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, value: Handle<Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty1(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, getter: JSNative, setter: JSNative, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty2(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, getter: Handle<*mut JSObject>, setter: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty3(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, value: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty4(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, value: Handle<*mut JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty5(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty6(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty7(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, desc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty1(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, desc: Handle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty2(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, value: Handle<Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty3(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, getter: Handle<*mut JSObject>, setter: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty4(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, value: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty5(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, value: Handle<*mut JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty6(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty7(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty8(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, value: Handle<Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement1(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, getter: Handle<*mut JSObject>, setter: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement2(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, value: Handle<*mut JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement3(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, value: Handle<*mut JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement4(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement5(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement6(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_HasPropertyById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasUCProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, vp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasElement(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasOwnPropertyById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasOwnProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_ForwardGetPropertyTo(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, receiver: Handle<Value>, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_ForwardGetElementTo(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, receiver: Handle<*mut JSObject>, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetPropertyById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetUCProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetElement(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_ForwardSetPropertyTo(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, v: Handle<Value>, receiver: Handle<Value>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_SetPropertyById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, v: Handle<Value>) -> bool);
wrap!(jsapi: pub fn JS_SetProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, v: Handle<Value>) -> bool);
wrap!(jsapi: pub fn JS_SetUCProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, v: Handle<Value>) -> bool);
wrap!(jsapi: pub fn JS_SetElement(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, v: Handle<Value>) -> bool);
wrap!(jsapi: pub fn JS_SetElement1(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, v: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn JS_SetElement2(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, v: Handle<*mut JSString>) -> bool);
wrap!(jsapi: pub fn JS_SetElement3(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, v: i32) -> bool);
wrap!(jsapi: pub fn JS_SetElement4(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, v: u32) -> bool);
wrap!(jsapi: pub fn JS_SetElement5(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, v: f64) -> bool);
wrap!(jsapi: pub fn JS_DeletePropertyById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeleteProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeleteUCProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeleteElement(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeletePropertyById1(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>) -> bool);
wrap!(jsapi: pub fn JS_DeleteProperty1(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char) -> bool);
wrap!(jsapi: pub fn JS_DeleteElement1(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32) -> bool);
wrap!(jsapi: pub fn JS_DefineObject(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, clasp: *const JSClass, attrs: ::std::os::raw::c_uint) -> *mut JSObject);
wrap!(jsapi: pub fn JS_DefineProperties(cx: &mut JSContext, obj: Handle<*mut JSObject>, ps: *const JSPropertySpec) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnPropertyById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnUCProperty(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnElement(cx: &mut JSContext, obj: Handle<*mut JSObject>, index: u32, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_DefineFunctions(cx: &mut JSContext, obj: Handle<*mut JSObject>, fs: *const JSFunctionSpec) -> bool);
wrap!(jsapi: pub fn JS_DefineFunction(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_DefineUCFunction(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const u16, namelen: usize, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_DefineFunctionById(cx: &mut JSContext, obj: Handle<*mut JSObject>, id: Handle<jsid>, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_IterateCompartments(cx: &mut JSContext, data: *mut ::std::os::raw::c_void, compartmentCallback: JSIterateCompartmentCallback));
wrap!(jsapi: pub fn JS_IterateCompartmentsInZone(cx: &mut JSContext, zone: *mut Zone, data: *mut ::std::os::raw::c_void, compartmentCallback: JSIterateCompartmentCallback));
wrap!(jsapi: pub fn JS_SetNativeStackQuota(cx: &JSContext, systemCodeStackSize: NativeStackSize, trustedScriptStackSize: NativeStackSize, untrustedScriptStackSize: NativeStackSize));
wrap!(jsapi: pub fn JS_GetEmptyString(cx: &JSContext) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewStringCopyN(cx: &mut JSContext, s: *const ::std::os::raw::c_char, n: usize) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewStringCopyZ(cx: &mut JSContext, s: *const ::std::os::raw::c_char) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewStringCopyUTF8Z(cx: &mut JSContext, s: ConstUTF8CharsZ) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewStringCopyUTF8N(cx: &mut JSContext, s: *const UTF8Chars) -> *mut JSString);
wrap!(jsapi: pub fn JS_AtomizeStringN(cx: &JSContext, s: *const ::std::os::raw::c_char, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn JS_AtomizeString(cx: &JSContext, s: *const ::std::os::raw::c_char) -> *mut JSString);
wrap!(jsapi: pub fn JS_AtomizeAndPinStringN(cx: &JSContext, s: *const ::std::os::raw::c_char, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn JS_AtomizeAndPinString(cx: &JSContext, s: *const ::std::os::raw::c_char) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewUCStringCopyN(cx: &mut JSContext, s: *const u16, n: usize) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewUCStringCopyZ(cx: &mut JSContext, s: *const u16) -> *mut JSString);
wrap!(jsapi: pub fn JS_AtomizeUCStringN(cx: &JSContext, s: *const u16, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn JS_AtomizeUCString(cx: &JSContext, s: *const u16) -> *mut JSString);
wrap!(jsapi: pub fn JS_CompareStrings(cx: &JSContext, str1: *mut JSString, str2: *mut JSString, result: *mut i32) -> bool);
wrap!(jsapi: pub fn JS_StringEqualsAscii(cx: &JSContext, str_: *mut JSString, asciiBytes: *const ::std::os::raw::c_char, match_: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_StringEqualsAscii1(cx: &JSContext, str_: *mut JSString, asciiBytes: *const ::std::os::raw::c_char, length: usize, match_: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_PutEscapedString(cx: &JSContext, buffer: *mut ::std::os::raw::c_char, size: usize, str_: *mut JSString, quote: ::std::os::raw::c_char) -> usize);
wrap!(jsapi: pub fn JS_GetLatin1StringCharsAndLength(cx: &JSContext, nogc: *const AutoRequireNoGC, str_: *mut JSString, length: *mut usize) -> *const Latin1Char);
wrap!(jsapi: pub fn JS_GetTwoByteStringCharsAndLength(cx: &JSContext, nogc: *const AutoRequireNoGC, str_: *mut JSString, length: *mut usize) -> *const u16);
wrap!(jsapi: pub fn JS_GetStringCharAt(cx: &JSContext, str_: *mut JSString, index: usize, res: *mut u16) -> bool);
wrap!(jsapi: pub fn JS_CopyStringChars(cx: &JSContext, dest: *const Range<u16>, str_: *mut JSString) -> bool);
wrap!(jsapi: pub fn JS_CopyStringCharsZ(cx: &JSContext, str_: *mut JSString) -> UniqueTwoByteChars);
wrap!(jsapi: pub fn JS_EnsureLinearString(cx: &JSContext, str_: *mut JSString) -> *mut JSLinearString);
wrap!(jsapi: pub fn JS_NewDependentString(cx: &JSContext, str_: Handle<*mut JSString>, start: usize, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn JS_ConcatStrings(cx: &mut JSContext, left: Handle<*mut JSString>, right: Handle<*mut JSString>) -> *mut JSString);
wrap!(jsapi: pub fn JS_DecodeBytes(cx: &JSContext, src: *const ::std::os::raw::c_char, srclen: usize, dst: *mut u16, dstlenp: *mut usize) -> bool);
wrap!(jsapi: pub fn JS_GetStringEncodingLength(cx: &JSContext, str_: *mut JSString) -> usize);
wrap!(jsapi: pub fn JS_EncodeStringToBuffer(cx: &JSContext, str_: *mut JSString, buffer: *mut ::std::os::raw::c_char, length: usize) -> bool);
wrap!(jsapi: pub fn JS_SetDestroyZoneCallback(cx: &JSContext, callback: JSDestroyZoneCallback));
wrap!(jsapi: pub fn JS_SetDestroyCompartmentCallback(cx: &JSContext, callback: JSDestroyCompartmentCallback));
wrap!(jsapi: pub fn JS_SetSizeOfIncludingThisCompartmentCallback(cx: &JSContext, callback: JSSizeOfIncludingThisCompartmentCallback));
wrap!(jsapi: pub fn JS_RefreshCrossCompartmentWrappers(cx: &mut JSContext, obj: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn JS_MarkCrossZoneId(cx: &JSContext, id: jsid));
wrap!(jsapi: pub fn JS_MarkCrossZoneIdValue(cx: &JSContext, value: *const Value));
wrap!(jsapi: pub fn JS_StringHasBeenPinned(cx: &JSContext, str_: *mut JSString) -> bool);
wrap!(jsapi: pub fn JS_ValueToObject(cx: &mut JSContext, v: HandleValue, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_ValueToFunction(cx: &mut JSContext, v: HandleValue) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_ValueToConstructor(cx: &mut JSContext, v: HandleValue) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_ValueToSource(cx: &mut JSContext, v: Handle<Value>) -> *mut JSString);
wrap!(jsapi: pub fn JS_TypeOfValue(cx: &JSContext, v: Handle<Value>) -> JSType);
wrap!(jsapi: pub fn JS_SetWrapObjectCallbacks(cx: &JSContext, callbacks: *const JSWrapObjectCallbacks));
wrap!(jsapi: pub fn JS_WrapObject(cx: &mut JSContext, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_WrapValue(cx: &mut JSContext, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_TransplantObject(cx: &mut JSContext, origobj: HandleObject, target: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_ResolveStandardClass(cx: &mut JSContext, obj: HandleObject, id: HandleId, resolved: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_EnumerateStandardClasses(cx: &mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_NewEnumerateStandardClasses(cx: &mut JSContext, obj: HandleObject, properties: MutableHandleIdVector, enumerableOnly: bool) -> bool);
wrap!(jsapi: pub fn JS_NewEnumerateStandardClassesIncludingResolved(cx: &mut JSContext, obj: HandleObject, properties: MutableHandleIdVector, enumerableOnly: bool) -> bool);
wrap!(jsapi: pub fn JS_GetClassObject(cx: &mut JSContext, key: JSProtoKey, objp: MutableHandle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn JS_GetClassPrototype(cx: &mut JSContext, key: JSProtoKey, objp: MutableHandle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn JS_IdToProtoKey(cx: &JSContext, id: HandleId) -> JSProtoKey);
wrap!(jsapi: pub fn JS_InitReflectParse(cx: &mut JSContext, global: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_DefineProfilingFunctions(cx: &JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_ValueToId(cx: &mut JSContext, v: HandleValue, idp: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_StringToId(cx: &mut JSContext, s: HandleString, idp: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_IdToValue(cx: &JSContext, id: jsid, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_InitClass(cx: &mut JSContext, obj: HandleObject, protoClass: *const JSClass, protoProto: HandleObject, name: *const ::std::os::raw::c_char, constructor: JSNative, nargs: ::std::os::raw::c_uint, ps: *const JSPropertySpec, fs: *const JSFunctionSpec, static_ps: *const JSPropertySpec, static_fs: *const JSFunctionSpec) -> *mut JSObject);
wrap!(jsapi: pub fn JS_LinkConstructorAndPrototype(cx: &mut JSContext, ctor: Handle<*mut JSObject>, proto: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn JS_InstanceOf(cx: &mut JSContext, obj: Handle<*mut JSObject>, clasp: *const JSClass, args: *mut CallArgs) -> bool);
wrap!(jsapi: pub fn JS_HasInstance(cx: &mut JSContext, obj: Handle<*mut JSObject>, v: Handle<Value>, bp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetConstructor(cx: &mut JSContext, proto: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewObject(cx: &mut JSContext, clasp: *const JSClass) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewObjectWithGivenProto(cx: &mut JSContext, clasp: *const JSClass, proto: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewPlainObject(cx: &mut JSContext) -> *mut JSObject);
wrap!(jsapi: pub fn JS_DeepFreezeObject(cx: &mut JSContext, obj: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn JS_FreezeObject(cx: &mut JSContext, obj: Handle<*mut JSObject>) -> bool);
wrap!(jsapi: pub fn JS_GetPrototype(cx: &mut JSContext, obj: HandleObject, result: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_GetPrototypeIfOrdinary(cx: &mut JSContext, obj: HandleObject, isOrdinary: *mut bool, result: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_SetPrototype(cx: &mut JSContext, obj: HandleObject, proto: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_IsExtensible(cx: &mut JSContext, obj: HandleObject, extensible: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_PreventExtensions(cx: &mut JSContext, obj: HandleObject, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_SetImmutablePrototype(cx: &mut JSContext, obj: HandleObject, succeeded: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_AssignObject(cx: &mut JSContext, target: HandleObject, src: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_SetAllNonReservedSlotsToUndefined(obj: HandleObject));
wrap!(jsapi: pub fn JS_NewFunction(cx: &mut JSContext, call: JSNative, nargs: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, name: *const ::std::os::raw::c_char) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_GetFunctionId(cx: &JSContext, fun: Handle<*mut JSFunction>, name: MutableHandle<*mut JSString>) -> bool);
wrap!(jsapi: pub fn JS_GetFunctionDisplayId(cx: &JSContext, fun: Handle<*mut JSFunction>, name: MutableHandle<*mut JSString>) -> bool);
wrap!(jsapi: pub fn JS_GetFunctionLength(cx: &mut JSContext, fun: HandleFunction, length: *mut u16) -> bool);
wrap!(jsapi: pub fn JS_GetScriptBaseLineNumber(cx: &JSContext, script: *mut JSScript) -> ::std::os::raw::c_uint);
wrap!(jsapi: pub fn JS_GetFunctionScript(cx: &mut JSContext, fun: HandleFunction) -> *mut JSScript);
wrap!(jsapi: pub fn JS_DecompileScript(cx: &mut JSContext, script: Handle<*mut JSScript>) -> *mut JSString);
wrap!(jsapi: pub fn JS_DecompileFunction(cx: &mut JSContext, fun: Handle<*mut JSFunction>) -> *mut JSString);
wrap!(jsapi: pub fn JS_AbortIfWrongThread(cx: &JSContext));
wrap!(jsapi: pub fn JS_NewObjectForConstructor(cx: &mut JSContext, clasp: *const JSClass, args: *const CallArgs) -> *mut JSObject);
wrap!(jsapi: pub fn JS_SetOffthreadBaselineCompilationEnabled(cx: &JSContext, enabled: bool));
wrap!(jsapi: pub fn JS_SetOffthreadIonCompilationEnabled(cx: &JSContext, enabled: bool));
wrap!(jsapi: pub fn JS_SetGlobalJitCompilerOption(cx: &JSContext, opt: JSJitCompilerOption, value: u32));
wrap!(jsapi: pub fn JS_GetGlobalJitCompilerOption(cx: &JSContext, opt: JSJitCompilerOption, valueOut: *mut u32) -> bool);
wrap!(jsapi: pub fn JS_IndexToId(cx: &JSContext, index: u32, arg1: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_CharsToId(cx: &JSContext, chars: TwoByteChars, arg1: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_IsIdentifier(cx: &JSContext, str_: HandleString, isIdentifier: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_Utf8BufferIsCompilableUnit(cx: &mut JSContext, obj: Handle<*mut JSObject>, utf8: *const ::std::os::raw::c_char, length: usize) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript(cx: &mut JSContext, script: Handle<*mut JSScript>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript1(cx: &mut JSContext, script: Handle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript2(cx: &mut JSContext, envChain: *const EnvironmentChain, script: Handle<*mut JSScript>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript3(cx: &mut JSContext, envChain: *const EnvironmentChain, script: Handle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn JS_Stringify(cx: &mut JSContext, value: MutableHandle<Value>, replacer: Handle<*mut JSObject>, space: Handle<Value>, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_StringifyWithLengthHint(cx: &mut JSContext, value: MutableHandle<Value>, replacer: Handle<*mut JSObject>, space: Handle<Value>, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void, lengthHint: usize) -> bool);
wrap!(jsapi: pub fn JS_ParseJSON(cx: &mut JSContext, chars: *const u16, len: u32, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ParseJSON1(cx: &mut JSContext, str_: Handle<*mut JSString>, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ParseJSON2(cx: &mut JSContext, chars: *const Latin1Char, len: u32, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ParseJSONWithReviver(cx: &mut JSContext, chars: *const u16, len: u32, reviver: Handle<Value>, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ParseJSONWithReviver1(cx: &mut JSContext, str_: Handle<*mut JSString>, reviver: Handle<Value>, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ReadStructuredClone(cx: &mut JSContext, data: *const JSStructuredCloneData, version: u32, scope: StructuredCloneScope, vp: MutableHandleValue, cloneDataPolicy: *const CloneDataPolicy, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_WriteStructuredClone(cx: &mut JSContext, v: HandleValue, data: *mut JSStructuredCloneData, scope: StructuredCloneScope, cloneDataPolicy: *const CloneDataPolicy, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void, transferable: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_StructuredClone(cx: &mut JSContext, v: HandleValue, vp: MutableHandleValue, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_ReadString(r: *mut JSStructuredCloneReader, str_: MutableHandleString) -> bool);
wrap!(jsapi: pub fn JS_ReadTypedArray(r: *mut JSStructuredCloneReader, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_WriteString(w: *mut JSStructuredCloneWriter, str_: HandleString) -> bool);
wrap!(jsapi: pub fn JS_WriteTypedArray(w: *mut JSStructuredCloneWriter, v: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_ObjectNotWritten(w: *mut JSStructuredCloneWriter, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_NewInt8Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt8ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt8ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt16Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt16ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt16ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint16Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint16ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint16ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt32Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt32ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt32ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint32Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint32ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint32ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat32Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat32ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat32ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat64Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat64ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat64ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ClampedArray(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ClampedArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ClampedArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewBigInt64Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewBigInt64ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewBigInt64ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewBigUint64Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewBigUint64ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewBigUint64ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat16Array(cx: &mut JSContext, nelements: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat16ArrayFromArray(cx: &mut JSContext, array: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat16ArrayWithBuffer(cx: &mut JSContext, arrayBuffer: Handle<*mut JSObject>, byteOffset: usize, length: i64) -> *mut JSObject);
wrap!(jsapi: pub fn JS_GetArrayBufferViewBuffer(cx: &mut JSContext, obj: Handle<*mut JSObject>, isSharedMemory: *mut bool) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewDataView(cx: &mut JSContext, buffer: Handle<*mut JSObject>, byteOffset: usize, byteLength: usize) -> *mut JSObject);
wrap!(jsapi: pub fn JS_SetGrayGCRootsTracer(cx: &JSContext, traceOp: JSGrayRootsTracer, data: *mut ::std::os::raw::c_void));
wrap!(jsapi: pub fn JS_FindCompilationScope(cx: &JSContext, obj: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewObjectWithoutMetadata(cx: &mut JSContext, clasp: *const JSClass, proto: Handle<*mut JSObject>) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NondeterministicGetWeakMapKeys(cx: &mut JSContext, obj: HandleObject, ret: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_NondeterministicGetWeakSetKeys(cx: &mut JSContext, obj: HandleObject, ret: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_NewDeadWrapper(cx: &mut JSContext, origObject: *mut JSObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_CloneObject(cx: &mut JSContext, obj: HandleObject, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_InitializePropertiesFromCompatibleNativeObject(cx: &mut JSContext, dst: HandleObject, src: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_CopyOwnPropertiesAndPrivateFields(cx: &mut JSContext, target: HandleObject, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_WrapPropertyDescriptor(cx: &mut JSContext, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_DefineFunctionsWithHelp(cx: &mut JSContext, obj: HandleObject, fs: *const JSFunctionSpecWithHelp) -> bool);
wrap!(jsapi: pub fn JS_NewOwningCompileOptions(cx: &mut JSContext) -> *mut OwningCompileOptions);
wrap!(jsapi: pub fn JS_StackCapture_FirstSubsumedFrame(cx: &mut JSContext, ignoreSelfHostedFrames: bool, capture: *mut StackCapture));
wrap!(jsapi: pub fn NewExternalArrayBuffer(cx: &mut JSContext, nbytes: usize, contents: *mut ::std::os::raw::c_void, freeFunc: BufferContentsFreeFunc, freeUserData: *mut ::std::os::raw::c_void) -> *mut JSObject);
wrap!(jsapi: pub fn NewArrayBufferWithContents(cx: &mut JSContext, nbytes: usize, contents: *mut ::std::os::raw::c_void) -> *mut JSObject);
wrap!(jsapi: pub fn JS_ForOfIteratorInit(iterator: *mut ForOfIterator, iterable: HandleValue, nonIterableBehavior: ForOfIterator_NonIterableBehavior) -> bool);
wrap!(jsapi: pub fn JS_ForOfIteratorNext(iterator: *mut ForOfIterator, val: MutableHandleValue, done: *mut bool) -> bool);
wrap!(jsapi: pub fn FromPropertyDescriptor(cx: &mut JSContext, desc_: Handle<PropertyDescriptor>, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetPropertyDescriptor(cx: &mut JSContext, obj: Handle<*mut JSObject>, name: *const ::std::os::raw::c_char, desc: MutableHandle<PropertyDescriptor>, holder: MutableHandle<*mut JSObject>, isNone: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetOwnPropertyDescriptorById(cx: &mut JSContext, obj: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>, isNone: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetOwnPropertyDescriptor(cx: &mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, desc: MutableHandle<PropertyDescriptor>, isNone: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetOwnUCPropertyDescriptor(cx: &mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, desc: MutableHandle<PropertyDescriptor>, isNone: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetPropertyDescriptorById(cx: &mut JSContext, obj: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>, holder: MutableHandleObject, isNone: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetUCPropertyDescriptor(cx: &mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, desc: MutableHandle<PropertyDescriptor>, holder: MutableHandleObject, isNone: *mut bool) -> bool);
wrap!(jsapi: pub fn SetPropertyIgnoringNamedGetter(cx: &mut JSContext, obj: HandleObject, id: HandleId, v: HandleValue, receiver: HandleValue, ownDesc: *const Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn CreateError(cx: &mut JSContext, type_: JSExnType, stack: HandleObject, fileName: HandleString, lineNumber: u32, columnNumber: u32, report: *mut JSErrorReport, message: HandleString, cause: HandleValue, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn GetExceptionCause(exc: *mut JSObject, dest: MutableHandleValue));
wrap!(jsapi: pub fn NewEnvironmentChain(cx: &mut JSContext, supportUnscopables: SupportUnscopables) -> *mut EnvironmentChain);
