wrap!(glue: pub fn InvokeGetOwnPropertyDescriptor(handler: *const ::std::os::raw::c_void, cx: &mut JSContext, proxy: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>, isNone: *mut bool) -> bool);
wrap!(glue: pub fn InvokeHasOwn(handler: *const ::std::os::raw::c_void, cx: &mut JSContext, proxy: HandleObject, id: HandleId, bp: *mut bool) -> bool);
wrap!(glue: pub fn CallJitGetterOp(info: *const JSJitInfo, cx: &mut JSContext, thisObj: HandleObject, specializedThis: *mut ::std::os::raw::c_void, argc: ::std::os::raw::c_uint, vp: *mut Value) -> bool);
wrap!(glue: pub fn CallJitSetterOp(info: *const JSJitInfo, cx: &mut JSContext, thisObj: HandleObject, specializedThis: *mut ::std::os::raw::c_void, argc: ::std::os::raw::c_uint, vp: *mut Value) -> bool);
wrap!(glue: pub fn CallJitMethodOp(info: *const JSJitInfo, cx: &mut JSContext, thisObj: HandleObject, specializedThis: *mut ::std::os::raw::c_void, argc: u32, vp: *mut Value) -> bool);
wrap!(glue: pub fn NewCompileOptions(aCx: &mut JSContext, aFile: *const ::std::os::raw::c_char, aLine: ::std::os::raw::c_uint) -> *mut ReadOnlyCompileOptions);
wrap!(glue: pub fn NewProxyObject(aCx: &mut JSContext, aHandler: *const ::std::os::raw::c_void, aPriv: HandleValue, proto: *mut JSObject, aClass: *const JSClass, aLazyProto: bool) -> *mut JSObject);
wrap!(glue: pub fn WrapperNew(aCx: &mut JSContext, aObj: HandleObject, aHandler: *const ::std::os::raw::c_void, aClass: *const JSClass) -> *mut JSObject);
wrap!(glue: pub fn NewWindowProxy(aCx: &mut JSContext, aObj: HandleObject, aHandler: *const ::std::os::raw::c_void) -> *mut JSObject);
wrap!(glue: pub fn RUST_JSID_IS_INT(id: HandleId) -> bool);
wrap!(glue: pub fn int_to_jsid(i: i32, id: MutableHandleId));
wrap!(glue: pub fn RUST_JSID_TO_INT(id: HandleId) -> i32);
wrap!(glue: pub fn RUST_JSID_IS_STRING(id: HandleId) -> bool);
wrap!(glue: pub fn RUST_JSID_TO_STRING(id: HandleId) -> *mut JSString);
wrap!(glue: pub fn RUST_SYMBOL_TO_JSID(sym: *mut Symbol, id: MutableHandleId));
wrap!(glue: pub fn RUST_JSID_IS_VOID(id: HandleId) -> bool);
wrap!(glue: pub fn RUST_INTERNED_STRING_TO_JSID(cx: &mut JSContext, str_: *mut JSString, id: MutableHandleId));
wrap!(glue: pub fn ReportErrorASCII(aCx: &mut JSContext, aError: *const ::std::os::raw::c_char));
wrap!(glue: pub fn ReportErrorUTF8(aCx: &mut JSContext, aError: *const ::std::os::raw::c_char));
wrap!(glue: pub fn UnwrapObjectDynamic(obj: *mut JSObject, cx: &mut JSContext, stopAtWindowProxy: bool) -> *mut JSObject);
wrap!(glue: pub fn CreateRootedIdVector(cx: &mut JSContext) -> *mut PersistentRootedIdVector);
wrap!(glue: pub fn AppendToIdVector(v: MutableHandleIdVector, id: HandleId) -> bool);
wrap!(glue: pub fn CreateRootedObjectVector(aCx: &mut JSContext) -> *mut PersistentRootedObjectVector);
wrap!(glue: pub fn CollectServoSizes(cx: &mut JSContext, sizes: *mut ServoSizes, gs: GetSize) -> bool);
wrap!(glue: pub fn JS_GetPromiseResult(promise: HandleObject, dest: MutableHandleValue));
wrap!(glue: pub fn JS_GetScriptPrivate(script: *mut JSScript, dest: MutableHandleValue));
wrap!(glue: pub fn JS_MaybeGetScriptPrivate(obj: *mut JSObject, dest: MutableHandleValue));
wrap!(glue: pub fn JS_GetModulePrivate(module: *mut JSObject, dest: MutableHandleValue));
wrap!(glue: pub fn JS_GetScriptedCallerPrivate(cx: &mut JSContext, dest: MutableHandleValue));
wrap!(glue: pub fn JS_GetNaNValue(cx: &mut JSContext, dest: *mut Value));
wrap!(glue: pub fn JS_GetPositiveInfinityValue(cx: &mut JSContext, dest: *mut Value));
wrap!(glue: pub fn JS_GetEmptyStringValue(cx: &mut JSContext, dest: *mut Value));
wrap!(glue: pub fn JS_GetRegExpFlags(cx: &mut JSContext, obj: HandleObject, flags: *mut RegExpFlags));
wrap!(glue: pub fn EncodeStringToUTF8(cx: &mut JSContext, str_: HandleString, cb: EncodedStringCallback));
wrap!(glue: pub fn SetUpEventLoopDispatch(cx: &mut JSContext, callback: RustDispatchToEventLoopCallback, closure: *mut ::std::os::raw::c_void));
wrap!(glue: pub fn DispatchableRun(cx: &mut JSContext, ptr: *mut DispatchablePointer, mb: Dispatchable_MaybeShuttingDown));
wrap!(glue: pub fn DescribeScriptedCaller(cx: &mut JSContext, buffer: *mut ::std::os::raw::c_char, buflen: usize, line: *mut u32, col: *mut u32) -> bool);
wrap!(glue: pub fn SetDataPropertyDescriptor(desc: MutableHandle<PropertyDescriptor>, value: HandleValue, attrs: u32));
wrap!(glue: pub fn SetAccessorPropertyDescriptor(desc: MutableHandle<PropertyDescriptor>, getter: HandleObject, setter: HandleObject, attrs: u32));
wrap!(glue: pub fn DumpJSStack(cx: &mut JSContext, showArgs: bool, showLocals: bool, showThisProps: bool));
wrap!(glue: pub fn StackGCVectorValueLength(vec: Handle<StackGCVector<Value, TempAllocPolicy>>) -> u32);
wrap!(glue: pub fn StackGCVectorStringLength(vec: Handle<StackGCVector<*mut JSString, TempAllocPolicy>>) -> u32);
wrap!(glue: pub fn StackGCVectorValueAtIndex(vec: Handle<StackGCVector<Value, TempAllocPolicy>>, index: u32) -> *const Value);
wrap!(glue: pub fn StackGCVectorStringAtIndex(vec: Handle<StackGCVector<*mut JSString, TempAllocPolicy>>, index: u32) -> *const *mut JSString);
