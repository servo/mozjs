/* automatically generated by rust-bindgen 0.68.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub use crate::glue::EncodedStringCallback;
    pub(crate) use mozjs_sys::jsapi::*;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod __swappable_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod __swappable_with_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod __variant {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
        }
        pub mod pmr {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod placeholders {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod __exception_ptr {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod __ops {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub(crate) use mozjs_sys::jsapi::mozilla::*;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod tl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod span_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub(crate) use mozjs_sys::jsapi::js::*;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod jit {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
        }
        pub mod oom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod __gnu_debug {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod __cxxabiv1 {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod __pstl {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod execution {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod __internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub(crate) use mozjs_sys::jsapi::JS::*;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod shadow {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod Scalar {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod IPC {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type WantToMeasure =
        ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> bool>;
    pub type GetSize =
        ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> usize>;
    extern "C" {
        pub static mut gWantToMeasure: root::WantToMeasure;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JobQueueTraps {
        pub getIncumbentGlobal: ::std::option::Option<
            unsafe extern "C" fn(
                queue: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject,
        >,
        pub enqueuePromiseJob: ::std::option::Option<
            unsafe extern "C" fn(
                queue: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                job: root::JS::HandleObject,
                allocationSite: root::JS::HandleObject,
                incumbentGlobal: root::JS::HandleObject,
            ) -> bool,
        >,
        pub empty: ::std::option::Option<
            unsafe extern "C" fn(queue: *const ::std::os::raw::c_void) -> bool,
        >,
    }
    #[test]
    fn bindgen_test_layout_JobQueueTraps() {
        const UNINIT: ::std::mem::MaybeUninit<JobQueueTraps> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JobQueueTraps>(),
            24usize,
            concat!("Size of: ", stringify!(JobQueueTraps))
        );
        assert_eq!(
            ::std::mem::align_of::<JobQueueTraps>(),
            8usize,
            concat!("Alignment of ", stringify!(JobQueueTraps))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).getIncumbentGlobal) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JobQueueTraps),
                "::",
                stringify!(getIncumbentGlobal)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).enqueuePromiseJob) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JobQueueTraps),
                "::",
                stringify!(enqueuePromiseJob)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).empty) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JobQueueTraps),
                "::",
                stringify!(empty)
            )
        );
    }
    #[repr(C)]
    pub struct RustJobQueue__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct RustJobQueue {
        pub vtable_: *const RustJobQueue__bindgen_vtable,
        pub mTraps: root::JobQueueTraps,
        pub mQueue: *const ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_RustJobQueue() {
        const UNINIT: ::std::mem::MaybeUninit<RustJobQueue> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<RustJobQueue>(),
            40usize,
            concat!("Size of: ", stringify!(RustJobQueue))
        );
        assert_eq!(
            ::std::mem::align_of::<RustJobQueue>(),
            8usize,
            concat!("Alignment of ", stringify!(RustJobQueue))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mTraps) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RustJobQueue),
                "::",
                stringify!(mTraps)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mQueue) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(RustJobQueue),
                "::",
                stringify!(mQueue)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ReadableStreamUnderlyingSourceTraps {
        pub requestData: ::std::option::Option<
            unsafe extern "C" fn(
                source: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                desiredSize: usize,
            ),
        >,
        pub writeIntoReadRequestBuffer: ::std::option::Option<
            unsafe extern "C" fn(
                source: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                chunk: root::JS::HandleObject,
                length: usize,
                bytesWritten: *mut usize,
            ),
        >,
        pub cancel: ::std::option::Option<
            unsafe extern "C" fn(
                source: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                reason: root::JS::HandleValue,
                resolve_to: *mut root::JS::Value,
            ),
        >,
        pub onClosed: ::std::option::Option<
            unsafe extern "C" fn(
                source: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ),
        >,
        pub onErrored: ::std::option::Option<
            unsafe extern "C" fn(
                source: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                reason: root::JS::HandleValue,
            ),
        >,
        pub finalize: ::std::option::Option<
            unsafe extern "C" fn(source: *mut root::JS::ReadableStreamUnderlyingSource),
        >,
    }
    #[test]
    fn bindgen_test_layout_ReadableStreamUnderlyingSourceTraps() {
        const UNINIT: ::std::mem::MaybeUninit<ReadableStreamUnderlyingSourceTraps> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ReadableStreamUnderlyingSourceTraps>(),
            48usize,
            concat!("Size of: ", stringify!(ReadableStreamUnderlyingSourceTraps))
        );
        assert_eq!(
            ::std::mem::align_of::<ReadableStreamUnderlyingSourceTraps>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(ReadableStreamUnderlyingSourceTraps)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).requestData) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ReadableStreamUnderlyingSourceTraps),
                "::",
                stringify!(requestData)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).writeIntoReadRequestBuffer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ReadableStreamUnderlyingSourceTraps),
                "::",
                stringify!(writeIntoReadRequestBuffer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ReadableStreamUnderlyingSourceTraps),
                "::",
                stringify!(cancel)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).onClosed) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ReadableStreamUnderlyingSourceTraps),
                "::",
                stringify!(onClosed)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).onErrored) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ReadableStreamUnderlyingSourceTraps),
                "::",
                stringify!(onErrored)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ReadableStreamUnderlyingSourceTraps),
                "::",
                stringify!(finalize)
            )
        );
    }
    #[repr(C)]
    pub struct RustReadableStreamUnderlyingSource__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct RustReadableStreamUnderlyingSource {
        pub vtable_: *const RustReadableStreamUnderlyingSource__bindgen_vtable,
        pub mTraps: root::ReadableStreamUnderlyingSourceTraps,
        pub mSource: *const ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_RustReadableStreamUnderlyingSource() {
        const UNINIT: ::std::mem::MaybeUninit<RustReadableStreamUnderlyingSource> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<RustReadableStreamUnderlyingSource>(),
            64usize,
            concat!("Size of: ", stringify!(RustReadableStreamUnderlyingSource))
        );
        assert_eq!(
            ::std::mem::align_of::<RustReadableStreamUnderlyingSource>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(RustReadableStreamUnderlyingSource)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mTraps) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RustReadableStreamUnderlyingSource),
                "::",
                stringify!(mTraps)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mSource) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(RustReadableStreamUnderlyingSource),
                "::",
                stringify!(mSource)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSExternalStringCallbacksTraps {
        pub finalize: ::std::option::Option<
            unsafe extern "C" fn(privateData: *const ::std::os::raw::c_void, chars: *mut u16),
        >,
        pub sizeOfBuffer: ::std::option::Option<
            unsafe extern "C" fn(
                privateData: *const ::std::os::raw::c_void,
                chars: *const u16,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize,
        >,
    }
    #[test]
    fn bindgen_test_layout_JSExternalStringCallbacksTraps() {
        const UNINIT: ::std::mem::MaybeUninit<JSExternalStringCallbacksTraps> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSExternalStringCallbacksTraps>(),
            16usize,
            concat!("Size of: ", stringify!(JSExternalStringCallbacksTraps))
        );
        assert_eq!(
            ::std::mem::align_of::<JSExternalStringCallbacksTraps>(),
            8usize,
            concat!("Alignment of ", stringify!(JSExternalStringCallbacksTraps))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSExternalStringCallbacksTraps),
                "::",
                stringify!(finalize)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).sizeOfBuffer) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSExternalStringCallbacksTraps),
                "::",
                stringify!(sizeOfBuffer)
            )
        );
    }
    #[repr(C)]
    pub struct RustJSExternalStringCallbacks__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct RustJSExternalStringCallbacks {
        pub vtable_: *const RustJSExternalStringCallbacks__bindgen_vtable,
        pub mTraps: root::JSExternalStringCallbacksTraps,
        pub privateData: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_RustJSExternalStringCallbacks() {
        const UNINIT: ::std::mem::MaybeUninit<RustJSExternalStringCallbacks> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<RustJSExternalStringCallbacks>(),
            32usize,
            concat!("Size of: ", stringify!(RustJSExternalStringCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<RustJSExternalStringCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(RustJSExternalStringCallbacks))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mTraps) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RustJSExternalStringCallbacks),
                "::",
                stringify!(mTraps)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).privateData) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RustJSExternalStringCallbacks),
                "::",
                stringify!(privateData)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProxyTraps {
        pub enter: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                action: root::js::BaseProxyHandler_Action,
                bp: *mut bool,
            ) -> bool,
        >,
        pub getOwnPropertyDescriptor: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool,
        >,
        pub defineProperty: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub ownPropertyKeys: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool,
        >,
        pub delete_: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub enumerate: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool,
        >,
        pub getPrototypeIfOrdinary: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isOrdinary: *mut bool,
                protop: root::JS::MutableHandleObject,
            ) -> bool,
        >,
        pub getPrototype: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                protop: root::JS::MutableHandleObject,
            ) -> bool,
        >,
        pub setPrototype: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                proto: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub setImmutablePrototype: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool,
        >,
        pub preventExtensions: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub isExtensible: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool,
        >,
        pub has: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool,
        >,
        pub get: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >,
        pub set: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub call: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool,
        >,
        pub construct: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool,
        >,
        pub hasOwn: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool,
        >,
        pub getOwnEnumerablePropertyKeys: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool,
        >,
        pub nativeCall: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                test: root::JS::IsAcceptableThis,
                impl_: root::JS::NativeImpl,
                args: root::JS::CallArgs,
            ) -> bool,
        >,
        pub objectClassIs: ::std::option::Option<
            unsafe extern "C" fn(
                obj: root::JS::HandleObject,
                classValue: root::js::ESClass,
                cx: *mut root::JSContext,
            ) -> bool,
        >,
        pub className: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *const ::std::os::raw::c_char,
        >,
        pub fun_toString: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isToString: bool,
            ) -> *mut root::JSString,
        >,
        pub boxedValue_unbox: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >,
        pub defaultValue: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                hint: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >,
        pub trace: ::std::option::Option<
            unsafe extern "C" fn(trc: *mut root::JSTracer, proxy: *mut root::JSObject),
        >,
        pub finalize: ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JS::GCContext, proxy: *mut root::JSObject),
        >,
        pub objectMoved: ::std::option::Option<
            unsafe extern "C" fn(proxy: *mut root::JSObject, old: *mut root::JSObject) -> usize,
        >,
        pub isCallable:
            ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> bool>,
        pub isConstructor:
            ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> bool>,
    }
    #[test]
    fn bindgen_test_layout_ProxyTraps() {
        const UNINIT: ::std::mem::MaybeUninit<ProxyTraps> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ProxyTraps>(),
            240usize,
            concat!("Size of: ", stringify!(ProxyTraps))
        );
        assert_eq!(
            ::std::mem::align_of::<ProxyTraps>(),
            8usize,
            concat!("Alignment of ", stringify!(ProxyTraps))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(enter)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).getOwnPropertyDescriptor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(getOwnPropertyDescriptor)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).defineProperty) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(defineProperty)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).ownPropertyKeys) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(ownPropertyKeys)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).delete_) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(delete_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).enumerate) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(enumerate)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).getPrototypeIfOrdinary) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(getPrototypeIfOrdinary)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).getPrototype) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(getPrototype)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).setPrototype) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(setPrototype)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).setImmutablePrototype) as usize - ptr as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(setImmutablePrototype)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).preventExtensions) as usize - ptr as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(preventExtensions)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).isExtensible) as usize - ptr as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(isExtensible)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).has) as usize - ptr as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(has)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(get)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(set)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).call) as usize - ptr as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(call)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).construct) as usize - ptr as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(construct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).hasOwn) as usize - ptr as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(hasOwn)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).getOwnEnumerablePropertyKeys) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(getOwnEnumerablePropertyKeys)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).nativeCall) as usize - ptr as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(nativeCall)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).objectClassIs) as usize - ptr as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(objectClassIs)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).className) as usize - ptr as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(className)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).fun_toString) as usize - ptr as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(fun_toString)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).boxedValue_unbox) as usize - ptr as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(boxedValue_unbox)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).defaultValue) as usize - ptr as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(defaultValue)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).trace) as usize - ptr as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(trace)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(finalize)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).objectMoved) as usize - ptr as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(objectMoved)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).isCallable) as usize - ptr as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(isCallable)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).isConstructor) as usize - ptr as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(ProxyTraps),
                "::",
                stringify!(isConstructor)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZL13HandlerFamily"]
        pub static mut HandlerFamily: ::std::os::raw::c_int;
    }
    #[repr(C)]
    pub struct WrapperProxyHandler__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct WrapperProxyHandler {
        pub vtable_: *const WrapperProxyHandler__bindgen_vtable,
        pub __bindgen_padding_0: [u64; 2usize],
        pub mTraps: root::ProxyTraps,
    }
    #[test]
    fn bindgen_test_layout_WrapperProxyHandler() {
        const UNINIT: ::std::mem::MaybeUninit<WrapperProxyHandler> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<WrapperProxyHandler>(),
            264usize,
            concat!("Size of: ", stringify!(WrapperProxyHandler))
        );
        assert_eq!(
            ::std::mem::align_of::<WrapperProxyHandler>(),
            8usize,
            concat!("Alignment of ", stringify!(WrapperProxyHandler))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mTraps) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(WrapperProxyHandler),
                "::",
                stringify!(mTraps)
            )
        );
    }
    #[repr(C)]
    pub struct ForwardingProxyHandler__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct ForwardingProxyHandler {
        pub vtable_: *const ForwardingProxyHandler__bindgen_vtable,
        pub __bindgen_padding_0: [u64; 2usize],
        pub mTraps: root::ProxyTraps,
        pub mExtra: *const ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_ForwardingProxyHandler() {
        const UNINIT: ::std::mem::MaybeUninit<ForwardingProxyHandler> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ForwardingProxyHandler>(),
            272usize,
            concat!("Size of: ", stringify!(ForwardingProxyHandler))
        );
        assert_eq!(
            ::std::mem::align_of::<ForwardingProxyHandler>(),
            8usize,
            concat!("Alignment of ", stringify!(ForwardingProxyHandler))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mTraps) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ForwardingProxyHandler),
                "::",
                stringify!(mTraps)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mExtra) as usize - ptr as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(ForwardingProxyHandler),
                "::",
                stringify!(mExtra)
            )
        );
    }
    #[repr(C)]
    pub struct ServoDOMVisitor__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct ServoDOMVisitor {
        pub vtable_: *const ServoDOMVisitor__bindgen_vtable,
        pub __bindgen_padding_0: u64,
        pub get_size: root::GetSize,
    }
    #[test]
    fn bindgen_test_layout_ServoDOMVisitor() {
        const UNINIT: ::std::mem::MaybeUninit<ServoDOMVisitor> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ServoDOMVisitor>(),
            24usize,
            concat!("Size of: ", stringify!(ServoDOMVisitor))
        );
        assert_eq!(
            ::std::mem::align_of::<ServoDOMVisitor>(),
            8usize,
            concat!("Alignment of ", stringify!(ServoDOMVisitor))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ServoDOMVisitor),
                "::",
                stringify!(get_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSPrincipalsCallbacks {
        pub write: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSPrincipals,
                cx: *mut root::JSContext,
                writer: *mut root::JSStructuredCloneWriter,
            ) -> bool,
        >,
        pub isSystemOrAddonPrincipal:
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::JSPrincipals) -> bool>,
    }
    #[test]
    fn bindgen_test_layout_JSPrincipalsCallbacks() {
        const UNINIT: ::std::mem::MaybeUninit<JSPrincipalsCallbacks> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<JSPrincipalsCallbacks>(),
            16usize,
            concat!("Size of: ", stringify!(JSPrincipalsCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPrincipalsCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPrincipalsCallbacks))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPrincipalsCallbacks),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).isSystemOrAddonPrincipal) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPrincipalsCallbacks),
                "::",
                stringify!(isSystemOrAddonPrincipal)
            )
        );
    }
    #[repr(C)]
    pub struct RustJSPrincipals__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct RustJSPrincipals {
        pub vtable_: *const RustJSPrincipals__bindgen_vtable,
        pub __bindgen_padding_0: u64,
        pub callbacks: root::JSPrincipalsCallbacks,
        pub privateData: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_RustJSPrincipals() {
        const UNINIT: ::std::mem::MaybeUninit<RustJSPrincipals> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<RustJSPrincipals>(),
            40usize,
            concat!("Size of: ", stringify!(RustJSPrincipals))
        );
        assert_eq!(
            ::std::mem::align_of::<RustJSPrincipals>(),
            8usize,
            concat!("Alignment of ", stringify!(RustJSPrincipals))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).callbacks) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RustJSPrincipals),
                "::",
                stringify!(callbacks)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).privateData) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(RustJSPrincipals),
                "::",
                stringify!(privateData)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z19ShouldMeasureObjectP8JSObjectPP11nsISupports"]
        pub fn ShouldMeasureObject(
            obj: *mut root::JSObject,
            iface: *mut *mut root::nsISupports,
        ) -> bool;
    }
    extern "C" {
        pub fn CreateRustJSPrincipals(
            callbacks: *const root::JSPrincipalsCallbacks,
            privateData: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSPrincipals;
    }
    extern "C" {
        pub fn DestroyRustJSPrincipals(principals: *mut root::JSPrincipals);
    }
    extern "C" {
        pub fn GetRustJSPrincipalsPrivate(
            principals: *mut root::JSPrincipals,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn InvokeGetOwnPropertyDescriptor(
            handler: *const ::std::os::raw::c_void,
            cx: *mut root::JSContext,
            proxy: root::JS::HandleObject,
            id: root::JS::HandleId,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            isNone: *mut bool,
        ) -> bool;
    }
    extern "C" {
        pub fn InvokeHasOwn(
            handler: *const ::std::os::raw::c_void,
            cx: *mut root::JSContext,
            proxy: root::JS::HandleObject,
            id: root::JS::HandleId,
            bp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        pub fn RUST_JS_NumberValue(d: f64, dest: *mut root::JS::Value);
    }
    extern "C" {
        pub fn RUST_FUNCTION_VALUE_TO_JITINFO(v: root::JS::Value) -> *const root::JSJitInfo;
    }
    extern "C" {
        pub fn CreateCallArgsFromVp(
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> root::JS::CallArgs;
    }
    extern "C" {
        pub fn CallJitGetterOp(
            info: *const root::JSJitInfo,
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool;
    }
    extern "C" {
        pub fn CallJitSetterOp(
            info: *const root::JSJitInfo,
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool;
    }
    extern "C" {
        pub fn CallJitMethodOp(
            info: *const root::JSJitInfo,
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            argc: u32,
            vp: *mut root::JS::Value,
        ) -> bool;
    }
    extern "C" {
        pub fn CreateProxyHandler(
            aTraps: *const root::ProxyTraps,
            aExtra: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn CreateWrapperProxyHandler(
            aTraps: *const root::ProxyTraps,
        ) -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn GetCrossCompartmentWrapper() -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn GetSecurityWrapper() -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn DeleteCompileOptions(aOpts: *mut root::JS::ReadOnlyCompileOptions);
    }
    extern "C" {
        pub fn NewCompileOptions(
            aCx: *mut root::JSContext,
            aFile: *const ::std::os::raw::c_char,
            aLine: ::std::os::raw::c_uint,
        ) -> *mut root::JS::ReadOnlyCompileOptions;
    }
    extern "C" {
        pub fn NewProxyObject(
            aCx: *mut root::JSContext,
            aHandler: *const ::std::os::raw::c_void,
            aPriv: root::JS::HandleValue,
            proto: *mut root::JSObject,
            aClass: *const root::JSClass,
            aLazyProto: bool,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        pub fn WrapperNew(
            aCx: *mut root::JSContext,
            aObj: root::JS::HandleObject,
            aHandler: *const ::std::os::raw::c_void,
            aClass: *const root::JSClass,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_ZL16WindowProxyClass"]
        pub static WindowProxyClass: root::JSClass;
    }
    extern "C" {
        pub fn GetWindowProxyClass() -> *const root::JSClass;
    }
    extern "C" {
        pub fn NewWindowProxy(
            aCx: *mut root::JSContext,
            aObj: root::JS::HandleObject,
            aHandler: *const ::std::os::raw::c_void,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        pub fn GetProxyReservedSlot(
            obj: *mut root::JSObject,
            slot: u32,
            dest: *mut root::JS::Value,
        );
    }
    extern "C" {
        pub fn GetProxyPrivate(obj: *mut root::JSObject, dest: *mut root::JS::Value);
    }
    extern "C" {
        pub fn SetProxyReservedSlot(
            obj: *mut root::JSObject,
            slot: u32,
            val: *const root::JS::Value,
        );
    }
    extern "C" {
        pub fn SetProxyPrivate(obj: *mut root::JSObject, expando: *const root::JS::Value);
    }
    extern "C" {
        pub fn RUST_JSID_IS_INT(id: root::JS::HandleId) -> bool;
    }
    extern "C" {
        pub fn int_to_jsid(i: i32, id: root::JS::MutableHandleId);
    }
    extern "C" {
        pub fn RUST_JSID_TO_INT(id: root::JS::HandleId) -> i32;
    }
    extern "C" {
        pub fn RUST_JSID_IS_STRING(id: root::JS::HandleId) -> bool;
    }
    extern "C" {
        pub fn RUST_JSID_TO_STRING(id: root::JS::HandleId) -> *mut root::JSString;
    }
    extern "C" {
        pub fn RUST_SYMBOL_TO_JSID(sym: *mut root::JS::Symbol, id: root::JS::MutableHandleId);
    }
    extern "C" {
        pub fn RUST_JSID_IS_VOID(id: root::JS::HandleId) -> bool;
    }
    extern "C" {
        pub fn SetBuildId(
            buildId: *mut root::JS::BuildIdCharVector,
            chars: *const ::std::os::raw::c_char,
            len: usize,
        ) -> bool;
    }
    extern "C" {
        pub fn RUST_SET_JITINFO(func: *mut root::JSFunction, info: *const root::JSJitInfo);
    }
    extern "C" {
        pub fn RUST_INTERNED_STRING_TO_JSID(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            id: root::JS::MutableHandleId,
        );
    }
    extern "C" {
        pub fn RUST_js_GetErrorMessage(
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: u32,
        ) -> *const root::JSErrorFormatString;
    }
    extern "C" {
        pub fn IsProxyHandlerFamily(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        pub fn GetProxyHandlerFamily() -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn GetProxyHandlerExtra(obj: *mut root::JSObject) -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn GetProxyHandler(obj: *mut root::JSObject) -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn ReportErrorASCII(aCx: *mut root::JSContext, aError: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn ReportErrorUTF8(aCx: *mut root::JSContext, aError: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn IsWrapper(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        pub fn UnwrapObjectStatic(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        pub fn UnwrapObjectDynamic(
            obj: *mut root::JSObject,
            cx: *mut root::JSContext,
            stopAtWindowProxy: bool,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        pub fn UncheckedUnwrapObject(
            obj: *mut root::JSObject,
            stopAtWindowProxy: bool,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        pub fn CreateRootedIdVector(
            cx: *mut root::JSContext,
        ) -> *mut root::JS::PersistentRootedIdVector;
    }
    extern "C" {
        pub fn GetIdVectorAddress(
            v: *mut root::JS::PersistentRootedIdVector,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn SliceRootedIdVector(
            v: *const root::JS::PersistentRootedIdVector,
            length: *mut usize,
        ) -> *const root::jsid;
    }
    extern "C" {
        pub fn AppendToIdVector(v: root::JS::MutableHandleIdVector, id: root::JS::HandleId)
            -> bool;
    }
    extern "C" {
        pub fn DestroyRootedIdVector(v: *mut root::JS::PersistentRootedIdVector);
    }
    extern "C" {
        pub fn CreateRootedObjectVector(
            aCx: *mut root::JSContext,
        ) -> *mut root::JS::PersistentRootedObjectVector;
    }
    extern "C" {
        pub fn GetObjectVectorAddress(
            v: *mut root::JS::PersistentRootedObjectVector,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn AppendToRootedObjectVector(
            v: *mut root::JS::PersistentRootedObjectVector,
            obj: *mut root::JSObject,
        ) -> bool;
    }
    extern "C" {
        pub fn DeleteRootedObjectVector(v: *mut root::JS::PersistentRootedObjectVector);
    }
    extern "C" {
        pub fn CollectServoSizes(
            cx: *mut root::JSContext,
            sizes: *mut root::JS::ServoSizes,
            gs: root::GetSize,
        ) -> bool;
    }
    extern "C" {
        pub fn InitializeMemoryReporter(wtm: root::WantToMeasure);
    }
    extern "C" {
        pub fn CallValueTracer(
            trc: *mut root::JSTracer,
            valuep: *mut root::JS::Heap<root::JS::Value>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallIdTracer(
            trc: *mut root::JSTracer,
            idp: *mut root::JS::Heap<root::jsid>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallObjectTracer(
            trc: *mut root::JSTracer,
            objp: *mut root::JS::Heap<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallStringTracer(
            trc: *mut root::JSTracer,
            strp: *mut root::JS::Heap<*mut root::JSString>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallSymbolTracer(
            trc: *mut root::JSTracer,
            bip: *mut root::JS::Heap<*mut root::JS::Symbol>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallBigIntTracer(
            trc: *mut root::JSTracer,
            bip: *mut root::JS::Heap<*mut root::JS::BigInt>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallScriptTracer(
            trc: *mut root::JSTracer,
            scriptp: *mut root::JS::Heap<*mut root::JSScript>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallFunctionTracer(
            trc: *mut root::JSTracer,
            funp: *mut root::JS::Heap<*mut root::JSFunction>,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallUnbarrieredObjectTracer(
            trc: *mut root::JSTracer,
            objp: *mut *mut root::JSObject,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallObjectRootTracer(
            trc: *mut root::JSTracer,
            objp: *mut *mut root::JSObject,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn CallValueRootTracer(
            trc: *mut root::JSTracer,
            valp: *mut root::JS::Value,
            name: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn IsDebugBuild() -> bool;
    }
    extern "C" {
        pub fn GetInt8ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i8,
        );
    }
    extern "C" {
        pub fn GetUint8ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        );
    }
    extern "C" {
        pub fn GetUint8ClampedArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        );
    }
    extern "C" {
        pub fn GetInt16ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i16,
        );
    }
    extern "C" {
        pub fn GetUint16ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        );
    }
    extern "C" {
        pub fn GetInt32ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i32,
        );
    }
    extern "C" {
        pub fn GetUint32ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u32,
        );
    }
    extern "C" {
        pub fn GetFloat32ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f32,
        );
    }
    extern "C" {
        pub fn GetFloat64ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f64,
        );
    }
    extern "C" {
        pub fn NewJSAutoStructuredCloneBuffer(
            scope: root::JS::StructuredCloneScope,
            callbacks: *const root::JSStructuredCloneCallbacks,
        ) -> *mut root::JSAutoStructuredCloneBuffer;
    }
    extern "C" {
        pub fn DeleteJSAutoStructuredCloneBuffer(buf: *mut root::JSAutoStructuredCloneBuffer);
    }
    extern "C" {
        pub fn GetLengthOfJSStructuredCloneData(data: *mut root::JSStructuredCloneData) -> usize;
    }
    extern "C" {
        pub fn CopyJSStructuredCloneData(src: *mut root::JSStructuredCloneData, dest: *mut u8);
    }
    extern "C" {
        pub fn WriteBytesToJSStructuredCloneData(
            src: *const u8,
            len: usize,
            dest: *mut root::JSStructuredCloneData,
        ) -> bool;
    }
    extern "C" {
        pub fn JS_GetPromiseResult(
            promise: root::JS::HandleObject,
            dest: root::JS::MutableHandleValue,
        );
    }
    extern "C" {
        pub fn JS_GetScriptPrivate(script: *mut root::JSScript, dest: root::JS::MutableHandleValue);
    }
    extern "C" {
        pub fn JS_GetModulePrivate(module: *mut root::JSObject, dest: root::JS::MutableHandleValue);
    }
    extern "C" {
        pub fn JS_GetNaNValue(cx: *mut root::JSContext, dest: *mut root::JS::Value);
    }
    extern "C" {
        pub fn JS_GetPositiveInfinityValue(cx: *mut root::JSContext, dest: *mut root::JS::Value);
    }
    extern "C" {
        pub fn JS_GetEmptyStringValue(cx: *mut root::JSContext, dest: *mut root::JS::Value);
    }
    extern "C" {
        pub fn JS_GetReservedSlot(obj: *mut root::JSObject, index: u32, dest: *mut root::JS::Value);
    }
    extern "C" {
        pub fn EncodeStringToUTF8(
            cx: *mut root::JSContext,
            str_: root::JS::HandleString,
            cb: root::EncodedStringCallback,
        );
    }
    extern "C" {
        pub fn JS_ForgetStringLinearness(str_: *mut root::JSLinearString) -> *mut root::JSString;
    }
    extern "C" {
        pub fn CreateJobQueue(
            aTraps: *const root::JobQueueTraps,
            aQueue: *const ::std::os::raw::c_void,
        ) -> *mut root::JS::JobQueue;
    }
    extern "C" {
        pub fn DeleteJobQueue(queue: *mut root::JS::JobQueue);
    }
    extern "C" {
        pub fn CreateReadableStreamUnderlyingSource(
            aTraps: *const root::ReadableStreamUnderlyingSourceTraps,
            aSource: *const ::std::os::raw::c_void,
        ) -> *mut root::JS::ReadableStreamUnderlyingSource;
    }
    extern "C" {
        pub fn DeleteReadableStreamUnderlyingSource(
            source: *mut root::JS::ReadableStreamUnderlyingSource,
        );
    }
    extern "C" {
        pub fn CreateJSExternalStringCallbacks(
            aTraps: *const root::JSExternalStringCallbacksTraps,
            privateData: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSExternalStringCallbacks;
    }
    extern "C" {
        pub fn DeleteJSExternalStringCallbacks(callbacks: *mut root::JSExternalStringCallbacks);
    }
    extern "C" {
        pub fn DispatchableRun(
            cx: *mut root::JSContext,
            ptr: *mut root::JS::Dispatchable,
            mb: root::JS::Dispatchable_MaybeShuttingDown,
        );
    }
    extern "C" {
        pub fn StreamConsumerConsumeChunk(
            sc: *mut root::JS::StreamConsumer,
            begin: *const u8,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        pub fn StreamConsumerStreamEnd(sc: *mut root::JS::StreamConsumer);
    }
    extern "C" {
        pub fn StreamConsumerStreamError(sc: *mut root::JS::StreamConsumer, errorCode: usize);
    }
    extern "C" {
        pub fn StreamConsumerNoteResponseURLs(
            sc: *mut root::JS::StreamConsumer,
            maybeUrl: *const ::std::os::raw::c_char,
            maybeSourceMapUrl: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn DescribeScriptedCaller(
            cx: *mut root::JSContext,
            buffer: *mut ::std::os::raw::c_char,
            buflen: usize,
            line: *mut u32,
            col: *mut u32,
        ) -> bool;
    }
    extern "C" {
        pub fn SetDataPropertyDescriptor(
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            value: root::JS::HandleValue,
            attrs: u32,
        );
    }
    extern "C" {
        pub fn SetAccessorPropertyDescriptor(
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            getter: root::JS::HandleObject,
            setter: root::JS::HandleObject,
            attrs: u32,
        );
    }
    extern "C" {
        pub fn FinishOffThreadStencil(
            cx: *mut root::JSContext,
            token: *mut root::JS::OffThreadToken,
            storage: *mut root::JS::InstantiationStorage,
            stencil: *mut root::already_AddRefed<root::JS::Stencil>,
        );
    }
}
